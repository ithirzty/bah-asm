#define generateTypeConversion(val bahValue*, type bahType*) asmSymbol
#define generateReflection(val bahValue*) asmSymbol
#define generateBahValueSymbol(val bahValue*, shortcut asmSymbol*) asmSymbol

getStrLen(s str) uint {
    l = len(s)
    n = 0
    i=1; for i+1 < l, i++ {
        n++
        if s[i] == <char>92 {
            if s[i+1] == <char>10 {
                i++
            } else if s[i+1] == '0' {
                i++
                start = i
                for i-start < 2, i++ {
                    if isNumber(s[i]) == false {
                        break
                    }
                }
                i--
            }
            i++
        }
    }

    return n
}

// isSameValue(a bahValue*, b bahValue*) bool {
//     if a.isPointer != b.isPointer {
//         return false
//     }

//     if a.isOperation {
//         if b.isOperation == false {
//             return false
//         }

//         return isSameValue(a.left, b.left) && isSameValue(a.right, b.right)
//     }

//     if a.isStaticValue {
//         if b.isStaticValue == false {
//             return false
//         }

//         return a.tok.cont == b.tok.cont
//     }

//     if a.isFunctionSym {
//         if b.isFunctionSym == false {
//             return false
//         }

//         return a.tok.cont == b.tok.cont
//     }

//     if a.isFunctionCall || b.isFunctionCall {
//         if a.isFunctionCall == b.isFunctionCall && (a.left.tok.cont == "len" || a.left.tok.cont == "sizeof") && a.left.tok.cont == b.left.tok.cont {
//             return true
//         }
//         return false
//     }

//     if a.isVariable {
//         if b.isVariable == false {
//             return false
//         }

//         return a.tok.cont == b.tok.cont
//     }

//     if a.isUnary {
//         if b.isUnary == false {
//             return false
//         }

//         return isSameValue(a.left, b.left)
//     }

//     if a.isCast {
//         for a.isCast {
//             a = a.left
//         }

//         for b.isCast {
//             b = b.left
//         }

//         return isSameValue(a, b)
//     }

//     if a.isIndexed {
//         if b.isIndexed == false {
//             return false
//         }

//         return isSameValue(a.left, b.left) && isSameValue(a.right, b.right)
//     }

//     if a.isSplit {
//         if b.isSplit == false {
//             return false
//         }

//         return isSameValue(a.left, b.left) && isSameValue(a.right.left, b.right.left) && isSameValue(a.right.right, b.right.right)
//     }

//     if a.isStruct {
//         if b.isStruct == false {
//             return false
//         }

//         return isSameValue(a.left, b.left) && a.right.tok.cont == b.right.tok.cont
//     }

//     if a.isGenerated {
//         if b.isGenerated == false {
//             return false
//         }

//         return gen.isSameArgAndSize(a.sym, b.sym)
//     }

//     return false
// }

// optimizeCostlyValue(val bahValue*, values []bahValue*) {
//     isEnd = false
//     if values == null {
//         isEnd = true
//         values = []bahValue*
//     }

//     if val.isStruct {
//         if val.type.isPtr {
//             values[len(values)] = val
//         }
//         optimizeCostlyValue(val.left, values)
//     }

//     if val.isIndexed {
//         if val.type.isPtr {
//             values[len(values)] = val
//         }
//         optimizeCostlyValue(val.left, values)
//         optimizeCostlyValue(val.right, values)
//     }

//     if val.isFunctionCall {
//         currArg = val.right
//         for currArg != null, currArg = currArg.right {
//             optimizeCostlyValue(currArg.left, values)
//         }
//     }

//     if val.isOperation && val.isSelfOp == false && val.tok.cont != "||" {
//         optimizeCostlyValue(val.left, values)
//         optimizeCostlyValue(val.right, values)
//     }

//     if isEnd == false {
//         return
//     }

//     i=0; for i < len(values), i++ {
//         if values[i].isGenerated {
//             continue
//         }
//         j=i+1; for j < len(values), j++ {
//             if isSameValue(values[i], values[j]) {
//                 printDebugContext()
//                 vj = values[j]
//                 vi = values[i]

//                 vj.sym = generateBahValueSymbol(vj, null)
//                 vj.sym = gen.generateTmpSym(vj.sym, vj.sym.size)
//                 vi.sym = vj.sym
//                 vj.isGenerated = true
//                 vi.isGenerated = true
//             }
//         }
//     }
// }

generateValueOperation(tok bahToken*, left asmSymbol, right asmSymbol, type bahType*) asmSymbol {
    opStr = tok.cont

    tp = ASM_NUM_INT
    if type.type == BAH_TYPE_UINT {
        tp = ASM_NUM_UINT
    } else if type.type == BAH_TYPE_FLOAT {
        tp = ASM_NUM_FLOAT
    } else if type.isPtr && type.child.type == BAH_TYPE_STRCT {
        methodName = ""
        if opStr[0] == '+' {
            methodName = ".add"
        } else if opStr[0] == '-' {
            methodName = ".sub"
        } else if opStr[0] == '*' {
            methodName = ".mult"
        } else if opStr[0] == '/' {
            methodName = ".div"
        }

        if len(methodName) != 0 {
            method = parserCtx.findFunc(type.child.child.name+methodName)

            if method != null {
                if compatibleTypes(type, method.type.child) == false {
                    throwError(tok, "Wrong type in call to "+method.name)
                }

                if compatibleTypes(type, method.type.child.next) == false {
                    throwError(tok, "Wrong type in call to "+method.name)
                }

                if compatibleTypes(type, method.type.ret) == false {
                    throwError(tok, method.name+"'s return type is not the same as its arguments.")
                }

                gen.generateFnCallStart()
                gen.generateFnCallArgument(left)
                gen.generateFnCallArgument(right)
                return gen.generateFnCall(asmSymbolValue(method.name), method.type.ret.size, null, false)
            }
        }

    } else if type.type == BAH_TYPE_STR {
        if opStr == "==" {
            gen.generateFnCallStart()
            gen.generateFnCallArgument(left)
            gen.generateFnCallArgument(right)
            return gen.generateFnCall(asmSymbolValue(strCompareFunction), 1, null, false)
        } else if opStr == "!=" {
            gen.generateFnCallStart()
            gen.generateFnCallArgument(left)
            gen.generateFnCallArgument(right)
            res = gen.generateFnCall(asmSymbolValue(strCompareFunction), 1, null, false)
            stcInt = gen.staticInt("0")
            stcInt.size = 1
            return gen.generateCompare(res, stcInt, ASM_OP_EQ, false)
        }

        if opStr != "in" {
            throwError(tok, "Invalid operation.")
        }
    }

    //handle strings concat and struct methods special operations
    //also handle conversions
    //also handle other operations
    if opStr == "*" || opStr == "*=" {
        return gen.generateOpMult(left, right, tp)
    }
    
    if opStr == "/" || opStr == "/=" {
        return gen.generateOpDiv(left, right, tp)
    }
    
    if opStr == "%" || opStr == "%=" {
        if tp == ASM_NUM_FLOAT {
            throwError(tok, "Cannot do modulo operation on floats.")
        }
        return gen.generateOpMod(left, right, tp)
    }
    
    if opStr == "-" || opStr == "-=" {
        return gen.generateOpSub(left, right, tp)
    }
    
    if opStr == "+" || opStr == "+=" {
        return gen.generateOpAdd(left, right, tp)
    }

    if opStr == ">>" {
        return gen.generateOpBitwise(left, right, ASM_OP_BITWISE_RIGHT)
    }

    if opStr == "<<" {
        return gen.generateOpBitwise(left, right, ASM_OP_BITWISE_LEFT)
    }

    if opStr == "&" {
        return gen.generateOpBitwise(left, right, ASM_OP_BITWISE_AND)
    }

    if opStr == "|" {
        return gen.generateOpBitwise(left, right, ASM_OP_BITWISE_OR)
    }

    if opStr == "^" {
        return gen.generateOpBitwise(left, right, ASM_OP_BITWISE_XOR)
    }

    if opStr == "in" {
        right = gen.generateTmpSym(right, 8)

        retSym = gen.generateTmpDecl(1, false)
        gen.generateVarSet(retSym, gen.staticInt("0"), true)

        index = asmSymbolReg(ASM_reg_id_op, 8, gen.regIndex+2)
        uintType = new bahType {
            type: BAH_TYPE_UINT
            size: 8
        }
        gen.generateMoveValue(gen.staticInt("0"), index)

        elemSizeSym = gen.generateSymOffset(right, gen.staticInt(uintToStr(ARR_ELEMSIZE_OFFSET)))
        elemSizeSym.level = 1
        elemSizeSym = gen.generateTmpSym(elemSizeSym, 8)

        gen.generateFor()


        arrLen = gen.generateSymOffset(right, gen.staticInt(uintToStr(ARR_LENGTH_OFFSET)))
        arrLen = gen.generateDereference(arrLen)

        tmpTok = *tok
        tmpTok.cont = "<"
        gen.generateForCond(generateValueOperation(&tmpTok, index, arrLen, uintType))

        gen.generateSelfOp(index, ASM_SELF_OP_ADD)

        gen.generateForIncr()


        tmpTok = *tok
        tmpTok.cont = "=="

        arrElem = gen.generateDereference(right)
        arrElem = gen.generateSymOffset(arrElem, gen.generateOpMult(elemSizeSym, index, ASM_NUM_UINT))
        arrElem.size = type.size
        arrElem.level = 1

        gen.generateIf(generateValueOperation(&tmpTok, left, arrElem, type))
        gen.generateVarSet(retSym, gen.staticInt("1"), true)
        gen.generateForBreak()

        gen.generateEndIf()
        gen.generateForEnd()

        retSym.size = 1

        return retSym
    }
    
    leftSym = left
    if leftSym.isTmp == false && leftSym.stack == false {
        leftSym = gen.generateTmpSym(leftSym, leftSym.size)
    }

    if opStr == "<" {
        return gen.generateCompare(leftSym, right, ASM_OP_LESS, tp == ASM_NUM_UINT)
    }
    
    if opStr == ">" {
        return gen.generateCompare(leftSym, right, ASM_OP_GREATER, tp == ASM_NUM_UINT)
    }
    
    if opStr == "<=" {
        return gen.generateCompare(leftSym, right, ASM_OP_LESS_OR_EQ, tp == ASM_NUM_UINT)
    }
    
    if opStr == ">=" {
        return gen.generateCompare(leftSym, right, ASM_OP_GREATER_OR_EQ, tp == ASM_NUM_UINT)
    }
    
    if opStr == "==" {
        return gen.generateCompare(leftSym, right, ASM_OP_EQ, tp == ASM_NUM_UINT)
    }
    
    if opStr == "!=" {
        return gen.generateCompare(leftSym, right, ASM_OP_NOT_EQ, tp == ASM_NUM_UINT)
    }

    throwError(tok, "Internal error: could not generate operation.")

    n = asmSymbol{}
    return n
}

generateBahValueSymbol(val bahValue*, shortcut asmSymbol*) asmSymbol {
    r = asmSymbol {}
    
    if val.type != null {
        for val.type.type == BAH_TYPE_CUSTOM_TYPE {
            val.type = val.type.child
        }
    }

    if val.isPointer {
        actualValue = val
        for actualValue.value == BAH_VALUE_CAST {
            actualValue = actualValue.left
        }
        if actualValue.value != BAH_VALUE_VAR && actualValue.value != BAH_VALUE_REG && actualValue.value != BAH_VALUE_FUNC_SYM && actualValue.value != BAH_VALUE_STRUCT {
            val.isPointer = false
            sym = generateBahValueSymbol(val, null)
            sym.size = 8
            if sym.level == 1 {
                sym.level = 0
                return sym
            }

            sym.level = -1
            return sym
        }
    }

    if val.value == BAH_VALUE_CAST {
        if val.left.value == BAH_VALUE_REG {
            if val.left.tok.cont[1:] == "data" {
                sym = asmSymbolStaticName("__data_start")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            } else if val.left.tok.cont[1:] == "bss" {
                sym = asmSymbolStaticName("__bss_start")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            } else if val.left.tok.cont[1:] == "end" {
                sym = asmSymbolStaticName("__bss_end")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            } else if val.left.tok.cont[1:] == "debug" {
                sym = asmSymbolStaticName(".bah_debug_info")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            } else if val.left.tok.cont[1:] == "debugLines" {
                sym = asmSymbolStaticName(".bah_debug_info_lines")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            }
            r.isValue = true
            r.name = "%"+val.left.tok.cont[1:]
            r.size = val.type.size
            return r
        }
        return generateTypeConversion(val.left, val.type)
    }

    if val.value == BAH_VALUE_REG {
        throwError(&val.tok, "Cannot use a register without casting it.")
    }

    if val.value == BAH_VALUE_DECLARATION {

        if val.type.type == BAH_TYPE_BUFFER {
            sym = gen.generateVarDecl("buffer_declare", val.type.size, false)
            sym.level = -1
            sym.size = 8
            return sym
        }

        if val.type.type == BAH_TYPE_STRCT || val.type.isPtr && val.type.child.type == BAH_TYPE_STRCT {
            sym asmSymbol

            structType = val.type
            if val.type.isPtr {
                structType = val.type.child
            }
            initFn = parserCtx.findMethod(structType, "_init")

            if val.type.isPtr == false {
                sym = gen.generateVarDecl("strct_declare", val.type.size, true)
                currVal = val.left
                for currVal != null, currVal = currVal.left {
                    fieldSym = asmSymbolStack(sym.address - currVal.type.offset, currVal.type.size)
                    fieldVal = generateBahValueSymbol(currVal.right, &fieldSym)
                    if isEmptySymbol(fieldVal) == false {
                        gen.generateVarSet(fieldSym, fieldVal, currVal.type.type == BAH_TYPE_UINT)
                    }
                }

                if initFn != null {
                    gen.generateFnCallStart()
                    pSym = sym
                    pSym.level = -1
                    pSym.size = 8
                    gen.generateFnCallArgument(pSym)
                    gen.generateFnCall(asmSymbolValue(initFn.name), 0, null, false)
                }

                return sym
            }

            sym = gen.generateVarDecl("strct_declare", 8, false)
            gen.generateFnCallStart()
            gen.generateFnCallArgument(gen.staticInt(uintToStr(val.type.child.size)))
            gen.generateMoveValue(gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, null, false), sym)
            currVal = val.left
            for currVal != null, currVal = currVal.left {
                if currVal.right.value == BAH_VALUE_FUNC_SYM {
                    fieldVal = generateBahValueSymbol(currVal.right, null)
                    fieldVal = gen.generateTmpSym(fieldVal, 8)
                    nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(currVal.type.offset)))
                    nSym.size = currVal.type.size
                    nSym = gen.generateDestDereference(nSym)
                    gen.generateVarSet(nSym, fieldVal, currVal.type.type == BAH_TYPE_UINT)
                } else if currVal.type.size > 16 {
                    nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(currVal.type.offset)))
                    nSym = gen.generateTmpSym(nSym, 8)
                    nSym.level = 1
                    fieldVal = generateBahValueSymbol(currVal.right, &nSym)
                    if isEmptySymbol(fieldVal) == false {
                        nSym.level = 0
                        nSym.size = currVal.type.size
                        nSym = gen.generateDestDereference(nSym)
                        gen.generateVarSet(nSym, fieldVal, currVal.type.type == BAH_TYPE_UINT)
                    }

                } else {
                    fieldVal = generateBahValueSymbol(currVal.right, null)
                    nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(currVal.type.offset)))
                    nSym.size = currVal.type.size
                    nSym = gen.generateDestDereference(nSym)
                    gen.generateVarSet(nSym, fieldVal, currVal.type.type == BAH_TYPE_UINT)
                }

            }
            sym.size = 8


            if initFn != null {
                gen.generateFnCallStart()
                gen.generateFnCallArgument(sym)
                gen.generateFnCall(asmSymbolValue(initFn.name), 0, null, false)
            }

            return sym
        }

        if val.type.type == BAH_TYPE_ARRAY {
            sym = gen.generateVarDecl("array_declare", 8, false)
            gen.generateFnCallStart()
            gen.generateFnCallArgument(gen.staticInt(uintToStr(val.type.size)))
            gen.generateMoveValue(gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, null, false), sym)

            nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(ARR_ELEMSIZE_OFFSET)))
            elemSizeSym = gen.generateDestDereference(nSym)
            gen.generateVarSet(elemSizeSym, gen.staticInt(uintToStr(val.type.child.size)), true)

                    
            arrLen = 0
            currVal = val.right
            for currVal != null, currVal = currVal.right {
                arrLen++
            }

            nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(ARR_LENGTH_OFFSET)))
            lengthSym = gen.generateDestDereference(nSym)
            gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)

            if arrLen < 64 {
                arrLen = 64
            }

            nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(ARR_REALENGTH_OFFSET)))
            lengthSym = gen.generateDestDereference(nSym)
            gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)


            gen.generateFnCallStart()
            gen.generateFnCallArgument(gen.staticInt(uintToStr(val.type.child.size * arrLen)))
            fnRet = gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, null, false)
            dataSym = gen.generateDestDereference(sym)
            gen.generateMoveValue(fnRet, dataSym)
            dataSym.level = 0
            gen.generateMoveValue(fnRet, dataSym)
            

            currVal = val.right
            index = 0
            for currVal != null, currVal = currVal.right {

                elemSym = generateBahValueSymbol(currVal.left, null)
                
                dataSym = gen.generateDestDereference(sym)
                dataSym = gen.generateDestSymOffset(dataSym, gen.staticInt(uintToStr(val.type.child.size * index)))                

                dataSym.level = 1
                dataSym.size = val.type.child.size
                gen.generateVarSet(dataSym, elemSym, currVal.left.type.type == BAH_TYPE_UINT)

                index++
            }
            

            return sym
        }

        if val.type.type == BAH_TYPE_TUPLE {
            currVal = val.left

            sym = gen.generateVarDecl("tuple_declare", val.type.size, false)

            offset = 0

            for currVal != null, currVal = currVal.left {
                setSym = sym
                setSym.size = currVal.right.type.size
                setSym.address -= offset

                gen.generateVarSet(setSym, generateBahValueSymbol(currVal.right, null), currVal.right.type.type == BAH_TYPE_UINT)

                offset += currVal.right.type.size
            }

            return sym
        }


    }


    if val.value == BAH_VALUE_SPLIT {
        fnSym asmSymbol
        if val.left.type.type == BAH_TYPE_STR {
            fnSym = asmSymbolValue(strSplitFunction)
        } else if val.left.type.type == BAH_TYPE_ARRAY {
            fnSym = asmSymbolValue(arraySplitFunction)
        }
        sym = generateBahValueSymbol(val.left, null)
        sym = gen.generateTmpSym(sym, sym.size)
        lenSym asmSymbol

        if val.right.right == null {
            if val.left.type.type == BAH_TYPE_STR {
                sym.size = 4
                lenSym = gen.generateDereference(sym)
            } else if val.left.type.type == BAH_TYPE_ARRAY {
                lenSym = gen.generateSymOffset(sym, gen.staticInt(uintToStr(ARR_LENGTH_OFFSET)))
                lenSym = gen.generateDereference(lenSym)
            }
        }

        gen.generateFnCallStart()

        gen.generateFnCallArgument(sym)

        if val.right.left == null {
            sym = gen.staticInt("0")
        } else {
            sym = generateBahValueSymbol(val.right.left, null)
        }
        gen.generateFnCallArgument(sym)

        if val.right.right != null {
            lenSym = generateBahValueSymbol(val.right.right, null)
        }
        gen.generateFnCallArgument(lenSym)
        
        sym = gen.generateFnCall(fnSym, 8, null, false)
        sym.size = val.type.size
        
        return sym
    }

    if val.value == BAH_VALUE_INDEXED {
        if val.left.type.type == BAH_TYPE_STR {
            rSym = gen.generateOpAdd(generateBahValueSymbol(val.right, null), gen.staticInt("4"), ASM_NUM_UINT)
            rSym = gen.generateTmpSym(rSym, rSym.size)
            lSym = generateBahValueSymbol(val.left, null)
            lSym = gen.generateSymOffset(lSym, rSym)
            lSym.size = 1
            return gen.generateUnary(lSym)
        }

        if val.left.type.type == BAH_TYPE_BUFFER {
            sym = generateBahValueSymbol(val.left, null)
            indexSym = generateBahValueSymbol(val.right, null)
            sym.size = 8
            sym = gen.generateSymOffset(sym, indexSym)
            sym.size = 1
            sym.level = 1
            return sym
        }

        if val.left.type.type == BAH_TYPE_ARRAY {
            rSym = generateBahValueSymbol(val.right, null)
            rSym = gen.generateOpMult(rSym, gen.staticInt(uintToStr(val.left.type.child.size)), ASM_NUM_UINT)
            rSym = gen.generateTmpSym(rSym, 8)

            lSym = generateBahValueSymbol(val.left, null)
            lSym = gen.generateDereference(lSym)

            lSym = gen.generateSymOffset(lSym, rSym)
            lSym.level = 1
            lSym.size = val.left.type.child.size
            return lSym
        }

        if val.left.type.type == BAH_TYPE_TUPLE {
            sym = generateBahValueSymbol(val.left, null)
            sym.level = -1
            sym.size = 8
            sym = gen.generateSymOffset(sym, gen.staticInt(uintToStr(val.type.offset)))
            sym.size = val.type.size
            sym.level = 0
            return sym
        }
    }

    if val.value == BAH_VALUE_UNARY {
        sym = generateBahValueSymbol(val.left, null)
        sym.size = val.left.type.child.size
        return gen.generateUnary(sym)
    }

    if val.isStaticValue {
        if val.type.type == BAH_TYPE_INT || val.type.type == BAH_TYPE_UINT {
            if val.tok.type == TOKEN_TYPE_CHAR {
                //handle escaping
                c uint = val.tok.cont[1]
                sym = gen.staticInt(uintToStr(c))
                sym.size = 1
                return sym
            } else if val.tok.type == TOKEN_TYPE_INT {

                sym = gen.staticInt(val.tok.cont)
                sym.size = val.type.size
                return sym
            }
        } else if val.type.type == BAH_TYPE_FLOAT {
            if val.type.size == 4 {
                return gen.staticFloat32(val.tok.cont)
            } else if val.type.size == 8 {
                return gen.staticFloat64(val.tok.cont)
            }
        } else if val.type.type == BAH_TYPE_STR {
            return gen.generateStaticStr(val.tok.cont, getStrLen(val.tok.cont))
        }
        
        if isEmptySymbol(val.sym) == false {
            return val.sym
        }
    }

    if val.value == BAH_VALUE_VAR || val.value == BAH_VALUE_FUNC_SYM {
        i=0; for i < len(parserCtx.variables), i++ {
            if parserCtx.variables[i].name == val.tok.cont {
                sm = parserCtx.variables[i].sym
                if val.isPointer {
                    sm.level = -1
                    sm.size = 8
                }
                return sm
            }
        }
    }

    if val.value == BAH_VALUE_FUNC_SYM {
        if isEmptySymbol(val.sym) == false {
            return val.sym
        }
        sym = asmSymbolValue(val.tok.cont)
        sym.size = 8
        sym.level = -1
        return sym
    }

    if val.value == BAH_VALUE_STRUCT {
        currVal = val
        addr = 0

        if val.right.value == BAH_VALUE_FUNC_SYM {
            return val.right.sym
        }

        isLastPtr = false

        for currVal.left != null, currVal = currVal.left {
            addr -= currVal.right.type.offset

            sym = generateBahValueSymbol(currVal.left, null)
            if currVal.left.type.isPtr == false {
                isLastPtr = false
                if sym.stack && sym.isTmp == false {
                    addr += sym.address
                    r.stack = true
                } else {
                    size = sym.size
                    sym.size = 8
                    if sym.stack == false {
                        sym.level = -1
                    } else {
                        sym.level = 0
                    }
                    nSym = gen.generateSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                    if val.isPointer == false {
                        r = gen.generateDereference(nSym)
                        r.size = val.type.size
                    } else {
                        r = nSym
                        r.size = 8
                    }
                    return r
                }
            } else {
                isLastPtr = true
                nSym = gen.generateSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                r = gen.generateTmpSym(nSym, nSym.size)
                addr = r.address
                r.level = 1
            }
            break
        }

        r.address = addr
        r.size = val.type.size
        if val.isPointer {
            if isLastPtr {
                r.level = 0
            } else {
                r.level = -1
            }
            r.size = 8
        }

        return r
    }

    if val.value == BAH_VALUE_OP {

        if val.isSelfOp {
            if val.tok.cont == "+" {
                return gen.generateSelfOp(generateBahValueSymbol(val.left, null), ASM_SELF_OP_ADD)
            } else {
                return gen.generateSelfOp(generateBahValueSymbol(val.left, null), ASM_SELF_OP_SUB)
            }
        }

        if val.left.type.isPtr && val.tok.cont != "==" && val.tok.cont != "!=" && val.left.type.child.type != BAH_TYPE_STRCT {
            throwError(&val.tok, "Cannot perform operation on pointers.")
        }

        opStr = val.tok.cont

        if val.left.type.type == BAH_TYPE_STR && opStr[0] == '+' {
            gen.generateStrConcatBegin()

            if val.right.tok.cont == "+" {
                currAdd = val
                for currAdd != null, currAdd = currAdd.right {
                    if currAdd.value != BAH_VALUE_OP || currAdd.tok.cont[0] != '+' {
                        gen.generateStrConcat(generateBahValueSymbol(currAdd, null))
                        return gen.generateStrConcatEnd()
                    }
                    gen.generateStrConcat(generateBahValueSymbol(currAdd.left, null))
                }
            }

            gen.generateStrConcat(generateBahValueSymbol(val.left, null))
            gen.generateStrConcat(generateBahValueSymbol(val.right, null))
            return gen.generateStrConcatEnd()
        }
        
        if opStr == "||" {
            gen.generateBoolOrStart()

            if val.right.tok.cont == "||" {
                currOr = val
                for currOr != null, currOr = currOr.right {
                    if currOr.tok.cont != "||" {
                        return gen.generateBoolOrEnd(generateBahValueSymbol(currOr, null))
                    }
                    gen.generateBoolOr(generateBahValueSymbol(currOr.left, null))
                }
            }

            gen.generateBoolOr(generateBahValueSymbol(val.left, null))
            return gen.generateBoolOrEnd(generateBahValueSymbol(val.right, null))

        } else if opStr == "&&" {
            gen.generateBoolAndStart()

            if val.right.tok.cont == "&&" {
                currOr = val
                for currOr != null, currOr = currOr.right {
                    if currOr.tok.cont != "&&" {
                        return gen.generateBoolAndEnd(generateBahValueSymbol(currOr, null))
                    }
                    gen.generateBoolAnd(generateBahValueSymbol(currOr.left, null))
                }
            }

            gen.generateBoolAnd(generateBahValueSymbol(val.left, null))
            return gen.generateBoolAndEnd(generateBahValueSymbol(val.right, null))

        }

        //rearrange tree for position dependent operations
        if (opStr[0] == '-' || opStr[0] == '/') && val.right.value == BAH_VALUE_OP && val.right.pemdas == val.pemdas {
            currVal = val.right
            prevVal = val
            currSym = generateBahValueSymbol(val.left, null)

            for currVal.pemdas == val.pemdas, currVal = currVal.right {
                currSym = gen.generateTmpSym(currSym, currSym.size)
                currSym = generateValueOperation(&prevVal.tok, currSym, generateBahValueSymbol(currVal.left, null), currVal.left.type)

                if currVal.right.value != BAH_VALUE_OP {
                    currSym = gen.generateTmpSym(currSym, currSym.size)
                    currSym = generateValueOperation(&currVal.tok, currSym, generateBahValueSymbol(currVal.right, null), currVal.right.type)
                    break
                }
                prevVal = currVal
            }

            if currVal.value == BAH_VALUE_OP && currVal.pemdas != val.pemdas {
                currSym = gen.generateTmpSym(currSym, currSym.size)
                currSym = generateValueOperation(&prevVal.tok, currSym, generateBahValueSymbol(currVal, null), currVal.type)
            }

            return currSym
        }



        leftSym = generateBahValueSymbol(val.left, null)

        leftSym = gen.generateTmpSym(leftSym, leftSym.size)

        rightSym = generateBahValueSymbol(val.right, null)



        return generateValueOperation(&val.tok, leftSym, rightSym, val.left.type)

    }

    if val.value == BAH_VALUE_FUNC_CALL {

        fnName = val.tok.cont
        isMethodCall = false

        //need to pass the structure pointer to the method function
        if val.left.value == BAH_VALUE_STRUCT && val.left.type.child != null && val.left.type.child.isPtr && (val.left.left.type.isPtr && compatibleTypes(val.left.left.type, val.left.type.child) || val.left.left.type.isPtr == false && compatibleTypes(val.left.left.type, val.left.type.child.child)) {
            isMethodCall = true
            //we need to pre generate the parent value
            parent = generateBahValueSymbol(val.left.left, null)
            val.left.left.value = BAH_VALUE_VAR
            val.left.left.sym = parent
        }

        fnNameSym = generateBahValueSymbol(val.left, null)

        if fnNameSym.isValue == false && fnNameSym.level != 0 {
            newFnNameSym = fnNameSym
            newFnNameSym.level = 0
            gen.generateMoveValue(fnNameSym, newFnNameSym)
        }
    
        if fnName == "sizeof" {
            return gen.staticInt(uintToStr(val.right.left.type.size))
        }

        if fnName == "len" {
            if val.right.left.type.type == BAH_TYPE_ARRAY {
                fnNameSym = asmSymbolValue("__bah_arrayLength")
            } else if val.right.left.type.type == BAH_TYPE_STR {
                fnNameSym = asmSymbolValue("__bah_strlenSTR")
            }
        } else if fnName == "panic" {
            fnNameSym = asmSymbolValue("__Bah_panic")
            gen.generateFnCallStart()

            sym = generateBahValueSymbol(val.right.left, null)
            gen.generateFnCallArgument(sym)

            locLine = "\""+absPath(parserCtx.currentFilePath)+":"+uintToStr(val.tok.line)+"\""

            sym = gen.generateStaticStr(locLine, getStrLen(locLine))
            gen.generateFnCallArgument(sym)


            return gen.generateFnCall(fnNameSym, 0, null, false)
        }

        if val.isAsync {
            //store arguments in heap

            //calculate size

            allocSize = 0
            
            if isMethodCall {
                allocSize = 8
            }

            argVal = val.right
            for argVal != null, argVal = argVal.right {
                allocSize += argVal.type.size
            }

            gen.generateFnCallStart()
            gen.generateFnCallArgument(gen.staticInt(uintToStr(allocSize)))
            argsSym = gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, null, false)
            argsSym = gen.generateTmpSym(argsSym, 8)
            offset = 0

            if isMethodCall {
                parentSym = val.left.left.sym
                if val.left.left.type.isPtr == false {
                    parentSym.level -= 1
                }
                parentSym.size = 8
                setSym = gen.generateDestSymOffset(argsSym, gen.staticInt(uintToStr(offset)))
                setSym = gen.generateDestDereference(setSym)
                gen.generateVarSet(setSym, parentSym, false)
                offset = 8
            }

            argVal = val.right
            for argVal != null, argVal = argVal.right {
                sym = asmSymbol{}

                if argVal.value == BAH_VALUE_REFLECT {
                    sym = generateReflection(argVal.left)
                } else if argVal.left.type.size != argVal.type.size && (argVal.type.size > 8 || argVal.type.size < argVal.left.type.size) {
                    sym = generateTypeConversion(argVal.left, argVal.type)
                } else {
                    sym = generateBahValueSymbol(argVal.left, null)
                }

                //convert str to char* in fn call
                if argVal.type.isPtr && argVal.type.child.type == BAH_TYPE_UINT && argVal.type.child.size == 1 && argVal.left.type.type == BAH_TYPE_STR {
                    sym = gen.generateSymOffset(sym, asmSymbolValue("$4"))
                    // sym = gen.generateTmpSym(sym, sym.size)
                }

                setSym = gen.generateDestSymOffset(argsSym, gen.staticInt(uintToStr(offset)))
                setSym = gen.generateDestDereference(setSym)
                gen.generateVarSet(setSym, sym, argVal.type.type == BAH_TYPE_UINT)
                offset += argVal.type.size
            }

            asyncFnName = ".Bah_async_"+uintToStr(gen.fileNb)+"_"+uintToStr(gen.currentLine)

            //ptherad fn call
            gen.generateFnCallStart()
            gen.generateFnCallArgument(gen.staticInt("0"))
            gen.generateFnCallArgument(gen.staticInt("0"))
            asyncFnSym = asmSymbolValue(asyncFnName)
            asyncFnSym.size = 8
            asyncFnSym.level = -1
            gen.generateFnCallArgument(asyncFnSym)
            gen.generateFnCallArgument(argsSym)
            // gen.generateFnCall(asmSymbolValue(".Bah_async_"+uintToStr(realGen.fileNb)+"_"+uintToStr(realGen.currentLine)), 0, null, false)

            gen.generateFnCall(asmSymbolValue(threadCreateFunction), 4, null, false)

            //create function call wrapper
            realGen = gen
            gen = globalFuncsGen
            gen.fileNb = realGen.fileNb
            gen.totalFileNb = realGen.totalFileNb

            args = []asmSymbol {gen.generateVarDecl("args", 8, false)}

            gen.generateFnStart(asyncFnName, args, 0)


            gen.generateFnCallStart()
            argsSym = asmSymbolStack(16, 8)
            offset = 0
            if isMethodCall {
                setSym = gen.generateSymOffset(argsSym, gen.staticInt(uintToStr(offset)))
                setSym = gen.generateDereference(setSym)
                gen.generateFnCallArgument(setSym)
                offset = 8
            }
            argVal = val.right
            for argVal != null, argVal = argVal.right {
                setSym = gen.generateSymOffset(argsSym, gen.staticInt(uintToStr(offset)))
                setSym = gen.generateDereference(setSym)
                gen.generateFnCallArgument(setSym)
                offset += argVal.type.size
            }
            gen.generateFnCall(fnNameSym, 0, null, false)

            gen.generateFnEnd()
            globalFuncsGen.code = gen.code

            gen = realGen

            return r
        }

        gen.generateFnCallStart()

        if isMethodCall {
            parentSym = val.left.left.sym
            if val.left.left.type.isPtr == false {
                parentSym.level -= 1
            }
            parentSym.size = 8
            gen.generateFnCallArgument(parentSym)
        }

        argVal = val.right
        for argVal != null, argVal = argVal.right {
            sym = asmSymbol{}

            if argVal.value == BAH_VALUE_REFLECT {
                sym = generateReflection(argVal.left)
            } else if argVal.left.type.size != argVal.type.size && (argVal.type.size > 8 || argVal.type.size < argVal.left.type.size) {
                sym = generateTypeConversion(argVal.left, argVal.type)
            } else {
                sym = generateBahValueSymbol(argVal.left, null)
            }

            //convert str to char* in fn call
            if argVal.type.isPtr && argVal.type.child.type == BAH_TYPE_UINT && argVal.type.child.size == 1 && argVal.left.type.type == BAH_TYPE_STR {
                sym = gen.generateSymOffset(sym, asmSymbolValue("$4"))
                sym = gen.generateTmpSym(sym, sym.size)
            }

            gen.generateFnCallArgument(sym)
        }
        returnSize = 0
        isFloat = false
        if val.type != null {
            returnSize = val.type.size
            isFloat = val.type.type == BAH_TYPE_FLOAT
        }

        if shortcut != null && returnSize > 16 {
            if shortcut.level == 0 {
                shortcut.level = -1
                shortcut.size = 8
            } else if shortcut.level == 1 {
                shortcut.level = 0
                shortcut.size = 8                
            }
            // printDebugContext()
            gen.generateFnCall(fnNameSym, returnSize, shortcut, isFloat)
            return r
        }

        return gen.generateFnCall(fnNameSym, returnSize, null, isFloat)
    }

    throwError(&val.tok, "Internal error generating value asm symbol: "+toJson(val)+".")

    return r
}

generateBahLeftValueSymbol(lval bahLeftValue*) asmSymbol {
    r = asmSymbol{}

    if lval.isUnary {
        sym = gen.generateDestDereference(generateBahLeftValueSymbol(lval.left))
        sym.size = lval.left.type.child.size

        return sym
    }

    if lval.isStruct {
        currVal = lval
        addr = 0
        for currVal.left != null, currVal = currVal.left {
            addr -= currVal.right.type.offset

            // if currVal.left.isStruct == false {
                sym = generateBahLeftValueSymbol(currVal.left)
                if currVal.left.type.isPtr == false {
                    if sym.stack && sym.isTmp == false {
                        addr += sym.address
                        r.stack = true
                    } else {
                        size = sym.size
                        sym.size = 8
                        if sym.stack == false {
                            sym.level = -1
                        } else {
                            sym.level = 0
                        }
                        nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                        r = gen.generateDestDereference(nSym)
                        r.size = lval.type.size
                        return r
                    }
                } else {
                    nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                    nSym.size = lval.type.size
                    return gen.generateDestDereference(nSym)
                }
                break
            // }

            // if currVal.left.type.isPtr {
            //     break
            // }
        }


        // r.stack = true
        r.address = addr
        r.size = lval.type.size
        return r
    }

    if lval.isBuffer {
        sym = generateBahLeftValueSymbol(lval.left)
        indexSym = generateBahValueSymbol(lval.index, null)
        sym.size = 8
        sym = gen.generateDestSymOffset(sym, indexSym)
        sym.size = 1
        sym.level = 1
        return sym
    }

    if lval.isArray {
        sym = generateBahLeftValueSymbol(lval.left)
        sym = gen.generateTmpSym(sym, 8)

        indexSym = generateBahValueSymbol(lval.index, null)
        indexSym = gen.generateTmpSym(indexSym, 8)

        gen.generateFnCallStart()

        gen.generateFnCallArgument(sym)
        gen.generateFnCallArgument(indexSym)

        gen.generateFnCall(asmSymbolValue("__Bah_realocate_arr"), 0, null, false)

        sym = gen.generateDestDereference(sym)

        indexSym = gen.generateOpMult(indexSym, gen.staticInt(uintToStr(lval.left.type.child.size)), ASM_NUM_UINT)
        sym = gen.generateDestSymOffset(sym, indexSym)
        sym.level = 1
        sym.size = lval.left.type.child.size
        return sym
    }

    if lval.isTuple {
        sym = generateBahLeftValueSymbol(lval.left)
        sym.size = 8
        sym.level = -1
        sym = gen.generateDestSymOffset(sym, gen.staticInt(uintToStr(lval.type.offset)))
        sym.size = lval.type.size
        sym.level = 0
        return sym
    }

    if lval.isVariable {
        // if lval.variable.scope == 0 && lval.type.type == BAH_TYPE_STR {
        //    sym = lval.variable.sym
        //    sym.level = 1
        //    return sym
        // }
        return lval.variable.sym
    }

    throwError(&lval.tok, "Internal error generating left-value asm symbol.")

    return r
}

struct _typeAndSymStack {
    type: bahType*
    sym: asmSymbol
}

generateReflectionFromType(type bahType*, typesStack []_typeAndSymStack) asmSymbol {

    i=0; for i < len(typesStack), i++ {
        if isSameType(typesStack[i].type, type) {
            return typesStack[i].sym
        }
    }

    ogType = type

    for type.isPtr {
        if type.type == BAH_TYPE_PTR {
            break
        }
        type = type.child
    }

    for type.type == BAH_TYPE_CUSTOM_TYPE {
        type = type.child
    }

    sym = gen.generateVarDecl("reflect_elem", REFLECT_TYPE_SIZE, false)
    setSym = sym
    setSym.size = 8

    typesStack[len(typesStack)] = _typeAndSymStack {ogType, sym}

    //size
    if type.type == BAH_TYPE_ARRAY {
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(ARR_TYPE_SIZE)), true)
    } else if type.type == BAH_TYPE_MAP {
        printDebugContext()
        panic("size not known yet")
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(ARR_TYPE_SIZE)), true)
    } else if type.type == BAH_TYPE_CHAN {
        printDebugContext()
        panic("size not known yet")
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(ARR_TYPE_SIZE)), true)
    } else {
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(type.size)), true)
    }

    //type
    typeStr = "\""+ogType.toStr()+"\""
    setSym.address -= 8
    gen.generateVarSet(setSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

    //isArray
    setSym.address -= 16
    if type.type == BAH_TYPE_ARRAY {
        gen.generateVarSet(setSym, gen.staticInt("1"), true)
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //arrayElement
    setSym.address -= 8
    if type.type == BAH_TYPE_ARRAY {
        arrElem = generateReflectionFromType(type.child, typesStack)
        arrElem.level = -1
        arrElem.size = 8
        gen.generateVarSet(setSym, arrElem, false)
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //isStruct
    setSym.address -= 8
    if type.type == BAH_TYPE_STRCT {
        gen.generateVarSet(setSym, gen.staticInt("1"), true)
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //strutLayout
    setSym.address -= 8
    if type.type == BAH_TYPE_STRCT {
    
        structLayoutSym = gen.generateVarDecl("array_declare", 8, false)
        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(ARR_TYPE_SIZE)))
        gen.generateMoveValue(gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, null, false), structLayoutSym)

        nSym = gen.generateDestSymOffset(structLayoutSym, gen.staticInt(intToStr(ARR_ELEMSIZE_OFFSET)))
        elemSizeSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(elemSizeSym, gen.staticInt(uintToStr(REFLECT_TYPE_SIZE)), true)

        arrLen = 0
        currFieldType = type.child.next
        for currFieldType != null, currFieldType = currFieldType.next {
            arrLen++
        }

        nSym = gen.generateDestSymOffset(structLayoutSym, gen.staticInt(intToStr(ARR_LENGTH_OFFSET)))
        lengthSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)

        nSym = gen.generateDestSymOffset(structLayoutSym, gen.staticInt(intToStr(ARR_REALENGTH_OFFSET)))
        lengthSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)


        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(REFLECT_TYPE_SIZE * arrLen)))
        fnRet = gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, null, false)
        dataSym = gen.generateDestDereference(structLayoutSym)
        gen.generateMoveValue(fnRet, dataSym)
        dataSym.level = 0
        gen.generateMoveValue(fnRet, dataSym)
        gen.generateVarSet(setSym, structLayoutSym, true)
        

        currFieldType = type.child.next
        index = 0
        for currFieldType != null, currFieldType = currFieldType.next {

            elemSym = generateReflectionFromType(currFieldType, typesStack)

            // offstetElemSym = elemSym
            // offstetElemSym.address -= 56
            // offstetElemSym.size = 8
            // gen.generateVarSet(offstetElemSym, gen.staticInt(uintToStr(currFieldType.offset)), true)

            // typeStr = "\""+currFieldType.name+"\""
            // offstetElemSym.address = elemSym.address - 16
            // gen.generateVarSet(offstetElemSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

            dataSym = gen.generateDestDereference(structLayoutSym)
            dataSym = gen.generateDestSymOffset(dataSym, gen.staticInt(uintToStr(REFLECT_TYPE_SIZE * index)))
            dataSym.level = 1
            dataSym.size = REFLECT_TYPE_SIZE
            gen.generateVarSet(dataSym, elemSym, false)

            typeStr = "\""+currFieldType.name+"\""
            offstetElemSym = dataSym
            offstetElemSym.level = 0
            offstetElemSym.size = 8
            //previous var set incremented %rdi to dataSym address + 64, we need to set dataSym at offset 16: 16 - 64 = 48
            offstetElemSym = gen.generateSymOffset(offstetElemSym, gen.staticInt(intToStr(-48)))
            offstetElemSym.level = 1
            gen.generateVarSet(offstetElemSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

            offstetElemSym.level = 0
            offstetElemSym = gen.generateSymOffset(offstetElemSym, gen.staticInt(uintToStr(40)))
            offstetElemSym.level = 1
            gen.generateVarSet(offstetElemSym, gen.staticInt(uintToStr(currFieldType.offset)), true)
             
            index++
        }
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //offset
    setSym.address -= 8
    gen.generateVarSet(setSym, gen.staticInt("0"), true)

    return sym
}

generateReflection(val bahValue*) asmSymbol {
    types = []_typeAndSymStack

    sym = generateReflectionFromType(val.type, types)
    setSym = sym
    setSym.size = 8

    //name
    //TODO: better naming generation
    typeStr = "\""+val.tok.cont+"\""
    setSym.address = sym.address - 16
    gen.generateVarSet(setSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

    //value
    setSym.address = sym.address - 64
    valSym = generateBahValueSymbol(val, null)
    if val.type.isNativePtr == false {
        valSym.level = -1
        valSym.size = 8
    }
    gen.generateVarSet(setSym, valSym, false)

    return sym
}

generateTypeConversion(val bahValue*, type bahType*) asmSymbol {
    for type.type == BAH_TYPE_CUSTOM_TYPE {
        type = type.child
    }

    if (type.isPtr || type.isNativePtr) && val.type.isNativePtr == false && val.type.isPtr == false && val.type.size != 8 && val.type.type != BAH_TYPE_BUFFER {
        throwError(&val.tok, "Cannot be converted to a pointer type.")
    }

    if type.type == BAH_TYPE_INT || type.type == BAH_TYPE_UINT || type.type == BAH_TYPE_BOOL || val.type.type == BAH_TYPE_PTR || type.type == BAH_TYPE_PTR {
        
        if val.type.type == BAH_TYPE_FLOAT {
            return gen.generateConvFloatToInt(generateBahValueSymbol(val, null), type.size)
        }

        if val.type.size > 8 && val.type.isNativePtr == false && val.type.type != BAH_TYPE_BUFFER {
            throwError(&val.tok, "Invalid conversion, you may need to convert a pointer.")
        }

        r = generateBahValueSymbol(val, null)

        if type.size != val.type.size && val.isStaticValue == false {
            if r.size > 8 {
                r.size = 8
            }
            return gen.generateConvSizes(r, type.size, type.type == BAH_TYPE_UINT)
        }

        return r

    } else if type.type == BAH_TYPE_FLOAT {

        if val.type.type == BAH_TYPE_INT {
            return gen.generateConvIntToFloat(generateBahValueSymbol(val, null), type.size)
        }

    }

    if val.type.type == type.type || val.type.isNativePtr && type.isNativePtr {
        size = type.size
        if type.isNativePtr {
            size = 8
        }
        r = generateBahValueSymbol(val, null)
        if r.size != size && val.isStaticValue == false {
            gen.generateMoveValue(r, asmSymbolReg(ASM_reg_id_op, r.size, 0))
            r = asmSymbolReg(ASM_reg_id_op, size, 0)
        }
        return r
    }



    throwError(&val.tok, "Internal error generating conversion of asm symbol.")

    r = asmSymbol{}
    return r
}

generateImmediateValues(val bahValue*, syms []asmSymbol) {

    if val.type.isPtr {
        throwError(&val.tok, "Cannot (yet) use a pointer as a global value.")
    }

    if val.tok.type == TOKEN_TYPE_INT {
        syms[len(syms)] = asmSymbol {
            size: val.type.size
            name: val.tok.cont
        }
    } else if val.tok.type == TOKEN_TYPE_STR {
        sym = gen.generateStaticStr(val.tok.cont, getStrLen(val.tok.cont))
        syms[len(syms)] = asmSymbol {
            size: 8
            name: sym.name
        }
    } else if val.value == BAH_VALUE_DECLARATION {
        if val.type.type == BAH_TYPE_ARRAY {

            arrLen = 0
            currVal = val.right
            for currVal != null, currVal = currVal.right {
                arrLen++
            }

            nSyms = []asmSymbol
            //data
            nSyms[len(nSyms)] = asmSymbol {
                size: 8
                name: "0"
            }
            //length
            nSyms[len(nSyms)] = asmSymbol {
                size: 8
                name: uintToStr(arrLen)
            }
            //realLength
            nSyms[len(nSyms)] = asmSymbol {
                size: 8
                name: uintToStr(arrLen)
            }
            //elemSize
            nSyms[len(nSyms)] = asmSymbol {
                size: 8
                name: uintToStr(val.type.child.size)
            }

            //to get ptr to value
            privArrName = ".VAR_ARRAY_"+uintToStr(asmRandId)
            privArrSym = asmSymbolStaticName(privArrName)
            privArrSym.size = 8
            privArrSym.level = -1
            sym = gen.generatePrivateVarWithValue(privArrName, val.type.size, nSyms)
            asmRandId++

            syms[len(syms)] = asmSymbol {
                size: 8
                name: sym.name
            }

            realGen = gen
            gen = initFnGen
            gen.fileNb = realGen.fileNb
            gen.totalFileNb = realGen.totalFileNb

            arrSym = generateBahValueSymbol(val, null)
            arrSym = gen.generateDereference(arrSym)
            arrSym.size = 8
            

            privArrSymData = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
            gen.generateMoveValue(privArrSym, privArrSymData)
            privArrSymData.level = 1

            gen.generateVarSet(privArrSymData, arrSym, false)

            realGen.data += gen.data
            realGen.bss += gen.bss
            gen = realGen
        } else if val.type.type == BAH_TYPE_STRCT || val.type.isPtr && val.type.child.type == BAH_TYPE_STRCT {
            currTp = val.type.child
            for currTp != null, currTp = currTp.next {
                
                currVal = val.left
                for currVal != null, currVal = currVal.left {
                    if currVal.type.name == currTp.name {
                        break
                    }
                }

                if currVal != null {
                    generateImmediateValues(currVal.right, syms)
                } else {
                    //zero field
                    size = currTp.size
                    incr = 8
                    for size > 0, size -= incr {    
                        for incr > size {
                            incr = incr / 2
                        }
                        syms[len(syms)] = asmSymbol {
                            name: "0"
                            size: incr
                        }
                    }
                }
            }
        } else {
            throwError(&val.tok, "Immediate value of this declaration is not yet implemented.")
        }

        
    } else if val.sym.isValue {
        name = val.sym.name
        if name[0] == '$' {
            name = name[1:]
        }
        syms[len(syms)] = asmSymbol {
            name: name
            size: val.sym.size
        }
    } else {
        throwError(&val.tok, "Cannot use this value as a global value. (immediate value not yet implemented).")
    }

}

generateRuntimeDebugInfo() {
    if isObjectFile {
        return
    }

    gen.debugInfo += rope(".global .bah_debug_info\n.bah_debug_info:\n")
    i=0; for i < len(parserCtx.functions), i++ {
        if parserCtx.functions[i].declared == false {
            continue
        }
        fnName = parserCtx.functions[i].name
        fnPublicName = fnName

        if fnName == "__Bah_panic" {
            fnPublicName = "panic"
        }

        gen.debugInfo += rope(".quad "+fnName+"\n.quad ."+fnName+"_end\n.int "+uintToStr(len(fnPublicName))+"\n.asciz \""+fnPublicName+"\"\n")
    }
    gen.debugInfo += rope(".quad 0\n")
}