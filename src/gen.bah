#define generateTypeConversion(val bahValue*, type bahType*) asmSymbol
#define generateReflection(val bahValue*) asmSymbol
#define generateBahValueSymbol(val bahValue*) asmSymbol

getStrLen(s str) uint {
    l = len(s)
    n = 0
    i=1; for i+1 < l, i++ {
        n++
        if s[i] == <char>92 {
            if s[i+1] == <char>10 {
                i++
            } else if s[i+1] == '0' {
                i++
                start = i
                for i-start < 2, i++ {
                    if isNumber(s[i]) == false {
                        break
                    }
                }
                i--
            }
            i++
        }
    }

    return n
}

generateValueOperation(tok bahToken*, left asmSymbol, right asmSymbol, type bahType*) asmSymbol {
    opStr = tok.cont





    tp = ASM_NUM_INT
    if type.type == BAH_TYPE_UINT {
        tp = ASM_NUM_UINT
    } else if type.type == BAH_TYPE_FLOAT {
        tp = ASM_NUM_FLOAT
    } else if type.isPtr && type.child.type == BAH_TYPE_STRCT {
        methodName = ""
        if opStr[0] == '+' {
            methodName = ".add"
        } else if opStr[0] == '-' {
            methodName = ".sub"
        } else if opStr[0] == '*' {
            methodName = ".mult"
        } else if opStr[0] == '/' {
            methodName = ".div"
        }

        if len(methodName) != 0 {
            method = parserCtx.findFunc(type.child.child.name+methodName)

            if method != null {
                if compatibleTypes(type, method.type.child) == false {
                    throwError(tok, "Wrong type in call to "+method.name)
                }

                if compatibleTypes(type, method.type.child.next) == false {
                    throwError(tok, "Wrong type in call to "+method.name)
                }

                if compatibleTypes(type, method.type.ret) == false {
                    throwError(tok, method.name+"'s return type is not the same as its arguments.")
                }

                gen.generateFnCallStart()
                gen.generateFnCallArgument(left)
                gen.generateFnCallArgument(right)
                return gen.generateFnCall(asmSymbolValue(method.name), method.type.ret.size, false)
            }
        }

    } else if type.type == BAH_TYPE_STR {
        if opStr == "==" {
            gen.generateFnCallStart()
            gen.generateFnCallArgument(left)
            gen.generateFnCallArgument(right)
            return gen.generateFnCall(asmSymbolValue(strCompareFunction), 1, false)
        } else if opStr == "!=" {
            gen.generateFnCallStart()
            gen.generateFnCallArgument(left)
            gen.generateFnCallArgument(right)
            res = gen.generateFnCall(asmSymbolValue(strCompareFunction), 1, false)
            stcInt = gen.staticInt("0")
            stcInt.size = 1
            return gen.generateCompare(res, stcInt, ASM_OP_EQ, false)
        }

        if opStr != "in" {
            throwError(tok, "Invalid operation.")
        }
    }

    //handle strings concat and struct methods special operations
    //also handle conversions
    //also handle other operations
    if opStr == "*" || opStr == "*=" {
        return gen.generateOpMult(left, right, tp)
    } else if opStr == "/" || opStr == "/=" {
        return gen.generateOpDiv(left, right, tp)
    } else if opStr == "%" || opStr == "%=" {
        if tp == ASM_NUM_FLOAT {
            throwError(tok, "Cannot do modulo operation on floats.")
        }
        return gen.generateOpMod(left, right, tp)
    } else if opStr == "-" || opStr == "-=" {
        return gen.generateOpSub(left, right, tp)
    } else if opStr == "+" || opStr == "+=" {
        return gen.generateOpAdd(left, right, tp)
    } else if opStr == "<" {
        leftSym = left
        if leftSym.isTmp == false && leftSym.stack == false {
            leftSym = gen.generateTmpSym(leftSym, leftSym.size)
        }
        return gen.generateCompare(leftSym, right, ASM_OP_LESS, tp == ASM_NUM_UINT)
    } else if opStr == ">" {
        leftSym = left
        if leftSym.isTmp == false && leftSym.stack == false {
            leftSym = gen.generateTmpSym(leftSym, leftSym.size)
        }
        return gen.generateCompare(leftSym, right, ASM_OP_GREATER, tp == ASM_NUM_UINT)
    } else if opStr == "<=" {
        leftSym = left
        if leftSym.isTmp == false && leftSym.stack == false {
            leftSym = gen.generateTmpSym(leftSym, leftSym.size)
        }
        return gen.generateCompare(leftSym, right, ASM_OP_LESS_OR_EQ, tp == ASM_NUM_UINT)
    } else if opStr == ">=" {
        leftSym = left
        if leftSym.isTmp == false && leftSym.stack == false {
            leftSym = gen.generateTmpSym(leftSym, leftSym.size)
        }
        return gen.generateCompare(leftSym, right, ASM_OP_GREATER_OR_EQ, tp == ASM_NUM_UINT)
    } else if opStr == "==" {
        leftSym = left
        if leftSym.isTmp == false && leftSym.stack == false {
            leftSym = gen.generateTmpSym(leftSym, leftSym.size)
        }
        return gen.generateCompare(leftSym, right, ASM_OP_EQ, tp == ASM_NUM_UINT)
    } else if opStr == "!=" {
        leftSym = left
        if leftSym.isTmp == false && leftSym.stack == false {
            leftSym = gen.generateTmpSym(leftSym, leftSym.size)
        }
        return gen.generateCompare(leftSym, right, ASM_OP_NOT_EQ, tp == ASM_NUM_UINT)
    } else if opStr == "in" {
        right = gen.generateTmpSym(right, 8)

        retSym = gen.generateTmpDecl(1, false)
        gen.generateVarSet(retSym, gen.staticInt("0"), true)

        index = asmSymbolReg(ASM_reg_id_op, 8, gen.regIndex+2)
        uintType = new bahType {
            type: BAH_TYPE_UINT
            size: 8
        }
        gen.generateMoveValue(gen.staticInt("0"), index)

        elemSizeSym = gen.generateSymOffset(right, gen.staticInt(uintToStr(ARR_ELEMSIZE_OFFSET)))
        elemSizeSym.level = 1
        elemSizeSym = gen.generateTmpSym(elemSizeSym, 8)

        gen.generateFor()


        arrLen = gen.generateSymOffset(right, gen.staticInt(uintToStr(ARR_LENGTH_OFFSET)))
        arrLen = gen.generateDereference(arrLen)

        tmpTok = *tok
        tmpTok.cont = "<"
        gen.generateForCond(generateValueOperation(&tmpTok, index, arrLen, uintType))

        gen.generateSelfOp(index, ASM_SELF_OP_ADD)

        gen.generateForIncr()


        tmpTok = *tok
        tmpTok.cont = "=="

        arrElem = gen.generateDereference(right)
        arrElem = gen.generateSymOffset(arrElem, gen.generateOpMult(elemSizeSym, index, ASM_NUM_UINT))
        arrElem.size = type.size
        arrElem.level = 1

        gen.generateIf(generateValueOperation(&tmpTok, left, arrElem, type))
        gen.generateVarSet(retSym, gen.staticInt("1"), true)
        gen.generateForBreak()

        gen.generateEndIf()
        gen.generateForEnd()

        retSym.size = 1

        return retSym
    }

    throwError(tok, "Internal error: could not generate operation.")

    n = asmSymbol{}
    return n
}

generateBahValueSymbol(val bahValue*) asmSymbol {
    r = asmSymbol {}

    if val.isPointer {
        actualValue = val
        for actualValue.isCast {
            actualValue = actualValue.left
        }
        if actualValue.isVariable == false && actualValue.isReg == false && actualValue.isFunctionSym == false && actualValue.isStruct == false {
            val.isPointer = false
            sym = generateBahValueSymbol(val)
            sym.size = 8
            if sym.level == 1 {
                sym.level = 0
                return sym
            }

            sym.level = -1
            return sym
        }
    }

    if val.isCast {
        if val.left.isReg {
            if val.left.tok.cont[1:] == "data" {
                sym = asmSymbolStaticName("__data_start")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            } else if val.left.tok.cont[1:] == "bss" {
                sym = asmSymbolStaticName("__bss_start")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            } else if val.left.tok.cont[1:] == "end" {
                sym = asmSymbolStaticName("__bss_end")
                sym.level = -1
                return gen.generateTmpSym(sym, 8)
            }
            r.isValue = true
            r.name = "%"+val.left.tok.cont[1:]
            r.size = val.type.size
            return r
        }
        return generateTypeConversion(val.left, val.type)
    }

    if val.isReg {
        throwError(&val.tok, "Cannot use a register without casting it.")
    }

    if val.isBufferDeclare {
        sym = gen.generateVarDecl("buffer_declare", val.type.size, false)
        sym.level = -1
        sym.size = 8
        return sym
    }

    if val.isSplit {
        fnSym asmSymbol
        if val.left.type.type == BAH_TYPE_STR {
            fnSym = asmSymbolValue(strSplitFunction)
        } else if val.left.type.type == BAH_TYPE_ARRAY {
            fnSym = asmSymbolValue(arraySplitFunction)
        }
        sym = generateBahValueSymbol(val.left)
        sym = gen.generateTmpSym(sym, sym.size)
        lenSym asmSymbol

        if val.right.right == null {
            if val.left.type.type == BAH_TYPE_STR {
                sym.size = 4
                lenSym = gen.generateDereference(sym)
            } else if val.left.type.type == BAH_TYPE_ARRAY {
                lenSym = gen.generateSymOffset(sym, gen.staticInt(uintToStr(ARR_LENGTH_OFFSET)))
                lenSym = gen.generateDereference(lenSym)
            }
        }

        gen.generateFnCallStart()

        gen.generateFnCallArgument(sym)

        if val.right.left == null {
            sym = gen.staticInt("0")
        } else {
            sym = generateBahValueSymbol(val.right.left)
        }
        gen.generateFnCallArgument(sym)

        if val.right.right != null {
            lenSym = generateBahValueSymbol(val.right.right)
        }
        gen.generateFnCallArgument(lenSym)
        
        sym = gen.generateFnCall(fnSym, 8, false)
        
        return sym
    }

    if val.isIndexed {
        if val.left.type.type == BAH_TYPE_STR {
            rSym = gen.generateOpAdd(generateBahValueSymbol(val.right), gen.staticInt("4"), ASM_NUM_UINT)
            rSym = gen.generateTmpSym(rSym, rSym.size)
            lSym = generateBahValueSymbol(val.left)
            lSym = gen.generateSymOffset(lSym, rSym)
            lSym.size = 1
            return gen.generateUnary(lSym)
        }

        if val.left.type.type == BAH_TYPE_BUFFER {
            sym = generateBahValueSymbol(val.left)
            indexSym = generateBahValueSymbol(val.right)
            sym.size = 8
            sym = gen.generateSymOffset(sym, indexSym)
            sym.size = 1
            sym.level = 1
            return sym
        }

        if val.left.type.type == BAH_TYPE_ARRAY {
            rSym = generateBahValueSymbol(val.right)
            rSym = gen.generateOpMult(rSym, gen.staticInt(uintToStr(val.left.type.child.size)), ASM_NUM_UINT)
            rSym = gen.generateTmpSym(rSym, 8)

            lSym = generateBahValueSymbol(val.left)
            lSym = gen.generateDereference(lSym)

            lSym = gen.generateSymOffset(lSym, rSym)
            lSym.level = 1
            lSym.size = val.left.type.child.size
            return lSym
        }

        if val.left.type.type == BAH_TYPE_TUPLE {
            sym = generateBahValueSymbol(val.left)
            sym.level = -1
            sym.size = 8
            sym = gen.generateSymOffset(sym, gen.staticInt(uintToStr(val.type.offset)))
            sym.size = val.type.size
            sym.level = 0
            return sym
        }
    }

    if val.isUnary {
        sym = generateBahValueSymbol(val.left)
        sym.size = val.left.type.child.size
        return gen.generateUnary(sym)
    }

    if val.isStaticValue {
        if val.type.type == BAH_TYPE_INT || val.type.type == BAH_TYPE_UINT {
            if val.tok.type == TOKEN_TYPE_CHAR {
                //handle escaping
                c uint = val.tok.cont[1]
                sym = gen.staticInt(uintToStr(c))
                sym.size = 1
                return sym
            } else if val.tok.type == TOKEN_TYPE_INT {

                sym = gen.staticInt(val.tok.cont)
                sym.size = val.type.size
                return sym
            }
        } else if val.type.type == BAH_TYPE_FLOAT {
            if val.type.size == 4 {
                return gen.staticFloat32(val.tok.cont)
            } else if val.type.size == 8 {
                return gen.staticFloat64(val.tok.cont)
            }
        } else if val.type.type == BAH_TYPE_STR {
            return gen.generateStaticStr(val.tok.cont, getStrLen(val.tok.cont))
        }
        
        if isEmptySymbol(val.sym) == false {
            return val.sym
        }
    }

    if val.isVariable || val.isFunctionSym {
        i=0; for i < len(parserCtx.variables), i++ {
            if parserCtx.variables[i].name == val.tok.cont {
                sm = parserCtx.variables[i].sym
                if val.isPointer {
                    sm.level = -1
                    sm.size = 8
                }
                return sm
            }
        }
    }

    if val.isFunctionSym {
        if isEmptySymbol(val.sym) == false {
            return val.sym
        }
        sym = asmSymbolValue(val.tok.cont)
        sym.size = 8
        sym.level = -1
        return sym
    }

    if val.isStruct {
        currVal = val
        addr = 0

        if val.right.isFunctionSym {
            return val.right.sym
        }

        isLastPtr = false

        for currVal.left != null, currVal = currVal.left {
            addr -= currVal.right.type.offset

            sym = generateBahValueSymbol(currVal.left)
            if currVal.left.type.isPtr == false {
                isLastPtr = false
                if sym.stack && sym.isTmp == false {
                    addr += sym.address
                    r.stack = true
                } else {
                    size = sym.size
                    sym.size = 8
                    if sym.stack == false {
                        sym.level = -1
                    } else {
                        sym.level = 0
                    }
                    nSym = gen.generateSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                    if val.isPointer == false {
                        r = gen.generateDereference(nSym)
                        r.size = val.type.size
                    } else {
                        r = nSym
                        r.size = 8
                    }
                    return r
                }
            } else {
                isLastPtr = true
                nSym = gen.generateSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                r = gen.generateTmpSym(nSym, nSym.size)
                addr = r.address
                r.level = 1
            }
            break
        }

        r.address = addr
        r.size = val.type.size
        if val.isPointer {
            if isLastPtr {
                r.level = 0
            } else {
                r.level = -1
            }
            r.size = 8
        }

        return r
    }

    if val.isStructDeclare {
        sym asmSymbol

        structType = val.type
        if val.type.isPtr {
            structType = val.type.child
        }
        initFn = parserCtx.findFunc(structType.child.name+"._init")

        if val.type.isPtr == false {
            sym = gen.generateVarDecl("strct_declare", val.type.size, true)
            currVal = val.left
            for currVal != null, currVal = currVal.left {
                gen.generateLineLocation(currVal.right.tok.line)
                fieldVal = generateBahValueSymbol(currVal.right)
                fieldSym = asmSymbolStack(sym.address - currVal.type.offset, currVal.type.size)
                gen.generateVarSet(fieldSym, fieldVal, currVal.type.type == BAH_TYPE_UINT)
            }

            if initFn != null {
                gen.generateFnCallStart()
                pSym = sym
                pSym.level = -1
                pSym.size = 8
                gen.generateFnCallArgument(pSym)
                gen.generateFnCall(asmSymbolValue(initFn.name), 0, false)
            }

            return sym
        }

        sym = gen.generateVarDecl("strct_declare", 8, false)
        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(val.type.child.size)))
        gen.generateMoveValue(gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, false), sym)
        currVal = val.left
        for currVal != null, currVal = currVal.left {
            gen.generateLineLocation(currVal.right.tok.line)
            fieldVal = generateBahValueSymbol(currVal.right)
            if currVal.right.isFunctionSym {
                fieldVal = gen.generateTmpSym(fieldVal, 8)
            }
            nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(currVal.type.offset)))
            fieldSym = nSym
            fieldSym.size = currVal.type.size
            fieldSym = gen.generateDestDereference(fieldSym)
            gen.generateVarSet(fieldSym, fieldVal, currVal.type.type == BAH_TYPE_UINT)

        }
        sym.size = 8


        if initFn != null {
            gen.generateFnCallStart()
            gen.generateFnCallArgument(sym)
            gen.generateFnCall(asmSymbolValue(initFn.name), 0, false)
        }

        return sym
    }

    if val.isArrayDeclare {
        sym = gen.generateVarDecl("array_declare", 8, false)
        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(val.type.size)))
        gen.generateMoveValue(gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, false), sym)

        nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(ARR_ELEMSIZE_OFFSET)))
        elemSizeSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(elemSizeSym, gen.staticInt(uintToStr(val.type.child.size)), true)

                
        arrLen = 0
        currVal = val.right
        for currVal != null, currVal = currVal.right {
            arrLen++
        }

        nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(ARR_LENGTH_OFFSET)))
        lengthSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)

        if arrLen < 64 {
            arrLen = 64
        }

        nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(ARR_REALENGTH_OFFSET)))
        lengthSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)


        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(val.type.child.size * arrLen)))
        fnRet = gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, false)
        dataSym = gen.generateDestDereference(sym)
        gen.generateMoveValue(fnRet, dataSym)
        dataSym.level = 0
        gen.generateMoveValue(fnRet, dataSym)
        

        currVal = val.right
        index = 1
        for currVal != null, currVal = currVal.right {

            elemSym = generateBahValueSymbol(currVal.left)

            dataSym.level = 1
            dataSym.size = val.type.child.size
            gen.generateVarSet(dataSym, elemSym, currVal.left.type.type == BAH_TYPE_UINT)

            if currVal.right != null {
                dataSym = gen.generateDestDereference(sym)
                dataSym = gen.generateDestSymOffset(dataSym, gen.staticInt(uintToStr(val.type.child.size * index)))                
                index++
            }
        }
        

        return sym
    }

    if val.isTupleDeclare {
        currVal = val.left

        sym = gen.generateVarDecl("tuple_declare", val.type.size, false)

        offset = 0

        for currVal != null, currVal = currVal.left {
            setSym = sym
            setSym.size = currVal.right.type.size
            setSym.address -= offset

            gen.generateVarSet(setSym, generateBahValueSymbol(currVal.right), currVal.right.type.type == BAH_TYPE_UINT)

            offset += currVal.right.type.size
        }

        return sym
    }

    if val.isOperation {

        if val.isSelfOp {
            if val.tok.cont == "+" {
                return gen.generateSelfOp(generateBahValueSymbol(val.left), ASM_SELF_OP_ADD)
            } else {
                return gen.generateSelfOp(generateBahValueSymbol(val.left), ASM_SELF_OP_SUB)
            }
        }

        if val.left.type.isPtr && val.tok.cont != "==" && val.tok.cont != "!=" && val.left.type.child.type != BAH_TYPE_STRCT {
            throwError(&val.tok, "Cannot perform operation on pointers.")
        }

        opStr = val.tok.cont

        if val.left.type.type == BAH_TYPE_STR && opStr[0] == '+' {
            gen.generateStrConcatBegin()

            if val.right.tok.cont == "+" {
                currAdd = val
                for currAdd != null, currAdd = currAdd.right {
                    if currAdd.isOperation == false || currAdd.tok.cont[0] != '+' {
                        gen.generateStrConcat(generateBahValueSymbol(currAdd))
                        return gen.generateStrConcatEnd()
                    }
                    gen.generateStrConcat(generateBahValueSymbol(currAdd.left))
                }
            }

            gen.generateStrConcat(generateBahValueSymbol(val.left))
            gen.generateStrConcat(generateBahValueSymbol(val.right))
            return gen.generateStrConcatEnd()
        }
        
        if opStr == "||" {
            gen.generateBoolOrStart()

            if val.right.tok.cont == "||" {
                currOr = val
                for currOr != null, currOr = currOr.right {
                    if currOr.tok.cont != "||" {
                        return gen.generateBoolOrEnd(generateBahValueSymbol(currOr))
                    }
                    gen.generateBoolOr(generateBahValueSymbol(currOr.left))
                }
            }

            gen.generateBoolOr(generateBahValueSymbol(val.left))
            return gen.generateBoolOrEnd(generateBahValueSymbol(val.right))

        } else if opStr == "&&" {
            gen.generateBoolAndStart()

            if val.right.tok.cont == "&&" {
                currOr = val
                for currOr != null, currOr = currOr.right {
                    if currOr.tok.cont != "&&" {
                        return gen.generateBoolAndEnd(generateBahValueSymbol(currOr))
                    }
                    gen.generateBoolAnd(generateBahValueSymbol(currOr.left))
                }
            }

            gen.generateBoolAnd(generateBahValueSymbol(val.left))
            return gen.generateBoolAndEnd(generateBahValueSymbol(val.right))

        }

        //rearrange tree for position dependent operations
        if (opStr[0] == '-' || opStr[0] == '/') && val.right.isOperation && val.right.pemdas == val.pemdas {
            currVal = val.right
            prevVal = val
            currSym = generateBahValueSymbol(val.left)

            for currVal.pemdas == val.pemdas, currVal = currVal.right {
                currSym = gen.generateTmpSym(currSym, currSym.size)
                currSym = generateValueOperation(&prevVal.tok, currSym, generateBahValueSymbol(currVal.left), currVal.left.type)

                if currVal.right.isOperation == false {
                    currSym = gen.generateTmpSym(currSym, currSym.size)
                    currSym = generateValueOperation(&currVal.tok, currSym, generateBahValueSymbol(currVal.right), currVal.right.type)
                    break
                }
                prevVal = currVal
            }

            if currVal.isOperation && currVal.pemdas != val.pemdas {
                currSym = gen.generateTmpSym(currSym, currSym.size)
                currSym = generateValueOperation(&prevVal.tok, currSym, generateBahValueSymbol(currVal), currVal.type)
            }

            return currSym
        }



        leftSym = generateBahValueSymbol(val.left)

        leftSym = gen.generateTmpSym(leftSym, leftSym.size)

        rightSym = generateBahValueSymbol(val.right)



        return generateValueOperation(&val.tok, leftSym, rightSym, val.left.type)

    }

    if val.isFunctionCall {

        fnName = val.tok.cont
        isMethodCall = false

        //need to pass the structure pointer to the method function
        if val.left.isStruct && val.left.type.child != null && val.left.type.child.isPtr && (val.left.left.type.isPtr && compatibleTypes(val.left.left.type, val.left.type.child) || val.left.left.type.isPtr == false && compatibleTypes(val.left.left.type, val.left.type.child.child)) {
            isMethodCall = true
            //we need to pre generate the parent value
            parent = generateBahValueSymbol(val.left.left)
            val.left.left.isVariable = true
            val.left.left.sym = parent
        }

        fnNameSym = generateBahValueSymbol(val.left)
    
        if fnName == "sizeof" {
            return gen.staticInt(uintToStr(val.right.left.type.size))
        }

        if fnName == "len" {
            if val.right.left.type.type == BAH_TYPE_ARRAY {
                fnNameSym = asmSymbolValue("__bah_arrayLength")
            } else if val.right.left.type.type == BAH_TYPE_STR {
                fnNameSym = asmSymbolValue("__bah_strlenSTR")
            }
        } else if fnName == "panic" {
            fnNameSym = asmSymbolValue("__Bah_panic")
            gen.generateFnCallStart()

            sym = generateBahValueSymbol(val.right.left)
            gen.generateFnCallArgument(sym)

            locLine = "\""+absPath(parserCtx.currentFilePath)+":"+uintToStr(val.tok.line)+"\""

            sym = gen.generateStaticStr(locLine, getStrLen(locLine))
            gen.generateFnCallArgument(sym)


            return gen.generateFnCall(fnNameSym, 0, false)
        }

        // if fnName == "syscall" {
        //     return gen.generateSyscall(null, generateBahValueSymbol(), 8)
        // }

        gen.generateFnCallStart()

        if isMethodCall {
            parentSym = val.left.left.sym
            if val.left.left.type.isPtr == false {
                parentSym.level -= 1
            }
            parentSym.size = 8
            gen.generateFnCallArgument(parentSym)
        }

        argVal = val.right

        for argVal != null, argVal = argVal.right {
            
            sym = asmSymbol{}

            if argVal.isReflect {
                sym = generateReflection(argVal.left)
            } else if argVal.left.type.size != argVal.type.size && (argVal.type.size > 8 || argVal.type.size < argVal.left.type.size) {
                sym = generateTypeConversion(argVal.left, argVal.type)
            } else {
                sym = generateBahValueSymbol(argVal.left)
            }


            //convert str to char* in fn call
            if argVal.type.isPtr && argVal.type.child.type == BAH_TYPE_UINT && argVal.type.child.size == 1 && argVal.left.type.type == BAH_TYPE_STR {
                sym = gen.generateSymOffset(sym, asmSymbolValue("$4"))
                sym = gen.generateTmpSym(sym, sym.size)
            }

            gen.generateFnCallArgument(sym)

        }
        returnSize = 0
        isFloat = false
        if val.type != null {
            returnSize = val.type.size
            isFloat = val.type.type == BAH_TYPE_FLOAT
        }

        return gen.generateFnCall(fnNameSym, returnSize, isFloat)
    }

    throwError(&val.tok, "Internal error generating value asm symbol: "+toJson(val)+".")

    return r
}

generateBahLeftValueSymbol(lval bahLeftValue*) asmSymbol {
    r = asmSymbol{}

    if lval.isUnary {
        sym = gen.generateDestDereference(generateBahLeftValueSymbol(lval.left))
        sym.size = lval.left.type.child.size

        return sym
    }

    if lval.isStruct {
        currVal = lval
        addr = 0
        for currVal.left != null, currVal = currVal.left {
            addr -= currVal.right.type.offset

            // if currVal.left.isStruct == false {
                sym = generateBahLeftValueSymbol(currVal.left)
                if currVal.left.type.isPtr == false {
                    if sym.stack && sym.isTmp == false {
                        addr += sym.address
                        r.stack = true
                    } else {
                        size = sym.size
                        sym.size = 8
                        if sym.stack == false {
                            sym.level = -1
                        } else {
                            sym.level = 0
                        }
                        nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                        r = gen.generateDestDereference(nSym)
                        r.size = lval.type.size
                        return r
                    }
                } else {
                    nSym = gen.generateDestSymOffset(sym, gen.staticInt(intToStr(0 - addr)))
                    nSym.size = lval.type.size
                    return gen.generateDestDereference(nSym)
                }
                break
            // }

            // if currVal.left.type.isPtr {
            //     break
            // }
        }


        // r.stack = true
        r.address = addr
        r.size = lval.type.size
        return r
    }

    if lval.isBuffer {
        sym = generateBahLeftValueSymbol(lval.left)
        indexSym = generateBahValueSymbol(lval.index)
        sym.size = 8
        sym = gen.generateDestSymOffset(sym, indexSym)
        sym.size = 1
        sym.level = 1
        return sym
    }

    if lval.isArray {
        sym = generateBahLeftValueSymbol(lval.left)
        sym = gen.generateTmpSym(sym, 8)

        indexSym = generateBahValueSymbol(lval.index)
        indexSym = gen.generateTmpSym(indexSym, 8)

        gen.generateFnCallStart()

        gen.generateFnCallArgument(sym)
        gen.generateFnCallArgument(indexSym)

        gen.generateFnCall(asmSymbolValue("__Bah_realocate_arr"), 0, false)

        sym = gen.generateDestDereference(sym)

        indexSym = gen.generateOpMult(indexSym, gen.staticInt(uintToStr(lval.left.type.child.size)), ASM_NUM_UINT)
        sym = gen.generateDestSymOffset(sym, indexSym)
        sym.level = 1
        sym.size = lval.left.type.child.size
        return sym
    }

    if lval.isTuple {
        sym = generateBahLeftValueSymbol(lval.left)
        sym.size = 8
        sym.level = -1
        sym = gen.generateDestSymOffset(sym, gen.staticInt(uintToStr(lval.type.offset)))
        sym.size = lval.type.size
        sym.level = 0
        return sym
    }

    if lval.isVariable {
        // if lval.variable.scope == 0 && lval.type.type == BAH_TYPE_STR {
        //    sym = lval.variable.sym
        //    sym.level = 1
        //    return sym
        // }
        return lval.variable.sym
    }

    throwError(&lval.tok, "Internal error generating left-value asm symbol.")

    return r
}

struct _typeAndSymStack {
    type: bahType*
    sym: asmSymbol
}

generateReflectionFromType(type bahType*, typesStack []_typeAndSymStack) asmSymbol {

    i=0; for i < len(typesStack), i++ {
        if isSameType(typesStack[i].type, type) {
            return typesStack[i].sym
        }
    }

    ogType = type

    for type.isPtr {
        if type.type == BAH_TYPE_PTR {
            break
        }
        type = type.child
    }

    for type.type == BAH_TYPE_CUSTOM_TYPE {
        type = type.child
    }

    sym = gen.generateVarDecl("reflect_elem", REFLECT_TYPE_SIZE, false)
    setSym = sym
    setSym.size = 8

    typesStack[len(typesStack)] = _typeAndSymStack {ogType, sym}

    //size
    if type.type == BAH_TYPE_ARRAY {
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(ARR_TYPE_SIZE)), true)
    } else if type.type == BAH_TYPE_MAP {
        printDebugContext()
        panic("size not known yet")
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(ARR_TYPE_SIZE)), true)
    } else if type.type == BAH_TYPE_CHAN {
        printDebugContext()
        panic("size not known yet")
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(ARR_TYPE_SIZE)), true)
    } else {
        gen.generateVarSet(setSym, gen.staticInt(uintToStr(type.size)), true)
    }

    //type
    typeStr = "\""+ogType.toStr()+"\""
    setSym.address -= 8
    gen.generateVarSet(setSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

    //isArray
    setSym.address -= 16
    if type.type == BAH_TYPE_ARRAY {
        gen.generateVarSet(setSym, gen.staticInt("1"), true)
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //arrayElement
    setSym.address -= 8
    if type.type == BAH_TYPE_ARRAY {
        arrElem = generateReflectionFromType(type.child, typesStack)
        arrElem.level = -1
        arrElem.size = 8
        gen.generateVarSet(setSym, arrElem, false)
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //isStruct
    setSym.address -= 8
    if type.type == BAH_TYPE_STRCT {
        gen.generateVarSet(setSym, gen.staticInt("1"), true)
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //strutLayout
    setSym.address -= 8
    if type.type == BAH_TYPE_STRCT {
    
        structLayoutSym = gen.generateVarDecl("array_declare", 8, false)
        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(ARR_TYPE_SIZE)))
        gen.generateMoveValue(gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, false), structLayoutSym)

        nSym = gen.generateDestSymOffset(structLayoutSym, gen.staticInt(intToStr(ARR_ELEMSIZE_OFFSET)))
        elemSizeSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(elemSizeSym, gen.staticInt(uintToStr(REFLECT_TYPE_SIZE)), true)

        arrLen = 0
        currFieldType = type.child.next
        for currFieldType != null, currFieldType = currFieldType.next {
            arrLen++
        }

        nSym = gen.generateDestSymOffset(structLayoutSym, gen.staticInt(intToStr(ARR_LENGTH_OFFSET)))
        lengthSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)

        nSym = gen.generateDestSymOffset(structLayoutSym, gen.staticInt(intToStr(ARR_REALENGTH_OFFSET)))
        lengthSym = gen.generateDestDereference(nSym)
        gen.generateVarSet(lengthSym, gen.staticInt(uintToStr(arrLen)), true)


        gen.generateFnCallStart()
        gen.generateFnCallArgument(gen.staticInt(uintToStr(REFLECT_TYPE_SIZE * arrLen)))
        fnRet = gen.generateFnCall(asmSymbolValue(memoryAllocFunction), 8, false)
        dataSym = gen.generateDestDereference(structLayoutSym)
        gen.generateMoveValue(fnRet, dataSym)
        dataSym.level = 0
        gen.generateMoveValue(fnRet, dataSym)
        gen.generateVarSet(setSym, structLayoutSym, true)
        

        currFieldType = type.child.next
        index = 0
        for currFieldType != null, currFieldType = currFieldType.next {

            elemSym = generateReflectionFromType(currFieldType, typesStack)

            // offstetElemSym = elemSym
            // offstetElemSym.address -= 56
            // offstetElemSym.size = 8
            // gen.generateVarSet(offstetElemSym, gen.staticInt(uintToStr(currFieldType.offset)), true)

            // typeStr = "\""+currFieldType.name+"\""
            // offstetElemSym.address = elemSym.address - 16
            // gen.generateVarSet(offstetElemSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

            dataSym = gen.generateDestDereference(structLayoutSym)
            dataSym = gen.generateDestSymOffset(dataSym, gen.staticInt(uintToStr(REFLECT_TYPE_SIZE * index)))
            dataSym.level = 1
            dataSym.size = REFLECT_TYPE_SIZE
            gen.generateVarSet(dataSym, elemSym, false)

            typeStr = "\""+currFieldType.name+"\""
            offstetElemSym = dataSym
            offstetElemSym.level = 0
            offstetElemSym.size = 8
            //previous var set incremented %rdi to dataSym address + 64, we need to set dataSym at offset 16: 16 - 64 = 48
            offstetElemSym = gen.generateSymOffset(offstetElemSym, gen.staticInt(intToStr(-48)))
            offstetElemSym.level = 1
            gen.generateVarSet(offstetElemSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

            offstetElemSym.level = 0
            offstetElemSym = gen.generateSymOffset(offstetElemSym, gen.staticInt(uintToStr(40)))
            offstetElemSym.level = 1
            gen.generateVarSet(offstetElemSym, gen.staticInt(uintToStr(currFieldType.offset)), true)
             
            index++
        }
    } else {
        gen.generateVarSet(setSym, gen.staticInt("0"), true)
    }

    //offset
    setSym.address -= 8
    gen.generateVarSet(setSym, gen.staticInt("0"), true)

    return sym
}

generateReflection(val bahValue*) asmSymbol {
    types = []_typeAndSymStack

    sym = generateReflectionFromType(val.type, types)
    setSym = sym
    setSym.size = 8

    //name
    //TODO: better naming generation
    typeStr = "\""+val.tok.cont+"\""
    setSym.address = sym.address - 16
    gen.generateVarSet(setSym, gen.generateStaticStr(typeStr, getStrLen(typeStr)), false)

    //value
    setSym.address = sym.address - 64
    valSym = generateBahValueSymbol(val)
    if val.type.isNativePtr == false {
        valSym.level = -1
        valSym.size = 8
    }
    gen.generateVarSet(setSym, valSym, false)

    return sym
}

generateTypeConversion(val bahValue*, type bahType*) asmSymbol {
    for type.type == BAH_TYPE_CUSTOM_TYPE {
        type = type.child
    }

    if (type.isPtr || type.isNativePtr) && val.type.isNativePtr == false && val.type.isPtr == false && val.type.size != 8 && val.type.type != BAH_TYPE_BUFFER {
        throwError(&val.tok, "Cannot be converted to a pointer type.")
    }

    if type.type == BAH_TYPE_INT || type.type == BAH_TYPE_UINT || type.type == BAH_TYPE_BOOL || val.type.type == BAH_TYPE_PTR || type.type == BAH_TYPE_PTR {
        
        if val.type.type == BAH_TYPE_FLOAT {
            return gen.generateConvFloatToInt(generateBahValueSymbol(val), type.size)
        }

        if val.type.size > 8 && val.type.isNativePtr == false && val.type.type != BAH_TYPE_BUFFER {
            throwError(&val.tok, "Invalid conversion, you may need to convert a pointer.")
        }

        r = generateBahValueSymbol(val)

        if type.size != val.type.size && val.isStaticValue == false {
            if r.size > 8 {
                r.size = 8
            }
            return gen.generateConvSizes(r, type.size, type.type == BAH_TYPE_UINT)
        }

        return r

    } else if type.type == BAH_TYPE_FLOAT {

        if val.type.type == BAH_TYPE_INT {
            return gen.generateConvIntToFloat(generateBahValueSymbol(val), type.size)
        }

    }

    if val.type.type == type.type || val.type.isNativePtr && type.isNativePtr {
        size = type.size
        if type.isNativePtr {
            size = 8
        }
        r = generateBahValueSymbol(val)
        if r.size != size && val.isStaticValue == false {
            gen.generateMoveValue(r, asmSymbolReg(ASM_reg_id_op, r.size, 0))
            r = asmSymbolReg(ASM_reg_id_op, size, 0)
        }
        return r
    }



    throwError(&val.tok, "Internal error generating conversion of asm symbol.")

    r = asmSymbol{}
    return r
}

generateImmediateValues(val bahValue*, syms []asmSymbol) {

    if val.type.isPtr {
        throwError(&val.tok, "Cannot (yet) use a pointer as a global value.")
    }

    if val.tok.type == TOKEN_TYPE_INT {
        syms[len(syms)] = asmSymbol {
            size: val.type.size
            name: val.tok.cont
        }
    } else if val.tok.type == TOKEN_TYPE_STR {
        sym = gen.generateStaticStr(val.tok.cont, getStrLen(val.tok.cont))
        syms[len(syms)] = asmSymbol {
            size: 8
            name: sym.name
        }
    } else if val.isArrayDeclare {
        arrLen = 0
        currVal = val.right
        for currVal != null, currVal = currVal.right {
            arrLen++
        }

        nSyms = []asmSymbol
        //data
        nSyms[len(nSyms)] = asmSymbol {
            size: 8
            name: "0"
        }
        //length
        nSyms[len(nSyms)] = asmSymbol {
            size: 8
            name: uintToStr(arrLen)
        }
        //realLength
        nSyms[len(nSyms)] = asmSymbol {
            size: 8
            name: uintToStr(arrLen)
        }
        //elemSize
        nSyms[len(nSyms)] = asmSymbol {
            size: 8
            name: uintToStr(val.type.child.size)
        }

        //to get ptr to value
        privArrName = ".VAR_ARRAY_"+uintToStr(asmRandId)
        privArrSym = asmSymbolStaticName(privArrName)
        privArrSym.size = 8
        privArrSym.level = -1
        sym = gen.generatePrivateVarWithValue(privArrName, val.type.size, nSyms)
        asmRandId++

        syms[len(syms)] = asmSymbol {
            size: 8
            name: sym.name
        }

        realGen = gen
        gen = initFnGen
        gen.fileNb = realGen.fileNb
        gen.totalFileNb = realGen.totalFileNb

        arrSym = generateBahValueSymbol(val)
        arrSym = gen.generateDereference(arrSym)
        arrSym.size = 8
        

        privArrSymData = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
        gen.generateMoveValue(privArrSym, privArrSymData)
        privArrSymData.level = 1

        gen.generateVarSet(privArrSymData, arrSym, false)

        realGen.data += gen.data
        realGen.bss += gen.bss
        gen = realGen

        
    } else if val.isStructDeclare {

        currTp = val.type.child
        for currTp != null, currTp = currTp.next {
            
            currVal = val.left
            for currVal != null, currVal = currVal.left {
                if currVal.type.name == currTp.name {
                    break
                }
            }

            if currVal != null {
                generateImmediateValues(currVal.right, syms)
            } else {
                //zero field
                size = currTp.size
                incr = 8
                for size > 0, size -= incr {    
                    for incr > size {
                        incr = incr / 2
                    }
                    syms[len(syms)] = asmSymbol {
                        name: "0"
                        size: incr
                    }
                }
            }
        }

    } else if val.sym.isValue {
        name = val.sym.name
        if name[0] == '$' {
            name = name[1:]
        }
        syms[len(syms)] = asmSymbol {
            name: name
            size: val.sym.size
        }
    } else {
        throwError(&val.tok, "Cannot use this value as a global value. (immediate value not yet implemented).")
    }

}
