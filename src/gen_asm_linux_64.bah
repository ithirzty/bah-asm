#import "rope.bah"
#import "string.bah"
#import "iostream.bah"
#import "json.bah"

#include "globals.bah"

#define printDebugContext()


const ASM_arguments_registers_64 = []str{"%rdi", "%rsi", "%rdx", "%rcx",  "%r8",  "%r9"}
const ASM_arguments_registers_32 = []str{"%edi", "%esi", "%edx", "%ecx", "%r8d", "%r9d"}
const ASM_arguments_registers_16 = []str{"%di", "%si", "%dx", "%cx", "%r8w", "%r9w"}
const ASM_arguments_registers_8  = []str{"%dil", "%sil", "%dl", "%cl", "%r8b", "%r9b"}

const ASM_arguments_registers = [][]str{ASM_arguments_registers_8, ASM_arguments_registers_16, ASM_arguments_registers_32, ASM_arguments_registers_64}

const ASM_float_registers = []str{"%xmm0", "%xmm1", "%xmm2", "%xmm3", "%xmm4", "%xmm5", "%xmm6", "%xmm7", "%xmm8", "%xmm9", "%xmm10", "%xmm11", "%xmm12", "%xmm13", "%xmm14", "%xmm15"}

const ASM_ymm_registers = []str{"%ymm0", "%ymm1", "%ymm2", "%ymm3", "%ymm4", "%ymm5", "%ymm6", "%ymm7", "%ymm8", "%ymm9", "%ymm10", "%ymm11", "%ymm12", "%ymm13", "%ymm14", "%ymm15"}

const ASM_syscall_registers_64 = []str{"%rax", "%rbx", "%rcx", "%rdx"}
const ASM_syscall_registers_32 = []str{"%eax", "%ebx", "%ecx", "%edx"}
const ASM_syscall_registers_16 = []str{"%eax", "%ebx", "%ecx", "%edx"}
const ASM_syscall_registers_8  = []str{"%eax", "%ebx", "%ecx", "%edx"}

const ASM_syscall_registers = [][]str{ASM_syscall_registers_8, ASM_syscall_registers_16, ASM_syscall_registers_32, ASM_syscall_registers_64}

const ASM_op_registers_64 = []str{"%rbx", "%rdx",  "%r8",  "%r9",  "%r10",  "%r11",  "%r12",  "%r13",  "%r14",  "%r15"}
const ASM_op_registers_32 = []str{"%ebx", "%edx", "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"}
const ASM_op_registers_16 = []str{ "%bx",  "%dx", "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w"}
const ASM_op_registers_8  = []str{ "%bl",  "%dl", "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"}

const ASM_op_registers = [][]str{ASM_op_registers_8, ASM_op_registers_16, ASM_op_registers_32, ASM_op_registers_64}

const ASM_return_register    = []str{"%al", "%ax", "%eax", "%rax"}
const ASM_addr_dest_register = []str{"%dil", "%di", "%edi", "%rdi"}

const ASM_set = []str{"sete", "setne", "setg", "setl", "setle", "setge"}
const ASM_set_parity = []str{"setnp", "setp"}
const ASM_set_above_below_floats = []str{"", "", "seta", "seta", "setnb", "setnb"}
const ASM_set_above_below_unsgined = []str{"sete", "setne", "setb", "setb", "setnb", "setnb"}

const ASM_not = []str{"notb", "notw", "notl", "notq"}
const ASM_or = []str{"orb", "orw", "orl", "orq"}
const ASM_xor = []str{"xorb", "xorw", "xorl", "xorq"}
const ASM_and = []str{"andb", "andw", "andl", "andq"}
const ASM_shift_left = []str{"", "", "sall", "salq"}
const ASM_shift_right = []str{"", "", "sarl", "sarq"}

const ASM_bitwise_ops = [][]str{ASM_or, ASM_xor, ASM_and, ASM_shift_left, ASM_shift_right}

const ASM_reg_id_return = 0
const ASM_reg_id_dest_addr = 1
const ASM_reg_id_stack_pointer = 2
const ASM_reg_id_base_pointer = 3

const ASM_reg_id_args    = 128
const ASM_reg_id_syscall = 256
const ASM_reg_id_op      = 512
const ASM_reg_id_floats  = 1024
const ASM_reg_id_ymm     = 2048

const ASM_OP_EQ            = 0
const ASM_OP_NOT_EQ        = 1
const ASM_OP_GREATER       = 2
const ASM_OP_LESS          = 3
const ASM_OP_LESS_OR_EQ    = 4
const ASM_OP_GREATER_OR_EQ = 5

const ASM_OP_BITWISE_OR    = 0
const ASM_OP_BITWISE_XOR   = 1
const ASM_OP_BITWISE_AND   = 2
const ASM_OP_BITWISE_LEFT  = 3
const ASM_OP_BITWISE_RIGHT = 4

const ASM_SELF_OP_ADD = 0
const ASM_SELF_OP_SUB = 1


const ASM_lea  = []str{"", "", "leal", "leaq"}
const ASM_mov  = []str{"movb", "movw", "movl", "movq"}
const ASM_push = []str{"", "", "", "pushq"}
const ASM_pop  = []str{"", "", "", "popq"}
const ASM_add  = []str{"addb", "addw", "addl", "addq"}
const ASM_sub  = []str{"subb", "subw", "subl", "subq"}
const ASM_imul = []str{"imulb", "imulw", "imull", "imulq"}
const ASM_mul = []str{"mulb", "mulw", "mull", "mulq"}
const ASM_idiv = []str{"idivb", "idivw", "idivl", "idivq"}
const ASM_div = []str{"divb", "divw", "divl", "divq"}
const ASM_cmp = []str{"cmpb", "cmpw", "cmpl", "cmpq"}
const ASM_cmp_float = []str{"", "", "comiss", "comisd"}
const ASM_unordered_cmp_float = []str{"", "", "ucomiss", "ucomisd"}
const ASM_mov_float  = []str{"", "", "movd", "movq"}
const ASM_add_float  = []str{"", "", "addss", "addsd"}
const ASM_mul_float  = []str{"", "", "mulss", "mulsd"}
const ASM_sub_float  = []str{"", "", "subss", "subsd"}
const ASM_div_float  = []str{"", "", "divss", "divsd"}
const ASM_cond_mov_not_eq = "cmovne"
const ASM_convert_oct = "cqto"

GEN_AVXenabled = true
ASM_vector_mov = "vmovdqu"

GEN_disableAVX() {
    ASM_vector_mov = "movdqu"
}

const ASM_NUM_INT   = 0
const ASM_NUM_UINT  = 1
const ASM_NUM_FLOAT = 2

getTwoPow(x int) int {
    a = 2
    i=1; for a < x, i++ {
        a *= 2
    }

    if a != x {
        return -1
    }

    return i
}

spos(x uint) uint {
    if x == 1 {
        return 0
    }
    if x == 2 {
        return 1
    }
    if x == 4 {
        return 2
    }
    if x != 8 {
        return 0
    }

    return 3
}

asmRandId uint = 0

struct asmSymbol {
    name: str
    size: uint
    address: int
    offset: int
    level: int
    operStart: int = -1

    isFloat: bool
    isReg: bool
    stack: bool
    isTmp: bool
    isValue: bool
    active: bool

    toStr() str {
        if this.isValue {
            return this.name
        }

        if this.isTmp {
            return "TMP_"+uintToStr(this.address)
        }

        if this.isReg {

            s = ""
            size = this.size
            if this.level >= 1 {
                size = 8
            }
            if this.address == ASM_reg_id_return {
                s = ASM_return_register[spos(size)]
            } else if this.address == ASM_reg_id_dest_addr {
                s = ASM_addr_dest_register[spos(size)]
            } else if this.address == ASM_reg_id_stack_pointer {
                s = "%rsp"
            } else if this.address == ASM_reg_id_base_pointer {
                s = "%rbp"
            } else {
                if this.address < ASM_reg_id_syscall { //arguments
                    num = this.address - ASM_reg_id_args
                    if num > len(ASM_arguments_registers[spos(size)]) {
                        printDebugContext()
                        panic("Not enough argument registers")
                    }
                    s = ASM_arguments_registers[spos(size)][num]
                } else if this.address < ASM_reg_id_op { //syscall arguments
                    num = this.address - ASM_reg_id_syscall
                    if num > len(ASM_syscall_registers[spos(size)]) {
                        printDebugContext()
                        panic("Not enough syscall registers")
                    }
                    s = ASM_syscall_registers[spos(size)][num]
                } else if this.address < ASM_reg_id_floats { //operations and accumulators
                    num = this.address - ASM_reg_id_op
                    if num > len(ASM_op_registers[spos(size)]) {
                        printDebugContext()
                        panic("Not enough operation registers")
                    }
                    s = ASM_op_registers[spos(size)][num]
                } else if this.address < ASM_reg_id_ymm { //operations and accumulators
                    num = this.address - ASM_reg_id_floats
                    if num > len(ASM_float_registers) {
                        printDebugContext()
                        panic("Not enough XMM registers")
                    }
                    s = ASM_float_registers[num]
                } else {
                    num = this.address - ASM_reg_id_ymm
                    if num > len(ASM_ymm_registers) {
                        printDebugContext()
                        panic("Not enough YMM registers")
                    }
                    s = ASM_ymm_registers[num]
                }
            } 
            if this.level == 1 {
                if this.offset != 0 {
                    s = intToStr(this.offset)+"("+s+")"
                } else {
                    s = "("+s+")"
                }
            } else if this.offset != 0 {
                printDebugContext()
                panic("Offset of non dereferenced ptr.")
            }
            return s
        }

        if this.stack {


            //stack offset?
            if this.address == 0 {
                return "(%rbp)"
            }
            sub = "-"
            addr = this.address
            if this.address < 0 {
                sub = ""
                addr = 0 - this.address
            }
            return sub+uintToStr(addr)+"(%rbp)"
        }


        return this.name+"(%rip)"
    }
}

asmSymbolValue(s str) asmSymbol {
    r = asmSymbol{
        isValue: true
        name: s
        active: true
    }
    return r
}

asmSymbolReg(id uint, size uint, num uint) asmSymbol {
    r = asmSymbol {
        isReg: true
        size: size
        address: id + num
        active: true
    }

    if id >= ASM_reg_id_floats && id < ASM_reg_id_ymm {
        r.isFloat = true
    }
    return r
}

asmSymbolStack(address int, size uint) asmSymbol {
    r = asmSymbol {
        stack: true
        address: address
        size: size
        active: true
    }
    return r
}

asmSymbolStaticName(name str) asmSymbol {
    r = asmSymbol {
        name: name
        active: true
    }
    return r
}

asmSymbolTmp(size uint) asmSymbol {
    r = asmSymbol {
        stack: true
        isTmp: true
        address: asmRandId
        size: size
        active: true
    }
    asmRandId++
    return r
}

isEmptySymbol(sym asmSymbol*) bool {
    return sym.active == false
}

struct asmInstruction {
    instruction: str
    arg1: asmSymbol
    arg2: asmSymbol

    toStr() str {
        if isEmptySymbol(&this.arg2) == false {
            return this.instruction+" "+this.arg1.toStr()+", "+this.arg2.toStr()
        }
        if isEmptySymbol(&this.arg1) == false {
            return this.instruction+" "+this.arg1.toStr()
        }
        return this.instruction
    }
}

#define _asm_append_instruction(ctxPtr ptr, inst asmInstruction)

struct asmStrLookup {
    string: str
    symbolName: str
}

struct asmContext {
    // symbols: []asmSymbol

    staticData: rope*
    data: rope*
    bss: rope*
    code: rope*
    debugInfo: rope*

    debugEnabled: bool = true

    currentFn: str
    scope: uint
    startIndex: uint

    verbose: bool = true

    regIndex: uint

    stackOffset: uint
    maxStackOffset: uint

    endSym: queue
    forStack: queue

    enableOptimizations: bool = true

    xmmIndex: uint

    instructions: []asmInstruction
    discardedArgs: []asmSymbol

    strings: []asmStrLookup

    isSameArg(a asmSymbol*, b asmSymbol*) bool {
        if a.active == false || b.active == false {
            return false
        }

        if a.isTmp != b.isTmp {
            return false
        }

        if a.isTmp || b.isTmp {
            return a.address == b.address    
        }

        if a.stack {
            if b.stack == false {
                return false
            }

            if a.address == b.address {
                return true
            }

            if a.address < 0 && b.address >= 0 || a.address >= 0 && b.address < 0 {
                return false
            }

            if a.size < b.size {
                c = a
                a = b
                b = c
            }

            if a.address - a.size < b.address && a.address >= b.address {
                return true
            }

            return false
        }

        if a.isReg {
            if b.isReg == false {
                return false
            }

            if a.offset != b.offset {
                return false
            }

            if a.address == b.address {
                return true
            }

            if a.address == ASM_reg_id_op + 1 && b.address == ASM_reg_id_args + 2 || b.address == ASM_reg_id_op + 1 && a.address == ASM_reg_id_args + 2 {
                return true
            }

            if a.address == ASM_reg_id_op + 2 && b.address == ASM_reg_id_args + 4 || b.address == ASM_reg_id_op + 2 && a.address == ASM_reg_id_args + 4 {
                return true
            }
            
            if a.address == ASM_reg_id_op + 3 && b.address == ASM_reg_id_args + 5 || b.address == ASM_reg_id_op + 3 && a.address == ASM_reg_id_args + 5 {
                return true
            }

            if a.address > ASM_reg_id_ymm && b.address > ASM_reg_id_floats && a.address - ASM_reg_id_floats == b.address {
                return true
            }

            if b.address > ASM_reg_id_ymm && a.address > ASM_reg_id_floats && b.address - ASM_reg_id_floats == a.address {
                return true
            }

            return false
        }

        if a.isValue {
            if b.isValue == false {
                return a.name == b.toStr()
            }
            return a.name == b.name
        }

        if b.isValue {
            return b.name == a.toStr()
        }

        if len(a.name) == 0 {
            return false
        }

        if len(b.name) == 0 {
            return false
        }

        return a.name == b.name
    }

    isSameArgAndSize(a asmSymbol*, b asmSymbol*) bool {
        if this.isSameArg(a, b) {
            return a.address == b.address && a.size == b.size && a.level == b.level
        }

        return false
    }

    isSet(arg asmSymbol*, i uint) bool {
        if strHasPrefix(this.instructions[i].instruction, "cmp") == true {
            return arg.isReg && arg.address == ASM_reg_id_return
        }

        if this.instructions[i].instruction == "cqto" || strHasPrefix(this.instructions[i].instruction, "div") == true {
            return arg.isReg && (arg.address == ASM_reg_id_return || arg.address == ASM_reg_id_op + 1 || arg.address == ASM_reg_id_args + 2)
        }

        if arg.isReg && this.instructions[i].instruction == "call" {
            return true
        }

        if this.isSameArg(&this.instructions[i].arg2, arg) {
            if this.instructions[i].arg2.isReg && this.instructions[i].arg2.level == 1 {
                return false
            }
            return true
        }

        return false
    }

    isUsed(arg asmSymbol*, i uint) bool {
        //do not optimize out global variables
        if arg.isReg == false && arg.stack == false && arg.isValue == false {
            return true
        }

        if strHasPrefix(this.instructions[i].instruction, "cmp") {
            if this.isSameArg(&this.instructions[i].arg1, arg) || this.isSameArg(&this.instructions[i].arg2, arg) {
                return true
            }
            return false
        }

        if this.instructions[i].instruction == "cqto" || strHasPrefix(this.instructions[i].instruction, "div") == true {
            return arg.isReg && arg.address == ASM_reg_id_return
        }

        if arg.isTmp == false && this.instructions[i].instruction[0] == 'j' {
            return true
        }

        if arg.isReg && this.instructions[i].instruction == "call" {
            return true
        }

        if arg.isReg && arg.address == ASM_reg_id_return && this.instructions[i].instruction == "ret" {
            return true
        }

        if this.isSameArg(&this.instructions[i].arg1, arg) {
            return true
        }

        return false
    }

    isSetInRange(arg asmSymbol*, from uint, end uint) bool {
        i = from; for i < end, i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }
            
            if this.isSet(arg, i) {
                return true
            }
        }

        return false
    }

    isUsedInRange(arg asmSymbol*, from uint, end uint) bool {
        i = from; for i < end, i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if arg.isTmp && strHasPrefix(this.instructions[i].instruction, ".loc") {
                return false
            }

            if this.isSet(arg, i) {
                return arg.stack && arg.isTmp == false
            }
            
            if this.isUsed(arg, i) {
                return true
            }

        }

        return false
    }

    getUsedInRange(arg asmSymbol*, from uint, end uint) int {
        i = from; for i < end, i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if arg.isTmp && strHasPrefix(this.instructions[i].instruction, ".loc") {
                return -1
            }

            if this.isSet(arg, i) {
                if arg.stack && arg.isTmp == false {
                    return i
                }
                return -1
            }
            
            if this.isUsed(arg, i) {
                return i
            }

        }

        return -1
    }

    removeStackAlloc(sym asmSymbol) {
        if sym.address % 8 != 0 {
            return //to not mess up stack alignment without realigning all symbol after sym.address
        }

        size = sym.size

        if size % 8 != 0 {
            size = size + 8 - (size%8)
        }

        this.stackOffset -= size

        i=this.startIndex; for i < len(this.instructions), i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }
            if this.instructions[i].arg1.stack && this.instructions[i].arg1.address > sym.address {
                this.instructions[i].arg1.address = this.instructions[i].arg1.address - size

            }

            if this.instructions[i].arg2.stack && this.instructions[i].arg2.address > sym.address {
                this.instructions[i].arg2.address = this.instructions[i].arg2.address - size
            }
        }
    }


    removeStackAllocs() {
        i=0; for i < len(this.discardedArgs), i++ {
            printDebugContext()
            ind = i
            prevInd = ind
            i++
            for i < len(this.discardedArgs), i++ {
                alignment = 1
                if this.discardedArgs[i].size == 4 {
                    alignment = 8
                } if this.discardedArgs[i].size >= 8 {
                    alignment = 16
                }
                alignedAddress = this.discardedArgs[prevInd].address + this.discardedArgs[prevInd].size
                if alignedAddress % alignment != 0 {
                    alignedAddress += (alignment - alignedAddress % alignment)
                }

                if alignedAddress != this.discardedArgs[i].address {
                    break
                }
                prevInd = i
            }
            i--
            if i == ind {
                this.removeStackAlloc(this.discardedArgs[i])
            } else {
                tmpSym = this.discardedArgs[ind]
                tmpSym.size = (this.discardedArgs[i].address + this.discardedArgs[i].size) - tmpSym.address
                this.removeStackAlloc(tmpSym)
            }
        }
        clear(this.discardedArgs)
    }

    optimizeInstructions() {

        uses = []asmInstruction*

        i = this.startIndex; for i < len(this.instructions), i++ {
            istrct = &this.instructions[i]

            if istrct.instruction[0] == '#' {
                continue
            }

            if strHasPrefix(istrct.instruction, "add") || strHasPrefix(istrct.instruction, "sub") {
                if istrct.arg1.isValue && istrct.arg1.name == "$0" {
                    istrct.instruction = "#"
                }
                continue
            }

            if istrct.instruction[0] != 'm' {
                continue
            }

            if istrct.arg1.size != istrct.arg2.size || istrct.arg1.level != istrct.arg2.level {
                continue
            }

            if this.isSameArg(&istrct.arg1, &istrct.arg2) {
                istrct.instruction = "#"
                continue
            }

            if istrct.arg2.isReg && istrct.arg2.address >= ASM_reg_id_floats || istrct.arg2.stack && istrct.arg2.isTmp == false && istrct.arg2.address < 0 || istrct.arg2.isReg == false && istrct.arg2.stack == false && istrct.arg2.isValue == false {
                continue
            }

            if istrct.arg2.stack && istrct.arg2.isTmp == false && this.isSetInRange(&istrct.arg2, this.startIndex, i) {
                continue
            }

            isTmp = istrct.arg1.isTmp || istrct.arg2.isTmp

            j=i+1; for j < len(this.instructions), j++ {
                agnst = &this.instructions[j]

                if agnst.instruction[0] == '#' {
                    continue
                }

                if agnst.instruction[0] == 'm' { 
                    if this.isSameArgAndSize(&istrct.arg2, &agnst.arg1) && istrct.arg2.size == agnst.arg2.size && ((istrct.arg1.isReg && istrct.arg1.level == 0) || (agnst.arg2.isReg && agnst.arg2.level == 0)) {
                        // if this.isUsedInRange(&istrct.arg2, j+1, len(this.instructions)) || this.isSetInRange(&agnst.arg2, i+1, j) {
                        if this.isSetInRange(&agnst.arg2, i+1, j) {
                            break
                        }

                        if agnst.arg2.isReg && agnst.arg2.address >= ASM_reg_id_floats || agnst.arg2.stack && agnst.arg2.isTmp == false && agnst.arg2.address < 0 || agnst.arg2.isReg == false && agnst.arg2.stack == false && agnst.arg2.isValue == false {
                            break
                        }

                        nextUse = this.getUsedInRange(&istrct.arg2, j+1, len(this.instructions))
                        if nextUse != -1 {

                            if istrct.arg1.isReg == false {
                                break
                            }

                            currUse = j+1
                            wouldBreak = false
                            clear(uses)
                            uses[len(uses)] = agnst
                            for nextUse != -1 && currUse < len(this.instructions) {
                                if this.isSetInRange(&istrct.arg1, currUse, nextUse) || this.isSetInRange(&agnst.arg2, currUse, nextUse) {
                                    wouldBreak = true
                                    break
                                }
                                nu = &this.instructions[nextUse]

                                if this.isSet(&istrct.arg2, nextUse) {
                                    break
                                }

                                if nu.instruction[0] != 'j' && nu.instruction[0] != '.' {
                                    uses[len(uses)] = nu
                                }

                                if this.isSetInRange(&istrct.arg2, currUse, nextUse) {
                                    break
                                }
                                currUse = nextUse
                                nextUse = this.getUsedInRange(&istrct.arg2, currUse+1, len(this.instructions))
                            }

                            if wouldBreak == false {
                                istrct.instruction = "#"
                                k=0; for k < len(uses), k++ {
                                    argToReplace asmSymbol*
                                    if this.isSameArg(&istrct.arg2, &uses[k].arg1) {
                                        argToReplace = &uses[k].arg1
                                    } else if this.isSameArg(&istrct.arg2, &uses[k].arg2) {
                                        argToReplace = &uses[k].arg2
                                    } else {
                                        println("warning: weird optimizer behavior")
                                        continue
                                    }
                                    *argToReplace = istrct.arg1
                                }
                            }
                            break
                        }

                        istrct.instruction = "#"
                        if this.isSameArg(&istrct.arg1, &agnst.arg2) {
                            agnst.instruction = "#"
                            break
                        }

                        agnst.arg1 = istrct.arg1

                        break
                    }
                }
                
                if isTmp && strHasPrefix(agnst.instruction, ".loc") {
                    break
                }

                if agnst.instruction == "call" || agnst.instruction == "ret" || agnst.instruction[0] == 'j' {
                    break
                }

                if strHasPrefix(agnst.instruction, ".FOR_LOOP_START_") {
                    break
                }

                if isEmptySymbol(&agnst.arg2) == false && (this.isSet(&istrct.arg1, j) || this.isSet(&istrct.arg2, j)) {
                    break
                }

            }

        }
    }
    
    generateSymFromTmp(sym asmSymbol, i uint, regIndex uint) [uint, uint] {
        lastUse = 0
        j=regIndex; for j > 1, j-- {
            reg = asmSymbolReg(ASM_reg_id_op, sym.size, j)
            regNotBreaking = true
            k=i; for k < len(this.instructions), k++ {
                if this.instructions[k].instruction[0] == '#' {
                    continue
                }

                if strHasPrefix(this.instructions[k].instruction, ".loc") {
                    break
                }

                if this.instructions[k].instruction == "mulsd" && (this.instructions[k].arg1.isTmp && this.instructions[k].arg1.address == sym.address || this.instructions[k].arg2.isTmp && this.instructions[k].arg2.address == sym.address) {
                    regNotBreaking = false
                    break
                }

                if this.instructions[k].arg1.isReg && this.instructions[k].arg1.address == reg.address || this.instructions[k].arg2.isReg && this.instructions[k].arg2.address == reg.address {
                    regNotBreaking = false
                    break
                }

                if this.instructions[k].instruction == "call" {
                    regNotBreaking = false
                    break
                }

                if this.instructions[k].instruction == "leaq" && this.isSameArg(&this.instructions[k].arg1, &sym) {
                    regNotBreaking = false
                    break
                }
            }

            if regNotBreaking {
                for i < len(this.instructions), i++ {
                    if this.instructions[i].instruction[0] == '#' {
                        continue
                    }

                    if strHasPrefix(this.instructions[i].instruction, ".loc") {
                        break
                    }

                    if this.instructions[i].arg1.isTmp && this.instructions[i].arg1.address == sym.address {
                        this.instructions[i].arg1 = reg
                        lastUse = i
                    }

                    if this.instructions[i].arg2.isTmp && this.instructions[i].arg2.address == sym.address {
                        this.instructions[i].arg2 = reg
                        lastUse = i
                    }
                }
                return [j - 1, lastUse]
            }
        }

        alignment = 1
        if sym.size == 4 {
            alignment = 8
        } if sym.size >= 8 {
            alignment = 16
        }

        addr = this.stackOffset + sym.size

        if addr % alignment != 0 {
            addr += (alignment - addr % alignment)
        }

        this.stackOffset = addr

        for i < len(this.instructions), i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if strHasPrefix(this.instructions[i].instruction, ".loc") {
                break
            }

            if this.instructions[i].arg1.isTmp && this.instructions[i].arg1.address == sym.address {
                this.instructions[i].arg1.isTmp = false
                this.instructions[i].arg1.address = addr
            }

            if this.instructions[i].arg2.isTmp && this.instructions[i].arg2.address == sym.address {
                this.instructions[i].arg2.isTmp = false
                this.instructions[i].arg2.address = addr
            }
        }

        return [regIndex, 0]
    }

    flushInstructions() rope* {
        r = rope("")
        if this.maxStackOffset > this.stackOffset {
            this.stackOffset = this.maxStackOffset
        }

        if this.enableOptimizations {
            this.optimizeInstructions()
        }
        
        //generating tmp symbols
        stackOffsetBeforeTmp = this.stackOffset
        maxStackOffset = this.stackOffset
        currRegIndex = 5
        lastUse = 0
        i=this.startIndex; for i < len(this.instructions), i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if strHasPrefix(this.instructions[i].instruction, ".loc") {
                currRegIndex = 5
                if this.stackOffset > maxStackOffset {
                    maxStackOffset = this.stackOffset
                }
                lastUse = 0
                this.stackOffset = stackOffsetBeforeTmp
            } else if lastUse != 0 && i >= lastUse {
                currRegIndex++
                lastUse = 0
            }

            if this.instructions[i].arg2.isTmp {
                res = this.generateSymFromTmp(this.instructions[i].arg2, i, currRegIndex)
                currRegIndex = res[0]
                lastUse = res[1]
            }
        }

        if maxStackOffset > this.stackOffset {
            this.stackOffset = maxStackOffset
        }

        if this.enableOptimizations {
            i = this.startIndex; for i < len(this.instructions), i++ {
                if this.instructions[i].instruction == "#" {
                    continue
                }

                if this.instructions[i].arg2.stack || this.instructions[i].arg1.stack {
                    break
                }

                if this.instructions[i].instruction == "pushq" {
                    break
                }
            }

            //trim unnecessary stackframe 
            //WARNING: that will skip functions in the backtrace...
            if i == len(this.instructions) {
                this.stackOffset = 0
                this.instructions[this.startIndex-2].instruction = "#"
                this.instructions[this.startIndex-1].instruction = "#"
            }
        }


        i=0; for i < len(this.instructions), i++ {
            istrct = this.instructions[i]

            if istrct.instruction[0] == '#' {
                continue
            }

            if istrct.instruction == "SET_STACK_POINTER" {
                if this.stackOffset == 0 {
                    continue
                }
                if this.stackOffset % 16 != 0 {
                    this.stackOffset += 16 - (this.stackOffset % 16)
                }

                istrct.instruction = "subq"
                istrct.arg1 = asmSymbolValue("$"+uintToStr(this.stackOffset))
                istrct.arg2 = asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0)
            } else if istrct.instruction == "leave" {
                if this.stackOffset == 0 {
                    if this.instructions[this.startIndex-3].instruction[0] == '#' {
                        continue
                    } else {
                        istrct = asmInstruction {
                            "popq", asmSymbolReg(ASM_reg_id_base_pointer, 8, 0)
                        }
                    }
                }
            } else if strHasPrefix(istrct.instruction, "mov") && istrct.arg1.isFloat && istrct.arg1.isReg && istrct.arg1.address >= ASM_reg_id_floats {
                if istrct.arg1.isReg && istrct.arg1.address >= ASM_reg_id_floats && istrct.arg2.isReg && istrct.arg2.level == 0 && istrct.arg2.address < ASM_reg_id_floats {
                    istrct.instruction = "movq"
                    istrct.arg2.size = 8
                } else {
                    if istrct.arg2.isFloat && istrct.arg2.isReg && istrct.arg2.address >= ASM_reg_id_floats {
                        istrct.instruction = ASM_vector_mov
                    } else if istrct.instruction == "movq" {
                        istrct.instruction = ASM_mov_float[spos(8)]
                    } else if istrct.instruction == "movl" {
                        istrct.instruction = "movss"
                    }
                }
            } else if istrct.instruction == "call" && istrct.arg1.isValue == false {
                istrct.arg1 = asmSymbolValue("*"+istrct.arg1.toStr())
            }


            r += rope(istrct.toStr()+"\n")
        }
        clear(this.instructions)
        this.code += r
        return r
    }

    setToJump(inst str) str {
        r = ""
        if inst == "sete" {
            r = "jne"
        } else if inst == "setne" {
            r = "je"
        } else if inst == "setg" {
            r = "jle"
        } else if inst == "setl" {
            r = "jge"
        } else if inst == "setge" {
            r = "jl"
        } else if inst == "setle" {
            r = "jg"
        } else if inst == "setnb" {
            r = "jb"
        } else if inst == "setb" {
            r = "jnb"
        } else if inst == "setna" {
            r = "ja"
        } else if inst == "seta" {
            r = "jna"
        }
        return r
    }

    inverseJump(inst str) str {
        r = ""
        if inst == "je" {
            r = "jne"
        } else if inst == "jne" {
            r = "je"
        } else if inst == "jg" {
            r = "jle"
        } else if inst == "jl" {
            r = "jge"
        } else if inst == "jge" {
            r = "jl"
        } else if inst == "jle" {
            r = "jg"
        } else if inst == "jnb" {
            r = "jb"
        } else if inst == "jb" {
            r = "jnb"
        } else if inst == "jna" {
            r = "ja"
        } else if inst == "ja" {
            r = "jna"
        }
        return r
    }

    fileNb: uint = 0
    totalFileNb: uint = 0
    currentLine: uint
    lastFile: uint

    generateFileLocation(fileName str) {
        this.instructions[len(this.instructions)] = asmInstruction {
            ".file "+uintToStr(this.totalFileNb)+" \""+fileName+"\""
        }

        if this.debugEnabled == false {
            this.totalFileNb++
            this.fileNb = this.totalFileNb
            return
        }

        this.debugInfo += rope(".byte 1\n.int "+uintToStr(this.totalFileNb)+"\n.int "+uintToStr(len(fileName))+"\n.asciz \""+fileName+"\"\n")

        this.totalFileNb++
        this.fileNb = this.totalFileNb
    }

    generateLineLocation(line uint) {
        if this.debugEnabled == false {
            this.instructions[len(this.instructions)] = asmInstruction {
                ".loc "+uintToStr(this.fileNb-1)+" "+uintToStr(line)
            }
            this.currentLine = line
            this.lastFile = this.fileNb
            return
        }

        if this.currentLine == line && this.lastFile == this.fileNb  {
            return
        }


        index = len(this.instructions)
        labelName = ".loc_"+uintToStr(this.fileNb-1)+"_"+uintToStr(line)

        this.debugInfo += rope(".byte 2\n.quad "+labelName+"\n.int "+uintToStr(this.fileNb-1)+"\n.int "+uintToStr(line)+"\n")

        this.instructions[index] = asmInstruction {
            labelName+":"
        }

        this.currentLine = line
        this.lastFile = this.fileNb

    }

    resetRegisters() {
        this.regIndex = 0
    }

    generateMoveValue(sym asmSymbol, dest asmSymbol) {
        if sym.isReg == false && sym.level == -1 && sym.size <= 8 {
            if sym.isReg {
                printDebugContext()
                panic("what the hell: cannot leaq register")
            }
            if dest.isReg && dest.level == 0 {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "leaq", sym, dest
                }
                return
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "leaq", sym, asmSymbolReg(ASM_reg_id_return, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", asmSymbolReg(ASM_reg_id_return, 8, 0), dest
            }
            return
        }
        if sym.size > 8 {
            incrSize = 32
            if GEN_AVXenabled == false {
                incrSize = 16
            }
            offset = 0
            lastIncr = 0
            regnNB = 0

            if sym.isReg && sym.level == 0 && sym.size == 16 {
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_vector_mov, sym, dest
                }
                return
            }

            if sym.isReg == false && sym.stack == false {
                tmpsym = sym
                tmpsym.size = 8
                tmpsym.level = -1
                srcReg = asmSymbolReg(ASM_reg_id_return, 8, 0)
                this.generateMoveValue(tmpsym, srcReg)
                srcReg.level = 1
                srcReg.size = sym.size
                sym = srcReg
            }

            if dest.size > 8 && dest.isReg == false && dest.stack == false && dest.isValue == false {
                destReg = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex+1)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "leaq", dest, destReg
                }
                dest = destReg
                dest.level = 1
            }

            if sym.level == 1 {
                srcReg = asmSymbolReg(ASM_reg_id_return, 8, 0)
                tmpsym = sym
                tmpsym.level = 0
                tmpsym.size = 8
                this.generateMoveValue(tmpsym, srcReg)
                srcRegAddr = srcReg
                srcReg.level = sym.level

                for offset < sym.size, offset += incrSize {
                    for (sym.size - offset) < incrSize {
                        incrSize = incrSize / 2
                    }
                    if incrSize == 0 {
                        break
                    }
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "addq", asmSymbolValue("$"+uintToStr(lastIncr)), srcRegAddr
                    }
                    destReg asmSymbol
                    trsfrReg asmSymbol

                    if dest.stack && dest.isTmp == false {
                        destReg = asmSymbolStack(dest.address - offset, incrSize)
                    } else {
                        if dest.level <= 0 {
                            printDebugContext()
                            panic("what the hell: "+toJson(dest))
                        }
                        destReg = dest
                        destReg.level = 0
                        destReg.size = 8
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "addq", asmSymbolValue("$"+uintToStr(lastIncr)), destReg
                        }
                        destReg.level = dest.level
                    }

                    inst = ASM_vector_mov
                    if incrSize <= 2 {
                        inst = ASM_mov[spos(incrSize)]
                        trsfrReg = asmSymbolReg(ASM_reg_id_op, incrSize, this.regIndex)                    
                    } else {
                        if incrSize <= 8 {
                            inst = ASM_mov_float[spos(incrSize)]
                        }
                        if incrSize == 32 {
                            trsfrReg = asmSymbolReg(ASM_reg_id_ymm, incrSize, regnNB+1)                    
                        } else {
                            trsfrReg = asmSymbolReg(ASM_reg_id_floats, incrSize, regnNB)
                        }
                        regnNB = (regnNB + 1) % 8
                    }

                    this.instructions[len(this.instructions)] = asmInstruction {
                        inst, srcReg, trsfrReg
                    }

                    this.instructions[len(this.instructions)] = asmInstruction {
                        inst, trsfrReg, destReg
                    }
                    lastIncr = incrSize
                }   
                return
            }

            for offset < sym.size, offset += incrSize {
                for (sym.size - offset) < incrSize {
                    incrSize = incrSize / 2
                }
                if incrSize == 0 {
                    break
                }
                srcReg = asmSymbolStack(sym.address - offset, incrSize)
                destReg asmSymbol
                trsfrReg asmSymbol

                if dest.stack && dest.isTmp == false {
                    destReg = asmSymbolStack(dest.address - offset, incrSize)
                } else {
                    if dest.level <= 0 {
                        printDebugContext()
                        panic("what the hell")
                    }
                    destReg = dest
                    destReg.level = 0
                    destReg.size = 8
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "addq", asmSymbolValue("$"+uintToStr(lastIncr)), destReg
                    }
                    destReg.level = dest.level
                }


                inst = ASM_vector_mov
                if incrSize <= 2 {
                    inst = ASM_mov[spos(incrSize)]
                    trsfrReg = asmSymbolReg(ASM_reg_id_op, incrSize, this.regIndex)                    
                } else {
                    if incrSize <= 8 {
                        inst = ASM_mov_float[spos(incrSize)]
                    }
                    if incrSize == 32 {
                        trsfrReg = asmSymbolReg(ASM_reg_id_ymm, incrSize, regnNB+1)                    
                    } else {
                        trsfrReg = asmSymbolReg(ASM_reg_id_floats, incrSize, regnNB)
                    }
                    regnNB = (regnNB + 1) % 8
                } 


                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, srcReg, trsfrReg
                }

                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, trsfrReg, destReg
                }
                lastIncr = incrSize
            }
            return
        }

        from = sym
        level = sym.level
        if level > 0 {
            oDest = asmSymbol{}
            if dest.isReg == false {
                oDest = dest
                dest = asmSymbolReg(ASM_reg_id_return, 8, 0)
            }
            if from.isReg == false {
                tmpSym = from
                tmpSym.level = 0
                tmpSym.size = 8
                this.generateMoveValue(tmpSym, asmSymbolReg(ASM_reg_id_return, 8, 0))
                retDest = asmSymbolReg(ASM_reg_id_return, 8, 0)
                retDest.level = from.level
                from = retDest
            }

            for level > 1, level-- {
                from.level = 1
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", from, dest
                }
                from = dest
            }

            if isEmptySymbol(&oDest) == false {
                dest.size = oDest.size
            }
            
            if level == 1 {
                from.level = 1
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_mov[spos(dest.size)], from, dest
                }
            }
            if isEmptySymbol(&oDest) == false {
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_mov[spos(dest.size)], dest, oDest
                }
            }
            return
        }

        if dest.isReg == false && (sym.isValue == false && sym.isReg == false) {
            tmpReg = asmSymbolReg(ASM_reg_id_op, sym.size, this.regIndex)
            this.generateMoveValue(sym, tmpReg)
            from = tmpReg
        }

        inst = ASM_mov[spos(sym.size)]
        if dest.isReg && dest.address >= ASM_reg_id_floats && from.stack && sym.size == 4 {
            inst = "movd"
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            inst, from, dest
        }
    }

    generateStackAlloc(value asmSymbol) int {       
        alignment = 1
        if value.size == 4 {
            alignment = 8
        } if value.size >= 8 {
            alignment = 16
        }

        addr = this.stackOffset + value.size

        if addr % alignment != 0 {
            addr += (alignment - addr % alignment)
        }

        this.stackOffset = addr

        so = this.stackOffset
        this.generateMoveValue(value, asmSymbolStack(so, value.size))

        return so
    }

    generateTmpSym(value asmSymbol, size uint) asmSymbol {
        if value.level == 0 && (value.stack || value.isValue) {
            return value
        }

        if size > 8 {
            return asmSymbolStack(this.generateStackAlloc(value), value.size)
        }

        r = asmSymbolTmp(size)

        this.generateMoveValue(value, r)
        return r
    }

    generatePrefetch(addr asmSymbol) {
        if addr.stack == false && addr.level <= 0 {
            printDebugContext()
            panic("Invalid prefetch.")
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "prefetchnta", addr
        }
    }

    generateUnary(sym asmSymbol) asmSymbol {
        if sym.level == -1 {
            sym.level = 0
            return sym
        }
        addrReg = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex+1)
        ogSize = sym.size
        
        sym.size = 8
        this.generateMoveValue(sym, addrReg)

        sym.size = ogSize
        addrReg.level = 1
        if sym.size > 8 {
            addrReg.size = sym.size
            ns = asmSymbolStack(this.generateStackAlloc(addrReg), sym.size)
            return ns
        }

        return this.generateTmpSym(addrReg, ogSize)
    }

    generateDereference(sym asmSymbol) asmSymbol {
        if sym.isReg == false {
            oSize = sym.size
            sym.size = 8
            addrReg = asmSymbolReg(ASM_reg_id_return, sym.size, 0)

            this.generateMoveValue(sym, addrReg)

            addrReg.level = 1
            addrReg.size = oSize

            return addrReg
        }

        sym.level++
        return sym
    }

    generateDestDereference(sym asmSymbol) asmSymbol {
        if sym.isReg == false {
            oSize = sym.size
            sym.size = 8
            addrReg = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
            this.generateMoveValue(sym, addrReg)

            addrReg.level = 1
            addrReg.size = oSize

            return addrReg
        }

        sym.level++

        return sym
    }

    generateStaticStr(s str, length uint) asmSymbol {
        name = ""

        i=0; for i < len(this.strings), i++ {
            if this.strings[i].string == s {
                name = this.strings[i].symbolName
                break
            }
        }

        if i == len(this.strings) {
            name = ".VAR_"+uintToStr(asmRandId)
            this.staticData += rope(name+":\n.int "+uintToStr(length)+"\n.asciz "+s+"\n")
            this.strings[len(this.strings)] = asmStrLookup {
                string: s
                symbolName: name
            }
        }

        r = asmSymbol {
            name: name
            size: 8
            level: -1
            active: true
        }
        asmRandId++
        return r
    }

    staticInt(v str) asmSymbol {
        r = asmSymbol {
            name: "$"+intToStr(tokToInt(v))
            size: 8
            isValue: true
            active: true
        }

        return r
    }

    staticFloat32(v str) asmSymbol {
        f = <float32>strToFloat(v)
        u = *(<int32*>&f)

        name = ".FLOAT32_"+uintToStr(asmRandId)
        this.data += rope(name+":\n.long "+uintToStr(u)+"\n")
        asmRandId++

        r = asmSymbolStaticName(name)
        r.size = 4
        r.isFloat = true
        return r
    }

    staticFloat64(v str) asmSymbol {
        f = strToFloat(v)
        u = *(<int*>&f)

        partA = <int32>u
        partB = <int32>(u >> 32)

        name = ".FLOAT_"+uintToStr(asmRandId)
        this.data += rope(name+":\n.long "+intToStr(partA)+"\n.long "+intToStr(partB)+"\n")
        asmRandId++

        r = asmSymbolStaticName(name)
        r.isFloat = true
        r.size = 8
        return r
    }


    generateConvSizes(sym asmSymbol, to uint, isUnsigned bool) asmSymbol {
        if sym.size == to {
            return sym
        }

        if sym.isFloat {
            dest = asmSymbolReg(ASM_reg_id_floats, 8, 0)
            if sym.isReg && sym.level == 0 {
                dest = sym
            } else {
                this.generateMoveValue(sym, dest)
                sym = dest
            }
            if to == 4 {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "cvtsd2ss", sym, dest
                }
            } else {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "cvtss2sd", sym, dest
                }
            }

            dest.size = to
            dest.isFloat = true
            return dest
        }

        if sym.isValue {
            sym.size = to
            return sym
        }

        if sym.size > 8 || to > 8 {
            printDebugContext()
            panic("invalid size conversion: "+uintToStr(sym.size)+" -> "+uintToStr(to))
        }

        opReg = asmSymbolReg(ASM_reg_id_return, sym.size, 0)

        if sym.isReg {
            opReg.address = sym.address
        }

        if sym.size < 4 {
            insts = ["movsbl", "movswl"]
            if isUnsigned {
                insts[0] = "movzbl"
                insts[1] = "movzwl"
            }
            if to == 8 {
                insts = ["movsbq", "movswq"]
                if isUnsigned {
                    insts[0] = "movzbq"
                    insts[1] = "movzwq"
                }
                opReg.size = 8
            } else {
                opReg.size = 4
            }
            if sym.size == 1 {
                this.instructions[len(this.instructions)] = asmInstruction {
                    insts[0], sym, opReg
                }
            } else if sym.size == 2 {
                this.instructions[len(this.instructions)] = asmInstruction {
                    insts[1], sym, opReg
                }
            }
        } else if sym.isReg == false {
            this.generateMoveValue(sym, opReg)
        } else {
            opReg = sym
        }

        opReg.size = to
        return opReg
    }

    generateCompare(a asmSymbol, b asmSymbol, op uint, isUnsigned bool) asmSymbol {
        // this.convertRegister(&a, &b)

        ogB = b
        operStart = len(this.instructions)

        if isUnsigned == false || (op != ASM_OP_GREATER && op != ASM_OP_LESS_OR_EQ) {
            c = a
            a = b
            b = c

            if a.isFloat == false && b.isFloat == false && b.isReg == false {
                if a.isReg && a.level == 0 {
                    if op == ASM_OP_LESS {
                        op = ASM_OP_GREATER
                    } else if op == ASM_OP_LESS_OR_EQ {
                        op = ASM_OP_GREATER_OR_EQ
                    } else if op == ASM_OP_GREATER {
                        op = ASM_OP_LESS
                    } else if op == ASM_OP_GREATER_OR_EQ {
                        op = ASM_OP_LESS_OR_EQ
                    }
                    return this.generateCompare(a, b, op, isUnsigned)
                }
                tmpReg = asmSymbolReg(ASM_reg_id_op, b.size, this.regIndex+1)
                this.generateMoveValue(b, tmpReg)
                b = tmpReg
            }
        } else if a.isReg == false {
            tmpReg = asmSymbolReg(ASM_reg_id_return, b.size, 0)

            //further .generateConvSizes() could set a to %rax, in that case, a and b are moved into %rax
            if b.size > a.size || this.isSameArg(&tmpReg, &a) {
                tmpReg.address = ASM_reg_id_op + this.regIndex+1
            }
            this.generateMoveValue(b, tmpReg)
            b = tmpReg
        }

        if a.isReg == false && a.level == 1 {
            if ogB.level != 0 {
                this.regIndex++
            }
            tmpReg = asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)
            this.generateMoveValue(a, tmpReg)
            if ogB.level != 0 {
                this.regIndex--
            }
            a = tmpReg
        }

        if a.size > b.size && b.isValue == false {
            b = this.generateConvSizes(b, a.size, isUnsigned)
        } else if b.size > a.size && a.isValue == false {
            a = this.generateConvSizes(a, b.size, isUnsigned)
        }

        ret = asmSymbolReg(ASM_reg_id_return, 1, 0)

        if a.isFloat || b.isFloat {
            if a.isReg == false || a.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, 8, 0)
                if b.isReg && b.address >= ASM_reg_id_floats {
                    r.address += (b.address + 1 - ASM_reg_id_floats) % 16
                }
                this.generateMoveValue(a, r)
                a = r
            }

            if b.isReg == false || b.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, 8, (a.address + 1 - ASM_reg_id_floats) % 16)
                this.generateMoveValue(b, r)
                b = r
            }

            if op == ASM_OP_EQ || op == ASM_OP_NOT_EQ {
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_unordered_cmp_float[spos(a.size)], a, b
                }

                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_set_parity[op], ret
                }

                flip = this.staticInt("0")
                if op == ASM_OP_NOT_EQ {
                    flip = this.staticInt("1")
                }

                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_mov[spos(4)], flip, asmSymbolReg(ASM_reg_id_op, 4, 1)
                }

                ret.size = 4
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_cond_mov_not_eq, asmSymbolReg(ASM_reg_id_op, 4, 1), ret
                }
                ret.size = 1
            } else {
                if op == ASM_OP_LESS || op == ASM_OP_LESS_OR_EQ {
                    c = a
                    a = b
                    b = c
                }

                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_cmp_float[spos(a.size)], a, b
                }
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_set_above_below_floats[op], ret
                }
            }

        } else if isUnsigned {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_cmp[spos(a.size)], a, b
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_set_above_below_unsgined[op], ret
            }


        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_cmp[spos(a.size)], a, b
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_set[op], ret
            }
        }


        r = this.generateTmpSym(ret, 1)
        r.operStart = operStart

        return r
    }

    generateBoolOrStart() {
        operStart = len(this.instructions)
        jumpSym = ".BOOL_OR_" + uintToStr(asmRandId)
        asmRandId++

        this.endSym.insert(<ptr>operStart)
        this.endSym.insert(jumpSym)
    }

    generateBoolOr(cond asmSymbol) {
        operStart = <uint>this.endSym.end.prev.data
        jumpSym = <str>this.endSym.end.data

        if cond.operStart != -1 {
            setOpIndex = len(this.instructions)-1
            for setOpIndex > cond.operStart, setOpIndex-- {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            this.instructions[setOpIndex].instruction = "j" + this.instructions[setOpIndex].instruction[3:]
            this.instructions[setOpIndex].arg1 = asmSymbolValue(jumpSym)
            this.instructions[setOpIndex+1].instruction = "#"
        } else {
            if cond.level != 0 && cond.isReg == false {
                condReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
                this.generateMoveValue(cond, condReg)
                cond = condReg
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$1"), cond
            }
            if cond.isReg && cond.address == ASM_reg_id_return {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "je", asmSymbolValue(jumpSym+"_END")
                }
            } else {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "je", asmSymbolValue(jumpSym)
                }
            }
        }
    }

    generateBoolOrEnd(cond asmSymbol) asmSymbol {
        jumpSym = <str>this.endSym.pop()
        operStart = <uint>this.endSym.pop()

        if cond.operStart != -1 {
            setOpIndex = len(this.instructions)-1
            for setOpIndex > cond.operStart, setOpIndex-- {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            this.instructions[setOpIndex].instruction = this.setToJump(this.instructions[setOpIndex].instruction)

            this.instructions[setOpIndex].arg1.name = jumpSym+"_NOT"
            this.instructions[setOpIndex].arg1.isValue = true
            this.instructions[setOpIndex+1].instruction = "#"
        } else {

            if cond.level != 0 && cond.isReg == false {
                condReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
                this.generateMoveValue(cond, condReg)
                cond = condReg
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$1"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "jne", asmSymbolValue(jumpSym+"_NOT")
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+":"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$1"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(jumpSym+"_END")
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+"_NOT:"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$0"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+"_END:"
        }

        return asmSymbolReg(ASM_reg_id_return, 1, 0)
    }

    generateBoolAndStart() {
        operStart = len(this.instructions)
        jumpSym = ".BOOL_AND_" + uintToStr(asmRandId)
        asmRandId++

        this.endSym.insert(<ptr>operStart)
        this.endSym.insert(jumpSym)
    }

    generateBoolAnd(cond asmSymbol) {
        operStart = <uint>this.endSym.end.prev.data
        jumpSym = <str>this.endSym.end.data

        if cond.operStart != -1 {
            setOpIndex = len(this.instructions)-1
            for setOpIndex > cond.operStart, setOpIndex-- {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            this.instructions[setOpIndex].instruction = this.setToJump(this.instructions[setOpIndex].instruction)

            this.instructions[setOpIndex].arg1 = asmSymbolValue(jumpSym)
            this.instructions[setOpIndex+1].instruction = "#"
        } else {

            if cond.level != 0 && cond.isReg == false {
                condReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
                this.generateMoveValue(cond, condReg)
                cond = condReg
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$0"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "je", asmSymbolValue(jumpSym)
            }
        }
    }

    generateBoolAndEnd(cond asmSymbol) asmSymbol {
        jumpSym = <str>this.endSym.pop()
        operStart = <uint>this.endSym.pop()

        if cond.operStart != -1 {
            setOpIndex = len(this.instructions)-1
            for setOpIndex > cond.operStart, setOpIndex-- {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            this.instructions[setOpIndex].instruction = this.setToJump(this.instructions[setOpIndex].instruction)

            this.instructions[setOpIndex].arg1 = asmSymbolValue(jumpSym)
            this.instructions[setOpIndex+1].instruction = "#"
        } else {

            if cond.level != 0 && cond.isReg == false {
                condReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
                this.generateMoveValue(cond, condReg)
                cond = condReg
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$0"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "je", asmSymbolValue(jumpSym)
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$1"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(jumpSym+"_END")
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+":"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$0"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+"_END:"
        }

        return asmSymbolReg(ASM_reg_id_return, 1, 0)
    }

    generateStrConcatBegin() {
        this.endSym.insert(<ptr>len(this.instructions))
        syms = []asmSymbol
        this.endSym.insert(syms)
    }

    generateStrConcat(sym asmSymbol) {
        syms = <[]asmSymbol>this.endSym.end.data

        if sym.stack == false || sym.level != 0 {
            sym = this.generateTmpSym(sym, sym.size)
        }

        syms[len(syms)] = sym
    }

    generateStrConcatEnd() asmSymbol {
        syms = <[]asmSymbol>this.endSym.pop()
        operStart = <uint>this.endSym.pop()

        if len(syms) == 1 {
            return syms[0]
        }        

        this.instructions[len(this.instructions)] = asmInstruction {
            "movl", asmSymbolValue("$5"), asmSymbolReg(ASM_reg_id_args, 4, 0)
        }

        i=0; for i < len(syms), i++ {
            sym = syms[i]

            tmpOp = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex)

            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", sym, tmpOp
            }

            tmpOp.level = 1
            this.instructions[len(this.instructions)] = asmInstruction {
                "addl", tmpOp, asmSymbolReg(ASM_reg_id_args, 4, 0)
            }


        }

        sizeSym = this.generateTmpSym(asmSymbolReg(ASM_reg_id_args, 8, 0), 8)

        this.instructions[len(this.instructions)] = asmInstruction {
            "call", asmSymbolValue(memoryAllocFunctionSTR_NZ)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "subq", asmSymbolValue("$5"), sizeSym
        }

        tmpRet = asmSymbolReg(ASM_reg_id_return, 8, 0)
        tmpRet.level = 1
        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", sizeSym, asmSymbolReg(ASM_reg_id_args, 8, 0)
        }
        
        this.instructions[len(this.instructions)] = asmInstruction {
            "movl", asmSymbolReg(ASM_reg_id_args, 4, 0), tmpRet
        }

        tmpRet.level = 0
        retSym = asmSymbolReg(ASM_reg_id_args, 8, 3)

        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", tmpRet, retSym
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "addq", asmSymbolValue("$4"), tmpRet
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", tmpRet, asmSymbolReg(ASM_reg_id_args, 8, 0)
        }

        i=0; for i < len(syms), i++ {
            sym = syms[i]
            tmpArg1 = asmSymbolReg(ASM_reg_id_args, 8, 1)
            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", sym, tmpArg1
            }

            tmpArg1.level = 1
            this.instructions[len(this.instructions)] = asmInstruction {
                "movl", tmpArg1, asmSymbolReg(ASM_reg_id_args, 4, 2)
            }
            tmpArg1.level = 0
            this.instructions[len(this.instructions)] = asmInstruction {
                "addq", asmSymbolValue("$4"), tmpArg1
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "call", asmSymbolValue("persistentmcpy")
            }
        }

        return retSym
    }

    generateFor() {
        this.scope++
        forLoopStartSym = ".FOR_LOOP_START_"+uintToStr(asmRandId)
        this.endSym.insert(<ptr>this.stackOffset)
        this.endSym.insert(<ptr>(len(this.instructions)))
        this.endSym.insert(forLoopStartSym)
        this.forStack.insert(<ptr>asmRandId)
        this.endSym.insert(<ptr>asmRandId)
        asmRandId++

        this.instructions[len(this.instructions)] = asmInstruction {
            "#opti_placeholder"
        }
        
        this.instructions[len(this.instructions)] = asmInstruction {
            forLoopStartSym+":"
        }
    }

    generateForCond(cond asmSymbol, optimizedIndex int) {
        idNb = <uint>this.endSym.pop()
        forLoopStartSym = <str>this.endSym.pop()

        forNotSym = ".FOR_NOT_"+uintToStr(idNb)
        this.endSym.insert(forNotSym)

        this.endSym.insert(forLoopStartSym)

        this.forStack.insert(<ptr>optimizedIndex)
        if optimizedIndex != -1 {
            delete(this.instructions, optimizedIndex)
        }

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        } else {
            if this.instructions[len(this.instructions)-1].instruction == "movb" && this.isSameArg(&cond, &this.instructions[len(this.instructions)-1].arg2) {
                al = this.instructions[len(this.instructions)-1].arg1
                setInd = len(this.instructions)-2
                if this.isSameArg(&this.instructions[setInd].arg1, &al) {
                    jmpInst = this.setToJump(this.instructions[setInd].instruction)
                    if len(jmpInst) > 0 {
                        this.instructions[setInd].instruction = jmpInst
                        this.instructions[setInd].arg1 = asmSymbolValue(forNotSym)
                        this.instructions[setInd+1].instruction = "#"
                        if optimizedIndex != -1 {
                            this.instructions[len(this.instructions)] = asmInstruction {
                                forLoopStartSym+":"
                            }
                        }
                        this.endSym.insert(<ptr>len(this.instructions))
                        return
                    }
                }


            }
        }

        if cond.isValue && cond.name[0] == '$' {
            if cond.name == "$0" {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "jmp", asmSymbolValue(forNotSym)
                }
            }
        } else {
            if cond.size != 1 {
                cond = this.generateConvSizes(cond, 1, true)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                "je", asmSymbolValue(forNotSym)
            }
        }

        if optimizedIndex != -1 {
            this.instructions[len(this.instructions)] = asmInstruction {
                forLoopStartSym+":"
            }
        }


        this.endSym.insert(<ptr>len(this.instructions))
    }

    generateForIncr() {
        lastIndex = this.endSym.pop()

        incrIstrcts = this.instructions[lastIndex:]
        arrayDuplicate(incrIstrcts)
        
        rArr = <Bah_Array_Type*>(this.instructions)
        rArr.length = len(this.instructions) - len(incrIstrcts)

        this.endSym.insert(incrIstrcts)
        this.forStack.insert(incrIstrcts)

    }

    generateForOptimizedCond(cond asmSymbol) {
        forLoopStartSym = <str>this.endSym.end.prev.data

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        } else {
            if this.instructions[len(this.instructions)-1].instruction == "movb" && this.isSameArg(&cond, &this.instructions[len(this.instructions)-1].arg2) {
                al = this.instructions[len(this.instructions)-1].arg1
                setInd = len(this.instructions)-2
                if this.isSameArg(&this.instructions[setInd].arg1, &al) {
                    if strHasPrefix(this.instructions[setInd].instruction, "set") {
                        this.instructions[setInd].instruction = "j" + this.instructions[setInd].instruction[3:]
                        this.instructions[setInd].arg1 = asmSymbolValue(forLoopStartSym)
                        this.instructions[setInd+1].instruction = "#"
                        return
                    }
                }
            }
        }

        if cond.isValue && cond.name[0] == '$' {
            if cond.name == "$1" {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "jmp", asmSymbolValue(forLoopStartSym)
                }
            }
        } else {
            if cond.size != 1 {
                cond = this.generateConvSizes(cond, 1, true)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                "jne", asmSymbolValue(forLoopStartSym)
            }
        }


        // this.endSym.insert(<ptr>len(this.instructions))
    }

    generateForEnd(optimized bool) {
        incrInstructs = <[]asmInstruction>this.endSym.pop()
        loopStart = <str>this.endSym.pop()
        loopNot = <str>this.endSym.pop()

        this.forStack.pop()
        this.forStack.pop()
        this.forStack.pop()

        loopStartIndex = <uint>this.endSym.pop()

        i=0; for i < len(incrInstructs), i++ {
            this.instructions[len(this.instructions)] = incrInstructs[i]
        }

        // currSym asmSymbol*
        // lastCurrSym asmSymbol*
        // uses = [0,0]
        // const regNB = 8
        // if this.enableOptimizations && len(this.instructions) - loopStartIndex >= 100 {
        //     i=loopStartIndex; for i < len(this.instructions), i++ {
        //         if this.instructions[i].instruction == "ret" {
        //             currSym = null
        //             break
        //         }

        //         if this.instructions[i].arg1.isReg && this.instructions[i].arg1.address == ASM_reg_id_op + regNB || this.instructions[i].arg2.isReg && this.instructions[i].arg2.address == ASM_reg_id_op + regNB {
        //             currSym = null
        //             break
        //         }

        //         if this.instructions[i].instruction[0] == 'm' && this.instructions[i].arg2.stack && this.instructions[i].arg2.size <= 8 && this.instructions[i].arg2.isTmp == false {
        //             j=i-1; for j > this.startIndex, j-- {
        //                 if this.instructions[j].arg2.stack && this.isSameArg(this.instructions[i].arg2, this.instructions[j].arg2) {
        //                     break
        //                 }

        //                 if this.instructions[j].arg1.stack && this.isSameArg(this.instructions[i].arg2, this.instructions[j].arg1) {
        //                     break
        //                 }
        //             }

        //             if j != this.startIndex {
        //                 continue
        //             }

        //             lastCurrSym = currSym
        //             uses[1] = uses[0]
        //             uses[0] = 0
        //             currSym = &this.instructions[i].arg2



        //             j=i+1; for j < len(this.instructions), j++ {

        //                 if this.instructions[j].arg1.stack && this.instructions[j].arg1.isTmp == false && this.instructions[j].arg1.address == currSym.address {
        //                     if this.instructions[j].arg2.isReg && this.instructions[j].arg2.address >= ASM_reg_id_floats || this.instructions[j].instruction == "leaq" || this.instructions[j].arg1.size != currSym.size {
        //                         uses[0] = 0
        //                         break
        //                     }

        //                     uses[0]++
        //                     continue
        //                 }

        //                 if this.instructions[j].arg2.stack && this.instructions[j].arg2.isTmp == false && this.instructions[j].arg2.address == currSym.address {
        //                     if this.instructions[j].arg2.size != currSym.size || this.instructions[j].arg1.isReg && this.instructions[j].arg1.address >= ASM_reg_id_floats {
        //                         uses[0] = 0
        //                         break
        //                     }

        //                     uses[0]++
        //                     continue
        //                 }
        //             }
                    
        //             if currSym == null {
        //                 break
        //             }

        //             if uses[0] <= uses[1] {
        //                 uses[0] = uses[1]
        //                 currSym = lastCurrSym
        //             }

        //         }
        //     }
        // }

        // if currSym != null {
        //     searchAddr = currSym.address
        //     debugSym = *currSym
        //     changed = false
        //     i=loopStartIndex; for i < len(this.instructions), i++ {
        //         if this.instructions[i].arg1.stack && this.instructions[i].arg1.isTmp == false && this.instructions[i].arg1.address == searchAddr {
        //             changed = true
        //             this.instructions[i].arg1 = asmSymbolReg(ASM_reg_id_op, this.instructions[i].arg1.size, regNB)
        //         }

        //         if this.instructions[i].arg2.stack && this.instructions[i].arg2.isTmp == false && this.instructions[i].arg2.address == searchAddr {
        //             changed = true
        //             this.instructions[i].arg2 = asmSymbolReg(ASM_reg_id_op, this.instructions[i].arg2.size, regNB)
        //         }
        //     }

        //     if changed {
        //         // printDebugContext()
        //         // println(debugSym.toStr()+": "+uintToStr(uses[0])+" instructions: "+intToStr(len(this.instructions) - loopStartIndex))
        //         this.instructions[loopStartIndex] = asmInstruction {
        //             "pushq", asmSymbolReg(ASM_reg_id_op, 8, regNB)
        //         }
        //     } else {
        //         currSym = null
        //     }
        // }

        if optimized == false {
            this.instructions[len(this.instructions)] = asmInstruction {
                "jmp", asmSymbolValue(loopStart)
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            loopNot+":"
        }

        // if currSym != null {
        //     this.instructions[len(this.instructions)] = asmInstruction {
        //         "popq", asmSymbolReg(ASM_reg_id_op, 8, regNB)
        //     }
        // }

        this.scope--

        if this.stackOffset > this.maxStackOffset {
            this.maxStackOffset = this.stackOffset
        }

        this.stackOffset = <uint>this.endSym.pop()
    }

    generateForContinue() {
        loopId = <uint>this.forStack.end.prev.prev.data
        optimized = <int>this.forStack.end.prev.data != -1
        incrInstructs = <[]asmInstruction>this.forStack.end.data
        loopStart = ".FOR_LOOP_START_"+uintToStr(loopId)

        i=0; for i < len(incrInstructs), i++ {
            this.instructions[len(this.instructions)] = incrInstructs[i]
        }

        if optimized == false {
            this.instructions[len(this.instructions)] = asmInstruction {
                "jmp", asmSymbolValue(loopStart)
            }
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                "jmp", asmSymbolValue(".FOR_NOT_"+uintToStr(loopId))
            }
        }

    }

    generateForBreak() {
        loopId = <uint>this.forStack.end.prev.prev.data
        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(".FOR_NOT_"+uintToStr(loopId))
        }
    }

    generateIf(cond asmSymbol) uint {
        // this.instructions[len(this.instructions)] = asmInstruction {
        //     "#scope", asmSymbolValue(uintToStr(this.stackOffset))
        // }
        this.scope++
        ifNotSym = ".IF_NOT_"+uintToStr(asmRandId)
        this.endSym.insert(<ptr>this.stackOffset)
        this.endSym.insert(ifNotSym)
        asmRandId++

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        } else {

            if this.instructions[len(this.instructions)-1].instruction == "movb" && this.isSameArg(&cond, &this.instructions[len(this.instructions)-1].arg2) {
                al = this.instructions[len(this.instructions)-1].arg1
                setInd = len(this.instructions)-2
                if this.isSameArg(&this.instructions[setInd].arg1, &al) {
                    jmpInst = this.setToJump(this.instructions[setInd].instruction)
                    if len(jmpInst) > 0 {
                        this.instructions[setInd].instruction = jmpInst
                        this.instructions[setInd].arg1 = asmSymbolValue(ifNotSym)
                        if this.isSameArg(&this.instructions[setInd+1].arg1, &al) {
                            this.instructions[setInd+1].instruction = "#"
                        }
                        return setInd
                    }
                }


            }
        }

        if cond.size != 1 {
            cond = this.generateConvSizes(cond, 1, true)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "je", asmSymbolValue(ifNotSym)
        }

        return len(this.instructions) - 1
    }

    generateEndIf(canBeChainned bool) {
        if canBeChainned {
            this.instructions[len(this.instructions)] = asmInstruction {
                "# else_if_placeholder"
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            <str>this.endSym.pop()+":"
        }

        if this.stackOffset > this.maxStackOffset {
            this.maxStackOffset = this.stackOffset
        }

        this.stackOffset = <uint>this.endSym.pop()


        this.scope--
    }

    generateElseIf(cond asmSymbol, chainLength uint, chainLabels []uint) {
        // this.instructions[len(this.instructions)] = asmInstruction {
        //     "#scope", asmSymbolValue(uintToStr(this.stackOffset))
        // }
        this.scope++
        this.endSym.insert(<ptr>this.stackOffset)
        elseNotSym = ".ELSE_NOT_"+uintToStr(asmRandId)

        lasti = len(this.instructions)
        found = false

        for chainLength != 0, chainLength-- {
            this.instructions[chainLabels[chainLength-1] - 1] = asmInstruction {
                "jmp", asmSymbolValue(elseNotSym)
            }
        }    

        if chainLength != 0 && found == false {
            printDebugContext()
            panic("Could not find previous branch in else if chain.")
        }


        this.endSym.insert(elseNotSym)
        asmRandId++

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        }  else {
            if this.instructions[len(this.instructions)-1].instruction == "movb" && this.isSameArg(&cond, &this.instructions[len(this.instructions)-1].arg2) {
                al = this.instructions[len(this.instructions)-1].arg1
                setInd = len(this.instructions)-2
                if this.isSameArg(&this.instructions[setInd].arg1, &al) {
                    jmpInst = this.setToJump(this.instructions[setInd].instruction)
                    if len(jmpInst) > 0 {
                        this.instructions[setInd].instruction = jmpInst
                        this.instructions[setInd].arg1 = asmSymbolValue(elseNotSym)
                        if this.isSameArg(&this.instructions[setInd+1].arg1, &al) {
                            this.instructions[setInd+1].instruction = "#"
                        }
                        return
                    }
                }


            }
        }

        if cond.size != 1 {
            cond = this.generateConvSizes(cond, 1, true)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "je", asmSymbolValue(elseNotSym)
        }
    }

    generateElse(chainLength uint, chainLabels []uint) {
        // this.instructions[len(this.instructions)] = asmInstruction {
        //     "#scope", asmSymbolValue(uintToStr(this.stackOffset))
        // }
        this.scope++
        this.endSym.insert(<ptr>this.stackOffset)
        elseNotSym = ".ELSE_NOT_"+uintToStr(asmRandId)

        for chainLength != 0, chainLength-- {
            this.instructions[chainLabels[chainLength-1] - 1] = asmInstruction {
                "jmp", asmSymbolValue(elseNotSym)
            }
        }

        this.endSym.insert(elseNotSym)
        asmRandId++

    }

    generateEndElse() {
        this.instructions[len(this.instructions)] = asmInstruction {
            "# else_if_placeholder"
        }
        
        this.instructions[len(this.instructions)] = asmInstruction {
            <str>this.endSym.pop()+":"
        }

        if this.stackOffset > this.maxStackOffset {
            this.maxStackOffset = this.stackOffset
        }

        this.stackOffset = <uint>this.endSym.pop()

        this.scope--
    }

    generateVarDecl(name str, size uint, zero bool) asmSymbol {
        alignment = 1
        if size == 4 {
            alignment = 8
        } if size >= 8 {
            alignment = 16
        }

        addr = this.stackOffset + size

        if addr % alignment != 0 {
            addr += (alignment - addr % alignment)
        }

        this.stackOffset = addr

        r = asmSymbol {
            name: name
            size: size
            
            stack: true
            address: this.stackOffset
            active: true
        }

        //need to zero initialize it
        if zero {
            this.instructions[len(this.instructions)] = asmInstruction {
                "pxor", asmSymbolReg(ASM_reg_id_floats, 16, 0), asmSymbolReg(ASM_reg_id_floats, 16, 0)
            }

            offset = r.address
            if GEN_AVXenabled {
                for size >= 32, size -= 32 {
                    destAddr = asmSymbolStack(offset, 32)
                    this.instructions[len(this.instructions)] = asmInstruction {
                        ASM_vector_mov, asmSymbolReg(ASM_reg_id_ymm, 32, 0), destAddr
                    }
                    offset -= 32
                }
            }
            
            for size >= 16, size -= 16 {
                destAddr = asmSymbolStack(offset, 16)
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_vector_mov, asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 16
            }
            for size >= 8, size -= 8 {
                destAddr = asmSymbolStack(offset, 8)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 8
            }
            for size >= 4, size -= 4 {
                destAddr = asmSymbolStack(offset, 4)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movl", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }   
                offset -= 4
            }

            if size != 0 {
                this.instructions[len(this.instructions)] = asmInstruction{
                    "xorb", asmSymbolReg(ASM_reg_id_return, 1, 0), asmSymbolReg(ASM_reg_id_return, 1, 0)
                }
            }

            for size >= 1, size-- {
                destAddr = asmSymbolStack(offset, 1)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movb", asmSymbolReg(ASM_reg_id_return, 1, 0), destAddr
                }
                offset -= 1
            }
        }
        return r
    }

    generateTmpDecl(size uint, zero bool) asmSymbol {
        r = asmSymbolTmp(size)

        //need to zero initialize it
        if size > 8 && zero {
            this.instructions[len(this.instructions)] = asmInstruction {
                "pxor", asmSymbolReg(ASM_reg_id_floats, 16, 0), asmSymbolReg(ASM_reg_id_floats, 16, 0)
            }
            
            offset = r.address
            if GEN_AVXenabled {
                for size >= 32, size -= 32 {
                    destAddr = asmSymbolStack(offset, 32)
                    this.instructions[len(this.instructions)] = asmInstruction {
                        ASM_vector_mov, asmSymbolReg(ASM_reg_id_ymm, 32, 0), destAddr
                    }
                    offset -= 32
                }
            }
            
            for size >= 16, size -= 16 {
                destAddr = asmSymbolStack(offset, 16)
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_vector_mov, asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 16
            }
            for size >= 8, size -= 8 {
                destAddr = asmSymbolStack(offset, 8)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 8
            }
            for size >= 4, size -= 4 {
                destAddr = asmSymbolStack(offset, 4)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movl", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }   
                offset -= 4
            }

            if size != 0 {
                this.instructions[len(this.instructions)] = asmInstruction{
                    "xorb", asmSymbolReg(ASM_reg_id_return, 1, 0), asmSymbolReg(ASM_reg_id_return, 1, 0)
                }
            }

            for size >= 1, size-- {
                destAddr = asmSymbolStack(offset, 1)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movb", asmSymbolReg(ASM_reg_id_return, 1, 0), destAddr
                }
                offset -= 1
            }
        }
        return r
    }

    generateGlobalVarDecl(name str, size uint) asmSymbol {
        this.bss += rope(name+":\n.zero "+uintToStr(size)+"\n.global "+name+"\n")

        r = asmSymbolStaticName(name)
        r.size = size
        return r
    }

    generatePrivateVarWithValue(name str, size uint, syms []asmSymbol) asmSymbol {
        this.data += rope(name+":\n")

        sizeOffset = 0

        i=0; for i < len(syms), i++ {
            sym = syms[i]
            directive = ".byte"

            if sym.size == 8 {
                directive = ".quad"
            } else if sym.size == 4 {
                directive = ".int"
            } else if sym.size == 2 {
                directive = ".word"
            } else if sym.size == 0 {
                directive = ".asciz"
            }

            this.data += rope(directive + " " + sym.name + "\n")

            sizeOffset += sym.size
        }

        r = asmSymbolStaticName(name)
        r.size = size
        return r
    }

    generateGlobalVarDeclWithValue(name str, size uint, syms []asmSymbol) asmSymbol {
        this.data += rope(".global "+name+"\n"+name+":\n")

        sizeOffset = 0

        i=0; for i < len(syms), i++ {
            sym = syms[i]
            directive = ".byte"

            if sym.size == 8 {
                directive = ".quad"
            } else if sym.size == 4 {
                directive = ".int"
            } else if sym.size == 2 {
                directive = ".word"
            } else if sym.size == 0 {
                directive = ".asciz"
            }

            this.data += rope(directive + " " + sym.name + "\n")

            sizeOffset += sym.size
        }

        r = asmSymbolStaticName(name)
        r.size = size
        return r
    }

    generateVarSet(a asmSymbol, b asmSymbol, isUnsigned bool) {
        if b.size != a.size {
            b = this.generateConvSizes(b, a.size, isUnsigned)
        }

        // this.convertRegister(&a, &b)
        
        if b.isValue == false && a.isValue == false && b.size <= 8 && (b.isReg == false || b.level != 0) {
            tmpReg = asmSymbolReg(ASM_reg_id_op, b.size, this.regIndex+1)
            this.generateMoveValue(b, tmpReg)
            b = tmpReg
        }

        if a.level == -1 {
            a.level = 0
        }

        this.generateMoveValue(b, a)
    }

    generateInvBytes(a asmSymbol) asmSymbol {
        if a.isReg == false || a.level != 0 {
            reg = asmSymbolReg(ASM_reg_id_return, a.size, 0)
            this.generateMoveValue(a, reg)
            a = reg
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_not[spos(a.size)], a
        }

        return a
    }

    generateOpBitwise(a asmSymbol, b asmSymbol, operation uint, lossy bool) asmSymbol {
        operStart = len(this.instructions)

        if a.size < b.size {
            if b.isReg && b.address == ASM_reg_id_return {
                b = this.generateTmpSym(b, b.size)
            }
            a = this.generateConvSizes(a, b.size, false)
        } else if b.size < a.size {
            if a.isReg && a.address == ASM_reg_id_return {
                a = this.generateTmpSym(a, a.size)
            }
            b = this.generateConvSizes(b, a.size, false)
        }

        if operation == ASM_OP_BITWISE_LEFT || operation == ASM_OP_BITWISE_RIGHT {
            if (b.isReg == false || b.address != ASM_reg_id_args + 3) && (b.isValue == false || b.name[0] != '$') {
                rightReg = asmSymbolReg(ASM_reg_id_args, b.size, 3)
                if this.isSameArg(&a, &rightReg) {
                    a = this.generateTmpSym(a, a.size)
                }

                this.generateMoveValue(b, rightReg)
                b = rightReg
            }
        }

        inst = ASM_bitwise_ops[operation][spos(a.size)]

        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex), asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if b.level != 0 || b.isReg && b.address == ASM_reg_id_op + this.regIndex{
            this.generateMoveValue(b, accReg[1])
            this.generateMoveValue(a, accReg[0])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            if lossy && a.isReg {
                accReg[0] = a
            } else {
                this.generateMoveValue(a, accReg[0])
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }

        r = accReg[0]
        r.operStart = operStart

        return r
    }

    generateOpAdd(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        // this.convertRegister(&a, &b)


        if a.isValue && a.name[0] == '$' && b.isValue && b.name[0] == '$' {
            if numType == ASM_NUM_UINT {
                a.name = "$" + uintToStr(strToUint(a.name[1:]) + strToUint(b.name[1:]))
            } else {
                a.name = "$" + intToStr(strToInt(a.name[1:]) + strToInt(b.name[1:]))
            }

            return a
        }

        if numType == ASM_NUM_FLOAT {
            a.isFloat = true
            b.isFloat = true
        }

        if a.size < b.size {
            if b.isReg && b.address == ASM_reg_id_return {
                b = this.generateTmpSym(b, b.size)
            }
            a = this.generateConvSizes(a, b.size, numType == ASM_NUM_UINT)
        } else if b.size < a.size {
            if a.isReg && a.address == ASM_reg_id_return {
                a = this.generateTmpSym(a, a.size)
            }
            b = this.generateConvSizes(b, a.size, numType == ASM_NUM_UINT)
        }

        operStart = len(this.instructions)

        size = a.size
        if b.size > a.size {
            size = b.size
        }
        
        inst = ASM_add[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if numType == ASM_NUM_FLOAT {
            if a.isReg == false || a.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, size, 0)
                if b.isReg && b.address >= ASM_reg_id_floats {
                    r.address += (b.address + 1 - ASM_reg_id_floats) % 16
                }
                this.generateMoveValue(a, r)
                a = r
            }

            if b.isReg == false || b.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, size, (a.address + 1 - ASM_reg_id_floats) % 16)
                this.generateMoveValue(b, r)
                b = r
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_add_float[spos(a.size)], b, a
            }
            
            a.operStart = operStart
            a.isFloat = true
            return a
        }

        if b.isReg == true && b.address == accReg[0].address {
            c = a
            a = b
            b = c
            a.size = b.size
        } else if a.isReg == false || a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[0])
        }


        if b.level != 0 {
            this.generateMoveValue(b, accReg[1])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }
        
        r = accReg[0]
        r.operStart = operStart

        return r
    }
    

    generateOpMult(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        // this.convertRegister(&a, &b)

        if a.isValue && a.name[0] == '$' && b.isValue && b.name[0] == '$' {
            if numType == ASM_NUM_UINT {
                a.name = "$" + uintToStr(strToUint(a.name[1:]) * strToUint(b.name[1:]))
            } else {
                a.name = "$" + intToStr(strToInt(a.name[1:]) * strToInt(b.name[1:]))
            }

            return a
        }

        if a.isValue && a.name[0] == '$' {
            if a.name == "$1" {
                return b
            } else if a.name == "$0" {
                return a
            } else {
                n = strToInt(a.name[1:])
                if n % 2 == 0 {
                    p = getTwoPow(n)
                    if p != -1 {
                        return this.generateOpBitwise(b, this.staticInt(intToStr(p)), ASM_OP_BITWISE_LEFT, false)
                    }
                }
            }
        }

        if b.isValue && b.name[0] == '$' {
            if b.name == "$1" {
                return a
            } else if b.name == "$0" {
                return b
            } else {
                n = strToInt(b.name[1:])
                if n % 2 == 0 {
                    p = getTwoPow(n)
                    if p != -1 {
                        return this.generateOpBitwise(a, this.staticInt(intToStr(p)), ASM_OP_BITWISE_LEFT, false)
                    }
                }
            }
        }

        if numType == ASM_NUM_FLOAT {
            a.isFloat = true
            b.isFloat = true
        }

        if a.size < b.size {
            if b.isReg && b.address == ASM_reg_id_return {
                b = this.generateTmpSym(b, b.size)
            }
            a = this.generateConvSizes(a, b.size, numType == ASM_NUM_UINT)
        } else if b.size < a.size {
            if a.isReg && a.address == ASM_reg_id_return {
                a = this.generateTmpSym(a, a.size)
            }
            b = this.generateConvSizes(b, a.size, numType == ASM_NUM_UINT)
        }

        operStart = len(this.instructions)

        inst = ASM_imul[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if numType == ASM_NUM_FLOAT {
            if a.isReg == false || a.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, a.size, 0)
                if b.isReg && b.address >= ASM_reg_id_floats {
                    r.address += (b.address + 1 - ASM_reg_id_floats) % 16
                }
                this.generateMoveValue(a, r)
                a = r
            }

            if b.isReg == false || b.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, a.size, (a.address + 1 - ASM_reg_id_floats) % 16)
                this.generateMoveValue(b, r)
                b = r
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mul_float[spos(a.size)], b, a
            }
            
            a.operStart = operStart
            a.isFloat = true
            return a
        }

        if b.isReg == true && b.address == accReg[0].address {
            c = a
            a = b
            b = c
            a.size = b.size
        } else if a.isReg == false || a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[0])
        }


        if b.level != 0 {
            this.generateMoveValue(b, accReg[1])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }
            
        r = accReg[0]
        r.operStart = operStart

        return r
    }

    generateOpDiv(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        // this.convertRegister(&a, &b)

        if a.isValue && a.name[0] == '$' && b.isValue && b.name[0] == '$' {
            if numType == ASM_NUM_UINT {
                a.name = "$" + uintToStr(strToUint(a.name[1:]) / strToUint(b.name[1:]))
            } else {
                a.name = "$" + intToStr(strToInt(a.name[1:]) / strToInt(b.name[1:]))
            }

            return a
        }

        if b.isValue && b.name[0] == '$' {
            n = strToInt(b.name[1:])
            if n % 2 == 0 {
                p = getTwoPow(n)
                if p != -1 {
                    return this.generateOpBitwise(a, this.staticInt(intToStr(p)), ASM_OP_BITWISE_RIGHT, false)
                }
            }
        }

        if numType == ASM_NUM_FLOAT {
            a.isFloat = true
            b.isFloat = true
        }

        if a.size < b.size {
            if b.isReg && b.address == ASM_reg_id_return {
                b = this.generateTmpSym(b, b.size)
            }
            a = this.generateConvSizes(a, b.size, numType == ASM_NUM_UINT)
        } else if b.size < a.size {
            if a.isReg && a.address == ASM_reg_id_return {
                a = this.generateTmpSym(a, a.size)
            }
            b = this.generateConvSizes(b, a.size, numType == ASM_NUM_UINT)
        }

        operStart = len(this.instructions)

        inst = ""
        if numType == ASM_NUM_INT {
            inst = ASM_idiv[spos(a.size)]
        } else if numType == ASM_NUM_UINT {
            inst = ASM_div[spos(a.size)]
        }


        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]
        
        if numType == ASM_NUM_FLOAT {
            if a.isReg == false || a.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, a.size, 0)
                if b.isReg && b.address >= ASM_reg_id_floats {
                    r.address += (b.address + 1 - ASM_reg_id_floats) % 16
                }
                this.generateMoveValue(a, r)
                a = r
            }

            if b.isReg == false || b.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, a.size, (a.address + 1 - ASM_reg_id_floats) % 16)
                this.generateMoveValue(b, r)
                b = r
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_div_float[spos(a.size)], b, a
            }
            
            a.operStart = operStart
            a.isFloat = true
            return a
        }

        if a.isReg == true && a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[1])
            a = accReg[1]
        }

        this.generateMoveValue(b, accReg[0])

        
        this.generateMoveValue(a, asmSymbolReg(ASM_reg_id_return, a.size, 0))
        if a.size < 4 {
            a.size = 4
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_convert_oct
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            inst, accReg[0]
        }
        
        r = asmSymbolReg(ASM_reg_id_return, a.size, 0)
        
        r.operStart = operStart

        return r
    }

    generateOpMod(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        // this.convertRegister(&a, &b)

        if a.isValue && a.name[0] == '$' && b.isValue && b.name[0] == '$' {
            if numType == ASM_NUM_UINT {
                a.name = "$" + uintToStr(strToUint(a.name[1:]) % strToUint(b.name[1:]))
            } else {
                a.name = "$" + intToStr(strToInt(a.name[1:]) % strToInt(b.name[1:]))
            }

            return a
        }

        operStart = len(this.instructions)

        if a.size < b.size {
            if b.isReg && b.address == ASM_reg_id_return {
                b = this.generateTmpSym(b, b.size)
            }
            a = this.generateConvSizes(a, b.size, numType == ASM_NUM_UINT)
        } else if b.size < a.size {
            if a.isReg && a.address == ASM_reg_id_return {
                a = this.generateTmpSym(a, a.size)
            }
            b = this.generateConvSizes(b, a.size, numType == ASM_NUM_UINT)
        }

        inst = ""
        if numType == ASM_NUM_INT {
            inst = ASM_idiv[spos(a.size)]
        } else if numType == ASM_NUM_UINT {
            inst = ASM_div[spos(a.size)]
        }

        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if a.isReg == true && a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[1])
            a = accReg[1]
        }

        this.generateMoveValue(b, accReg[0])
        
        this.generateMoveValue(a, asmSymbolReg(ASM_reg_id_return, a.size, 0))

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_convert_oct
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            inst, accReg[0]
        }
        
        r = asmSymbolReg(ASM_reg_id_args, a.size, 2)
        r.operStart = operStart

        return r
    }

    generateOpSub(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        // this.convertRegister(&a, &b)

        if a.isValue && a.name[0] == '$' && b.isValue && b.name[0] == '$' {
            if numType == ASM_NUM_UINT {
                a.name = "$" + uintToStr(strToUint(a.name[1:]) - strToUint(b.name[1:]))
            } else {
                a.name = "$" + intToStr(strToInt(a.name[1:]) - strToInt(b.name[1:]))
            }

            return a
        }


        operStart = len(this.instructions)

        if numType == ASM_NUM_FLOAT {
            a.isFloat = true
            b.isFloat = true
        }

        if a.size < b.size {
            if b.isReg && b.address == ASM_reg_id_return {
                b = this.generateTmpSym(b, b.size)
            }
            a = this.generateConvSizes(a, b.size, numType == ASM_NUM_UINT)
        } else if b.size < a.size {
            if a.isReg && a.address == ASM_reg_id_return {
                a = this.generateTmpSym(a, a.size)
            }
            b = this.generateConvSizes(b, a.size, numType == ASM_NUM_UINT)
        }

        inst = ASM_sub[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]
        
        if numType == ASM_NUM_FLOAT {
            if a.isReg == false || a.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, a.size, 0)
                if b.isReg && b.address >= ASM_reg_id_floats {
                    r.address += (b.address + 1 - ASM_reg_id_floats) % 16
                }
                this.generateMoveValue(a, r)
                a = r
            }

            if b.isReg == false || b.address < ASM_reg_id_floats {
                r = asmSymbolReg(ASM_reg_id_floats, a.size, (a.address + 1 - ASM_reg_id_floats) % 16)
                this.generateMoveValue(b, r)
                b = r
            }

            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_sub_float[spos(a.size)], b, a
            }
            
            a.operStart = operStart
            a.isFloat = true
            return a
        }

        if b.level != 0 || b.isReg && b.address == ASM_reg_id_op + this.regIndex {
            this.generateMoveValue(b, accReg[1])
            this.generateMoveValue(a, accReg[0])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            this.generateMoveValue(a, accReg[0])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }

        r = accReg[0]
        r.operStart = operStart

        return r
    }

    generateConvFloatToInt(sym asmSymbol, size uint) asmSymbol {
        if sym.isValue && sym.name[0] == '$' {
            if size == 4 {
                return this.staticInt(intToStr(<int>strToFloat(sym.name[1:])))
            } else if size == 8 {
                return this.staticInt(intToStr(<int>strToFloat(sym.name[1:])))
            }
        }

        if sym.isValue == false || sym.isReg == false || sym.address >= ASM_reg_id_floats {
            this.generateMoveValue(sym, asmSymbolReg(ASM_reg_id_floats, 8, 0))
        }

        inst = "cvttsd2siq"
        regSize = 8
        opReg = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex)

        if sym.size == 8 {
            if size < 8 {
                inst = "cvttsd2sil"
                if size < 4 {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex+1)
                } else {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex)
                }
            }
        } else if sym.size == 4 {
            if size < 8 {
                inst = "cvttss2sil"
                if size < 4 {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex+1)
                } else {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex)
                }
            } else {
                inst = "cvttss2siq"
            }
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            inst, asmSymbolReg(ASM_reg_id_floats, 8, 0), opReg
        }

        if size == 1 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "movsbq", asmSymbolReg(ASM_reg_id_op, size, this.regIndex+1), asmSymbolReg(ASM_reg_id_op, size, this.regIndex)
            }
        } else if size == 2 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "movswq", asmSymbolReg(ASM_reg_id_op, size, this.regIndex+1), asmSymbolReg(ASM_reg_id_op, size, this.regIndex)
            }
        }

        r = this.generateTmpSym(asmSymbolReg(ASM_reg_id_op, size, this.regIndex), size)
        return r
    }

    generateConvIntToFloat(sym asmSymbol, size uint) asmSymbol {
        if sym.isValue && sym.name[0] == '$' {
            if size == 4 {
                return this.staticFloat32(sym.name[1:])
            } else if size == 8 {
                return this.staticFloat64(sym.name[1:])
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "pxor", asmSymbolReg(ASM_reg_id_floats, 8, 0), asmSymbolReg(ASM_reg_id_floats, 8, 0)
        }

        inst = "cvtsi2sdq"
        regSize = 8

        if sym.size == 8 {
            if size == 4 {
                inst = "cvtsi2ssq"
            }
        } else if sym.size == 4 {
            if size == 4 {
                inst = "cvtsi2ssl"
            } else {
                inst = "cvtsi2sdl"
            }
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            inst, sym, asmSymbolReg(ASM_reg_id_floats, size, 0)
        }

        return asmSymbolReg(ASM_reg_id_floats, size, 0)
    }


    generateSymOffset(sym asmSymbol, offset asmSymbol) asmSymbol {
        
        if sym.isReg && sym.level == 0 && offset.isValue && offset.name == "$0" {
            return sym
        }

        if sym.stack && sym.isTmp == false && sym.level == -1 && offset.isValue {
            sym.address -= strToInt(offset.name[1:])
            return sym
        }

        regName = asmSymbolReg(ASM_reg_id_return, 8, 0)
        if sym.isReg && sym.level == 0 {
            regName = sym
        } else {
            if sym.isReg && sym.level < 0 {
                sym.level = 0
            }
            this.generateMoveValue(sym, regName)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_add[spos(sym.size)], offset, regName
        }

        return regName
    }

    generateDestSymOffset(sym asmSymbol, offset asmSymbol) asmSymbol {
        
        if sym.isReg && sym.level == 0 && offset.isValue && offset.name == "$0" {
            return sym
        }

        if sym.stack && sym.isTmp == false && sym.level == -1 && offset.isValue {
            sym.address -= strToInt(offset.name[1:])
            return sym
        }

        regName = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
        if sym.isReg && sym.level == 0 {
            regName = sym
        } else {
            this.generateMoveValue(sym, regName)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_add[spos(sym.size)], offset, regName
        }

        return regName
    }

    generateSelfOp(sym asmSymbol, op byte) asmSymbol {
        inst = ""

        if op == ASM_SELF_OP_ADD {
            inst = ASM_add[spos(sym.size)]
        } else if op == ASM_SELF_OP_SUB {
            inst = ASM_sub[spos(sym.size)]
        }

        if sym.level == 1 {
            tmpSym = sym
            tmpSym.level = 0
            tmpSym.size = 8
            this.generateMoveValue(tmpSym, asmSymbolReg(ASM_reg_id_op, 8, this.regIndex+1))
            retDest = asmSymbolReg(ASM_reg_id_op, sym.size, this.regIndex+1)
            retDest.level = sym.level
            sym = retDest
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            inst, asmSymbolValue("$1"), sym
        }


        return sym
    }

    generateFnStart(fnName str, arguments []asmSymbol, returnSize uint) {
        this.scope++
        this.stackOffset = 0
        
        this.instructions[len(this.instructions)] = asmInstruction {
            ".global", asmSymbolValue(fnName)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            fnName+":"
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "pushq", asmSymbolReg(ASM_reg_id_base_pointer, 8, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0), asmSymbolReg(ASM_reg_id_base_pointer, 8, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "SET_STACK_POINTER"
        }

        this.startIndex = len(this.instructions)

        offset = 0
        floatNb = 0

        if returnSize > 16 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", asmSymbolReg(ASM_reg_id_dest_addr, 8, 0), asmSymbolStack(16, 8)
            }

            this.stackOffset = 16
            offset = 1
        }

        this.maxStackOffset = this.stackOffset

        tmpSyms = []asmSymbol
        this.currentFn = fnName

        i=0; for i < len(arguments) , i++ {
            tmpSyms[len(tmpSyms)] = arguments[i]
            tmpSyms[len(tmpSyms)-1].stack = true

            valueReg = asmSymbol{}

            if arguments[i].size > 8 {
                if arguments[i].size <= 16 {
                    if i+offset >= 5 {
                        valueReg = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
                        inst = ASM_pop[spos(8)]

                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, valueReg
                        }
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, 8, i + offset)
                        valueReg.level = arguments[i].level
                    }

                    tmpSyms[len(tmpSyms)-1] = this.generateVarDecl("small_arg", arguments[i].size, false)
                    this.generateMoveValue(valueReg, tmpSyms[len(tmpSyms)-1])
                    
                    offset++

                    ns = arguments[i].size - 8

                    if i+offset > 5 {
                        if ns < 8 {
                            ns = 8
                        }
                        valueReg = asmSymbolReg(ASM_reg_id_dest_addr, ns, 0)
                        inst = ASM_pop[spos(ns)]

                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, valueReg
                        }
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, ns, i + offset)
                        valueReg.level = arguments[i].level
                    }
                    this.generateMoveValue(valueReg, asmSymbolStack(tmpSyms[len(tmpSyms)-1].address - 8, ns))
                    
                } else {
                    offset--
                    tmpSyms[len(tmpSyms)-1].address = arguments[i].address
                }

                continue 
            }


            if i+offset > 5 {
                arg = arguments[i]
                valueReg = asmSymbolReg(ASM_reg_id_dest_addr, arg.size, 0)

                this.generateMoveValue(asmSymbolStack((i+offset-4) * -8, arg.size), valueReg)
                
                valueReg.size = arguments[i].size
            } else {
                valueReg = asmSymbolReg(ASM_reg_id_args, arguments[i].size, i + offset)
                if arguments[i].isFloat {
                    valueReg = asmSymbolReg(ASM_reg_id_floats, arguments[i].size, floatNb)
                    floatNb++
                    offset--
                }
                valueReg.level = arguments[i].level
            }

            tmpSyms[len(tmpSyms)-1].address = this.generateStackAlloc(valueReg)
        }
    }

    generateFnEnd(endInstructions []asmInstruction) rope* {
        this.scope--
        if len(this.instructions) != 0 && this.instructions[len(this.instructions)-1].instruction == "ret" {
            i=0; for i < len(endInstructions), i++ {
                this.instructions[len(this.instructions)] = endInstructions[i]
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ".global ."+this.currentFn+"_end"
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "."+this.currentFn+"_end:"
            }
            return this.flushInstructions()
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "leave"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "ret"
        }

        i=0; for i < len(endInstructions), i++ {
            this.instructions[len(this.instructions)] = endInstructions[i]
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ".global ."+this.currentFn+"_end"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "."+this.currentFn+"_end:"
        }

        return this.flushInstructions()
    }

    generateReturn(value asmSymbol) {

        if value.size > 8 {
            if value.size <= 16 {
                tmpArg = value
                tmpArg.size = 8
                valueReg = asmSymbolReg(ASM_reg_id_return, 8, 0)
                this.generateMoveValue(tmpArg, valueReg)

                tmpArg.size = value.size - 8

                if tmpArg.stack == false {
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "leaq", tmpArg, asmSymbolReg(ASM_reg_id_args, 8, 2)
                    }
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "addq", asmSymbolValue("$8"), asmSymbolReg(ASM_reg_id_args, 8, 2)
                    }
                    tmpArg = asmSymbolReg(ASM_reg_id_args, 8, 2)
                    tmpArg.level = 1
                } else {
                    tmpArg.address -= 8
                }

                valueReg = asmSymbolReg(ASM_reg_id_args, tmpArg.size, 2)

                this.generateMoveValue(tmpArg, valueReg)
            } else {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", asmSymbolStack(16, 8), asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
                }
                dest = asmSymbolReg(ASM_reg_id_dest_addr, value.size, 0)
                dest.level = 1
                this.generateMoveValue(value, dest)
            }
        } else {
            inst = ASM_mov[spos(value.size)]
            retReg = asmSymbolReg(ASM_reg_id_return, value.size, 0)
            if value.isFloat {
                retReg = asmSymbolReg(ASM_reg_id_floats, value.size, 0)
            }

            this.generateMoveValue(value, retReg)
        }



        this.instructions[len(this.instructions)] = asmInstruction {
            "leave"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "ret"
        }
    }

    generateEarlyReturn() {
        this.instructions[len(this.instructions)] = asmInstruction {
            "leave"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "ret"
        }
    }

    generateFnCallStart() {
        args = []asmSymbol
        this.endSym.insert(args)
    }

    generateFnCallArgument(arg asmSymbol) {
        args = <[]asmSymbol>this.endSym.end.data

        isFloat = arg.isFloat

        if arg.isReg {
            arg = this.generateTmpSym(arg, arg.size)
            arg.isFloat = isFloat
        }

        args[len(args)] = arg
    }

    generateFnCall(fnName asmSymbol, returnSize uint, returnAddress asmSymbol*, returnsFloat bool) asmSymbol {
        arguments = <[]asmSymbol>this.endSym.pop()

        returnAlloc asmSymbol

        offset int = 0

        if returnSize > 16 {
            if returnAddress != null {
                this.generateMoveValue(*returnAddress, asmSymbolReg(ASM_reg_id_dest_addr, 8, 0))
            } else {
                returnAlloc = this.generateVarDecl("return_addr", returnSize, false)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "leaq", returnAlloc, asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
                }
            }
            offset = 1
        }

        rspOffset = 0
        floatNb = 0
        i=0; for i < len(arguments), i++ {

            if arguments[i].isFloat && floatNb < 8 {
                //TODO: handle 16bytes structs (also in fnstart)
                this.generateMoveValue(arguments[i], asmSymbolReg(ASM_reg_id_floats, 8, floatNb))
                floatNb++
                offset--
                continue
            }

            if arguments[i].size > 8 {
                if arguments[i].size <= 16 {
                    tmpArg = arguments[i]
                    tmpArg.size = 8
                    if i+offset > 5 {
                        inst = ASM_push[spos(8)]
                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, tmpArg
                        }
                        rspOffset += 8
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, 8, i+offset)

                        this.generateMoveValue(tmpArg, valueReg)
                    }

                    offset++
                    tmpArg.size = arguments[i].size - 8

                    if tmpArg.stack == false {
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "leaq", tmpArg, asmSymbolReg(ASM_reg_id_return, 8, 0)
                        }
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "addq", asmSymbolValue("$8"), asmSymbolReg(ASM_reg_id_return, 8, 0)
                        }
                        tmpArg = asmSymbolReg(ASM_reg_id_return, tmpArg.size, 0)
                        tmpArg.level = 1
                    } else {
                        tmpArg.address -= 8
                    }
                    

                    if i+offset > 5 {
                        if tmpArg.size < 8 {
                            tmpArg.size = 8
                        }
                        inst = ASM_push[spos(tmpArg.size)]
                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, tmpArg
                        }
                        rspOffset += 8
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, tmpArg.size, i+offset)

                        this.generateMoveValue(tmpArg, valueReg)
                    }

                } else {
                    offset--
                    dest = asmSymbolReg(ASM_reg_id_op, 8, 4) //Avoid using rdi to not overwrite first argument
                    sizeAligned = arguments[i].size
                    if sizeAligned % 16 != 0 {
                        sizeAligned += (16 - sizeAligned % 16)
                    }
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "subq", asmSymbolValue("$"+uintToStr(sizeAligned)), asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0)
                    }
                    this.generateMoveValue(asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0), dest)
                    rspOffset += sizeAligned
                    dest.level = 1
                    this.generateMoveValue(arguments[i], dest)
                    
                    //make it dynamic for optimizer to skip its allocation
                }

                continue
            }

            if i+offset > 5 {
                arg = arguments[i]
                inst = ASM_push[spos(arg.size)]

                if arg.size < 8 {
                    inst = "pushq"
                    tmpDest = asmSymbolReg(ASM_reg_id_return, arg.size, 0)
                    this.generateMoveValue(arg, tmpDest)
                    tmpDest.size = 8
                    arg = tmpDest
                }

                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, arg
                }
                rspOffset += 8
            } else {
                valueReg = asmSymbolReg(ASM_reg_id_args, arguments[i].size, i+offset)
                this.generateMoveValue(arguments[i], valueReg)
                if arguments[i].size < 4 {
                    inst = "movsbl"
                    if arguments[i].size == 2 {
                        inst = "movswl"
                    }
                    this.instructions[len(this.instructions)] = asmInstruction {
                        inst, valueReg, valueReg    
                    }
                    this.instructions[len(this.instructions)-1].arg2.size = 4
                }
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "call", fnName
        }

        if rspOffset != 0 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "addq", asmSymbolValue("$"+uintToStr(rspOffset)), asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0)
            }
        }

        if returnSize > 8 {
            if returnSize <= 16 {
                accReg = asmSymbolReg(ASM_reg_id_floats, 16, 1)
                retSym = this.generateVarDecl("return_addr", 16, false)
                retSym.size = 8
                this.generateMoveValue(asmSymbolReg(ASM_reg_id_return, 8, 0), retSym)
                retSym.address -= 8
                this.generateMoveValue(asmSymbolReg(ASM_reg_id_args, 8, 2), retSym)

                retSym.address += 8
                retSym.size = returnSize
                return retSym
            } else {
                return returnAlloc
            }
        }

        if returnsFloat {
            f = asmSymbolReg(ASM_reg_id_floats, returnSize, 0)
            f.isFloat = true
            return f
        }
        
        r = asmSymbolReg(ASM_reg_id_return, returnSize, 0)
        

        return r
    }

    generateSyscall(arguments []asmSymbol, syscall asmSymbol, returnSize uint) asmSymbol {
        i=len(arguments)-1; for i != -1, i-- {
            valueReg = asmSymbolReg(ASM_reg_id_args, arguments[i].size, i)

            this.generateMoveValue(arguments[i], valueReg)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "int", syscall
        }

        return asmSymbolReg(ASM_reg_id_return, returnSize, 0)
    }
}

_asm_append_instruction(ctxPtr ptr, inst asmInstruction) {
    ctx = <asmContext*>ctxPtr
    ctx.instructions[len(ctx.instructions)] = inst
}