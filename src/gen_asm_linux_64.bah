ASM_arguments_registers_64 = []str{"%rdi", "%rsi", "%rdx", "%rcx",  "%r8",  "%r9"}
ASM_arguments_registers_32 = []str{"%edi", "%esi", "%edx", "%ecx", "%r8d", "%r9d"}
ASM_arguments_registers_16 = []str{"%di", "%si", "%dx", "%cx", "%r8w", "%r9w"}
ASM_arguments_registers_8  = []str{"%dil", "%sil", "%dl", "%cl", "%r8b", "%r9b"}

// ASM_arguments_registers_16 = []str{"%di",  "%si",  "%dx",  "%cx",  "%r8w", "%r9w"}
// ASM_arguments_registers_8  = []str{"%dil", "%sil", "%dl",  "%cl",  "%r8b", "%r9b"}

ASM_arguments_registers = [][]str{ASM_arguments_registers_8, ASM_arguments_registers_16, ASM_arguments_registers_32, ASM_arguments_registers_64}

ASM_float_registers = []str{"%xmm0", "%xmm1", "%xmm2", "%xmm3", "%xmm4", "%xmm5", "%xmm6", "%xmm7"}

ASM_syscall_registers_64 = []str{"%rax", "%rbx", "%rcx", "%rdx"}
ASM_syscall_registers_32 = []str{"%eax", "%ebx", "%ecx", "%edx"}
ASM_syscall_registers_16 = []str{"%eax", "%ebx", "%ecx", "%edx"}
ASM_syscall_registers_8  = []str{"%eax", "%ebx", "%ecx", "%edx"}

ASM_syscall_registers = [][]str{ASM_syscall_registers_8, ASM_syscall_registers_16, ASM_syscall_registers_32, ASM_syscall_registers_64}

ASM_op_registers_64 = []str{"%rbx", "%rdx",  "%r8",  "%r9",  "%r10",  "%r11",  "%r12",  "%r13",  "%r14",  "%r15"}
ASM_op_registers_32 = []str{"%ebx", "%edx", "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"}
ASM_op_registers_16 = []str{ "%bx",  "%dx", "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w"}
ASM_op_registers_8  = []str{ "%bl",  "%dl", "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"}

ASM_op_registers = [][]str{ASM_op_registers_8, ASM_op_registers_16, ASM_op_registers_32, ASM_op_registers_64}

ASM_return_register    = []str{"%al", "%ax", "%eax", "%rax"}
ASM_addr_dest_register = []str{"%dil", "%di", "%edi", "%rdi"}

ASM_set = []str{"sete", "setne", "setg", "setl", "setle", "setge"}

const ASM_reg_id_return = 0
const ASM_reg_id_dest_addr = 1
const ASM_reg_id_stack_pointer = 2
const ASM_reg_id_base_pointer = 3

const ASM_reg_id_args    = 128
const ASM_reg_id_syscall = 256
const ASM_reg_id_op      = 512
const ASM_reg_id_floats  = 1024

const ASM_OP_EQ            = 0
const ASM_OP_NOT_EQ        = 1
const ASM_OP_GREATER       = 2
const ASM_OP_LESS          = 3
const ASM_OP_LESS_OR_EQ    = 4
const ASM_OP_GREATER_OR_EQ = 5

const ASM_SELF_OP_ADD = 0
const ASM_SELF_OP_SUB = 1


ASM_mov  = []str{"movb", "movw", "movl", "movq"}
ASM_push = []str{"pushb", "pushw", "pushl", "pushq"}
ASM_pop  = []str{"popb", "popw", "popl", "popq"}
ASM_add  = []str{"addb", "addw", "addl", "addq"}
ASM_sub  = []str{"subb", "subw", "subl", "subq"}
ASM_imul = []str{"imulb", "imulw", "imull", "imulq"}
ASM_mul = []str{"mulb", "mulw", "mull", "mulq"}
ASM_idiv = []str{"idivb", "idivw", "idivl", "idivq"}
ASM_div = []str{"divb", "divw", "divl", "divq"}
ASM_cmp = []str{"cmpb", "cmpw", "cmpl", "cmpq"}
ASM_cmp_float = []str{"", "", "comiss", "comisd"}
ASM_mov_float  = []str{"", "", "movss", "movsd"}
ASM_add_float  = []str{"", "", "addss", "addsd"}
ASM_mul_float  = []str{"", "", "mulss", "mulsd"}
ASM_sub_float  = []str{"", "", "subss", "subsd"}
ASM_div_float  = []str{"", "", "divss", "divsd"}
ASM_convert_oct = "cqto"

ASM_NUM_INT   = 0
ASM_NUM_UINT  = 1
ASM_NUM_FLOAT = 2

spos(x uint) uint {
    if x == 1 {
        return 0
    }
    if x == 2 {
        return 1
    }
    if x == 4 {
        return 2
    }
    if x != 8 {
        return 0
        panic("Invalid length.")
    }

    return 3
}

asmRandId uint = 0

struct asmSymbol {
    name: str
    size: uint

    isFloat: bool
    
    isReg: bool
    stack: bool
    address: int
    heapOffset: int
    parent: ptr
    isTmp: bool

    scope: uint

    level: int

    isValue: bool
    optimizable: bool = true
    operStart: int = -1

    toStr() str {
        if this.isValue {
            return this.name
        }

        if this.isTmp {
            return "TMP_"+uintToStr(this.address)
            // panic("Trying to use non allocated temporary symbol: "+toJson(this)+".")
        }

        if this.isReg {
            s = ""
            size = this.size
            if this.level >= 1 {
                size = 8
            }
            if this.address == ASM_reg_id_return {
                s = ASM_return_register[spos(size)]
            } else if this.address == ASM_reg_id_dest_addr {
                s = ASM_addr_dest_register[spos(size)]
            } else if this.address == ASM_reg_id_stack_pointer {
                s = "%rsp"
            } else if this.address == ASM_reg_id_base_pointer {
                s = "%rbp"
            } else {
                if this.address < ASM_reg_id_syscall { //arguments
                    num = this.address - ASM_reg_id_args
                    if num > len(ASM_arguments_registers[spos(size)]) {
                        panic("Not enough argument registers")
                    }
                    s = ASM_arguments_registers[spos(size)][num]
                } else if this.address < ASM_reg_id_op { //syscall arguments
                    num = this.address - ASM_reg_id_syscall
                    if num > len(ASM_syscall_registers[spos(size)]) {
                        panic("Not enough argument registers")
                    }
                    s = ASM_syscall_registers[spos(size)][num]
                } else if this.address < ASM_reg_id_floats { //operations and accumulators
                    num = this.address - ASM_reg_id_op
                    if num > len(ASM_op_registers[spos(size)]) {
                        panic("Not enough argument registers")
                    }
                    s = ASM_op_registers[spos(size)][num]
                } else {
                    num = this.address - ASM_reg_id_floats
                    if num > len(ASM_float_registers) {
                        panic("Not enough argument registers")
                    }
                    s = ASM_float_registers[num]
                }
            } 
            if this.level == 1 {
                s = "("+s+")"
            }
            return s
        }

        if this.stack {
            //stack offset?
            if this.address == 0 {
                return "(%rbp)"
            }
            sub = "-"
            addr = this.address
            if this.address < 0 {
                sub = ""
                addr = 0 - this.address
            }
            return sub+uintToStr(addr)+"(%rbp)"
        }

        return this.name+"(%rip)"
    }
}

asmSymbolValue(s str) asmSymbol {
    r = asmSymbol{
        isValue: true
        name: s
    }
    return r
}

asmSymbolReg(id uint, size uint, num uint) asmSymbol {
    r = asmSymbol {
        isReg: true
        size: size
        address: id + num
    }

    if id >= ASM_reg_id_floats {
        r.isFloat = true
    }
    return r
}

asmSymbolStack(address int, size uint) asmSymbol {
    r = asmSymbol {
        stack: true
        address: address
        size: size
    }
    return r
}

asmSymbolStaticName(name str) asmSymbol {
    r = asmSymbol {
        name: name
    }
    return r
}

asmSymbolTmp(size uint) asmSymbol {
    r = asmSymbol {
        stack: true
        isTmp: true
        address: asmRandId
        size: size
    }
    asmRandId++
    return r
}

isEmptySymbol(sym asmSymbol) bool {
    return sym.isReg == false && sym.stack == false && sym.isValue == false && len(sym.name) == 0
}

struct asmInstruction {
    instruction: str
    arg1: asmSymbol
    arg2: asmSymbol

    toStr() str {
        if isEmptySymbol(this.arg2) == false {
            return this.instruction+" "+this.arg1.toStr()+", "+this.arg2.toStr()
        }
        if isEmptySymbol(this.arg1) == false {
            return this.instruction+" "+this.arg1.toStr()
        }
        return this.instruction
    }
}

#define _asm_append_instruction(ctxPtr ptr, inst asmInstruction)

struct asmContext {
    // symbols: []asmSymbol

    data: rope*
    bss: rope*
    code: rope*

    currentFn: str
    scope: uint = 0
    startIndex: uint = 0

    verbose: bool = true

    regIndex: uint = 0

    stackOffset: uint = 0
    lastStackOffset: uint = 0

    endSym: queue
    forStack: queue

    enableOptimizations: bool = true

    xmmIndex: uint = 0

    instructions: []asmInstruction
    discardedArgs: []asmSymbol

    isSameArg(a asmSymbol, b asmSymbol) bool {
        if a.isTmp != b.isTmp {
            return false
        }
        
        if a.isTmp || b.isTmp {
            return a.address == b.address    
        }

        if a.stack {
            if b.stack == false {
                return false
            }
            if a.address == b.address {
                return true
            }
            if a.size < b.size {
                c = a
                a = b
                b = c
            }

            

            if a.address - a.size < b.address && a.address >= b.address {
                return true
            }
            return false
        }

        if a.isReg {
            if b.isReg == false {
                return false
            }
            return a.address == b.address
        }

        if a.isValue {
            if b.isValue == false {
                return a.name == b.toStr()
            }
            return a.name == b.name
        }

        if b.isValue {
            return b.name == a.toStr()
        }

        if len(a.name) == 0 {
            return false
        }

        if len(b.name) == 0 {
            return false
        }

        return a.name == b.name
    }

    isSameArgAndSize(a asmSymbol, b asmSymbol) bool {
        if this.isSameArg(a, b) {
            return a.size == b.size && a.level == b.level
        }

        return false
    }

    isSet(arg asmSymbol, i uint) bool {
        if strHasPrefix(this.instructions[i].instruction, "cmp") == true {
            return false
        }

        if this.isSameArg(this.instructions[i].arg2, arg) {
            return true
        }

        return false
    }

    isUsed(arg asmSymbol, i uint) bool {
        //do not optimize out global variables
        if arg.isReg == false && arg.stack == false && arg.isValue == false {
            return true
        }

        if strHasPrefix(this.instructions[i].instruction, "cmp") {
            if this.isSameArg(this.instructions[i].arg1, arg) || this.isSameArg(this.instructions[i].arg2, arg) {
                return true
            }
            return false
        }

        if arg.isReg && this.instructions[i].instruction == "call" {
            return true
        }

        if this.isSameArg(this.instructions[i].arg1, arg) {
            return true
        }

        return false
    }

    isSetInRange(arg asmSymbol, from uint, end uint) bool {
        i = from; for i < end, i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }
            
            if this.isSet(arg, i) {
                return true
            }
        }

        return false
    }

    isUsedInRange(arg asmSymbol, from uint, end uint) bool {
        i = from; for i < end, i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if arg.isTmp && strHasPrefix(this.instructions[i].instruction, ".loc") {
                return false
            }

            if this.isSet(arg, i) {
                return true
            }
            
            if this.isUsed(arg, i) {
                return true
            }

            if arg.isReg && this.instructions[i].instruction == "call" {
                return false
            }

        }

        return false
    }

    removeStackAlloc(sym asmSymbol) {
        // i=4; for i < len(this.instructions), i++ {
        //     if this.instructions[i].instruction[0] == '#' {
        //         continue
        //     }
        //     if this.isSameArg(this.instructions[i].arg2, sym) || this.isSameArg(this.instructions[i].arg1, sym) {
        //         return
        //     }
        // }
        

        if sym.size % 16 != 0 {
            return //to not mess up stack alignment without realigning all symbol after sym.address
        }

        this.stackOffset -= sym.size

        i=this.startIndex; for i < len(this.instructions), i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }
            if this.instructions[i].arg1.stack && this.instructions[i].arg1.address > sym.address {
                this.instructions[i].arg1.address = this.instructions[i].arg1.address - sym.size

            }

            if this.instructions[i].arg2.stack && this.instructions[i].arg2.address > sym.address {
                this.instructions[i].arg2.address = this.instructions[i].arg2.address - sym.size
            }
        }
    }


    removeStackAllocs() {
        i=0; for i < len(this.discardedArgs), i++ {
            ind = i
            prevInd = ind
            i++
            for i < len(this.discardedArgs), i++ {
                alignment = 1
                if this.discardedArgs[i].size == 4 {
                    alignment = 8
                } if this.discardedArgs[i].size >= 8 {
                    alignment = 16
                }
                alignedAddress = this.discardedArgs[prevInd].address + this.discardedArgs[prevInd].size
                if alignedAddress % alignment != 0 {
                    alignedAddress += (alignment - alignedAddress % alignment)
                }

                if alignedAddress != this.discardedArgs[i].address {
                    break
                }
                prevInd = i
            }
            i--
            if i == ind {
                this.removeStackAlloc(this.discardedArgs[i])
            } else {
                tmpSym = this.discardedArgs[ind]
                tmpSym.size = (this.discardedArgs[i].address + this.discardedArgs[i].size) - tmpSym.address
                this.removeStackAlloc(tmpSym)
            }
        }
        clear(this.discardedArgs)
    }

    optimizeInstructions(n uint) bool {
        found = false

        i=this.startIndex; for i < len(this.instructions), i++ {
            istrct = this.instructions[i]

            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if strHasPrefix(istrct.instruction, "add") || strHasPrefix(istrct.instruction, "sub") {
                if istrct.arg1.isValue && istrct.arg1.name == "$0" {
                    this.instructions[i].instruction = "noop"
                }
            }

            if strHasPrefix(istrct.instruction, "mov") || istrct.instruction == "leaq" {
                
                if this.isSameArgAndSize(istrct.arg1, istrct.arg2) {
                    this.instructions[i].instruction = "#" + istrct.instruction
                    found = true
                    continue
                }

                //Double move optimization.
                //  'mov a -> b, mov b -> c'
                //  becomes
                //  'mov a, c'
                j = i + 1
                for j < len(this.instructions), j++ {
                    next = this.instructions[j]

                    if next.instruction[0] == '#' {
                        continue
                    }

                    if istrct.arg2.isTmp && strHasPrefix(this.instructions[i].instruction, ".loc") {
                        break
                    }

                    if strHasPrefix(next.instruction, "mov") == false && next.instruction != "leaq" && next.instruction[0] != '#' {
                        j = len(this.instructions)
                        break
                    }

                    //double mov
                    if this.isSameArgAndSize(next.arg1, istrct.arg2) {
                        if next.instruction != "leaq" && (istrct.arg1.isReg && istrct.arg1.level == 0 || next.arg2.isReg && next.arg2.level == 0) && istrct.arg1.size == next.arg2.size && (this.isUsedInRange(istrct.arg2, j+1, len(this.instructions)) == false) && this.isSetInRange(istrct.arg1, i+1, j) == false && this.isSetInRange(istrct.arg2, i+1, j) == false {
                            this.instructions[j].instruction = "#" + next.instruction
                            discardedArg = this.instructions[i].arg2
                            this.instructions[i].arg2 = next.arg2
                            if discardedArg.stack && discardedArg.isTmp == false {
                                // this.removeStackAlloc(discardedArg)
                                this.discardedArgs[len(this.discardedArgs)] = discardedArg
                            }
                            found = true
                        }

                        break
                    }

                    //double mov with dereference
                    if istrct.arg2.isReg && istrct.arg1.isReg && next.arg1.isReg && next.arg1.level == 1 && next.arg1.address == istrct.arg2.address {
                        if next.instruction != "leaq" && (istrct.arg1.isReg && istrct.arg1.level == 0 || next.arg2.isReg && next.arg2.level == 0) && (this.isUsedInRange(istrct.arg2, j+1, len(this.instructions)) == false) && this.isSetInRange(istrct.arg1, i+1, j) == false {
                            this.instructions[i].instruction = "#" + istrct.instruction
                            discardedArg = this.instructions[j].arg1
                            this.instructions[j].arg1 = istrct.arg1
                            this.instructions[j].arg1.level = 1
                            if discardedArg.stack && discardedArg.isTmp == false {
                                // this.removeStackAlloc(discardedArg)
                                this.discardedArgs[len(this.discardedArgs)] = discardedArg
                            }
                            found = true
                        }

                        break
                    }
                }


            }


        }

        //last step
        if found == false {
            this.removeStackAllocs()
        }

        return found
    }
    
    generateSymFromTmp(sym asmSymbol, i uint) uint {
        alignment = 1
        if sym.size == 4 {
            alignment = 8
        } if sym.size >= 8 {
            alignment = 16
        }

        addr = this.stackOffset + sym.size

        if addr % alignment != 0 {
            addr += (alignment - addr % alignment)
        }

        this.stackOffset = addr

        for i < len(this.instructions), i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if strHasPrefix(this.instructions[i].instruction, ".loc") {
                break
            }

            if this.instructions[i].arg1.isTmp && this.instructions[i].arg1.address == sym.address {
                this.instructions[i].arg1.isTmp = false
                this.instructions[i].arg1.address = addr
            }

            if this.instructions[i].arg2.isTmp && this.instructions[i].arg2.address == sym.address {
                this.instructions[i].arg2.isTmp = false
                this.instructions[i].arg2.address = addr
            }
        }

        return addr
    }

    flushInstructions() {
        if this.enableOptimizations {
            shouldOptimize = true
            n = 0
            for shouldOptimize {
                shouldOptimize = this.optimizeInstructions(n)
                n++
            }
        }

        //generating tmp symbols
        stackOffsetBeforeTmp = this.stackOffset
        maxStackOffset = this.stackOffset
        i=0; for i < len(this.instructions), i++ {
            if this.instructions[i].instruction[0] == '#' {
                continue
            }

            if strHasPrefix(this.instructions[i].instruction, ".loc") {
                if this.stackOffset > maxStackOffset {
                    maxStackOffset = this.stackOffset
                }
                this.stackOffset = stackOffsetBeforeTmp
            }

            //TODO: two args are the same tmp?

            if this.instructions[i].arg1.isTmp {
                this.generateSymFromTmp(this.instructions[i].arg1, i)
            }
            if this.instructions[i].arg2.isTmp {
                this.generateSymFromTmp(this.instructions[i].arg2, i)
            }
        }
        if maxStackOffset > this.stackOffset {
            this.stackOffset = maxStackOffset
        }
        


        //trim unnecessary stackframe 
        if this.stackOffset == 0 {
            i=this.startIndex; for i < len(this.instructions), i++ {
                if this.instructions[i].instruction[0] == '#' {
                    continue
                }

                if strHasPrefix(this.instructions[i].instruction, "push") {
                    break
                }

                if this.instructions[i].arg1.stack || this.instructions[i].arg2.stack {
                    break
                }
            }

            if i == len(this.instructions) {
                this.stackOffset = 0
                this.instructions[this.startIndex-2].instruction = "#" + this.instructions[1].instruction
                this.instructions[this.startIndex-1].instruction = "#" + this.instructions[2].instruction
            }
        }


        i=0; for i < len(this.instructions), i++ {
            istrct = this.instructions[i]

            if istrct.instruction == "noop" {
                continue
            }

            if istrct.instruction[0] == '#' {
                // this.code += rope(istrct.toStr()+"\n")
                continue
            }

            if istrct.instruction == "SET_STACK_POINTER" {
                if this.stackOffset == 0 {
                    continue
                }
                istrct.instruction = "subq"
                istrct.arg1 = asmSymbolValue("$"+uintToStr(this.stackOffset))
                istrct.arg2 = asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0)
            } else if istrct.instruction == "leave" {
                if this.stackOffset == 0 {
                    if this.instructions[1].instruction[0] == '#' {
                        istrct.instruction = "#" + istrct.instruction //"popq"
                    } else {
                        istrct = asmInstruction {
                            "popq", asmSymbolReg(ASM_reg_id_base_pointer, 8, 0)
                        } //"popq"
                    }
                    // istrct.arg1 = "%rbp"
                }
            } else if strHasPrefix(istrct.instruction, "mov") && istrct.arg1.isFloat && istrct.arg1.isReg && istrct.arg1.address >= ASM_reg_id_floats {
                if istrct.instruction == "movq" {
                    istrct.instruction = "movsd"
                } else if istrct.instruction == "movl" {
                    istrct.instruction = "movss"
                }
            }

            //immediate optimizations
            if this.enableOptimizations {
                //if (and) optimization
                if istrct.instruction[0] == 'j' && istrct.arg1.isValue && istrct.arg1.name == ".BOOL_AND_" {
                    searchName = istrct.arg1.name + "_END:"
                    j=i+1; for j < len(this.instructions), j++ {
                        if this.instructions[j].instruction == searchName {
                            break
                        }
                    }
                    if this.instructions[j+1].instruction == "cmpb" && ((this.instructions[j+1].arg1.isReg && this.instructions[j+1].arg1.address == ASM_reg_id_return && this.instructions[j+1].arg1.size == 1) || (this.instructions[j+1].arg2.isReg && this.instructions[j+1].arg2.address == ASM_reg_id_return && this.instructions[j+1].arg2.size == 1)) {
                        jumpInd = j+2; for jumpInd < len(this.instructions), jumpInd++ {
                            if this.instructions[jumpInd].instruction == "movb" && this.instructions[jumpInd].arg1.isReg && this.instructions[jumpInd].arg1.address == ASM_reg_id_return && this.instructions[jumpInd].arg1.size == 1 {
                                jumpInd = len(this.instructions)
                                break
                            }
                            if this.instructions[jumpInd].instruction[0] == 'j' {
                                break
                            }
                        }

                        if jumpInd != len(this.instructions) {
                            endInstrct = j
                            this.instructions[jumpInd].instruction = "noop"
                            this.instructions[endInstrct+1].instruction = "noop"

                            found = false


                            j=i+1; for j <= endInstrct, j++ {
                                if found {
                                    this.instructions[j].instruction = "noop"
                                    continue
                                }
                                if this.instructions[j].instruction[0] == 'j' {
                                    if this.isSameArgAndSize(this.instructions[j].arg1, istrct.arg1) {
                                        this.instructions[j].arg1 = this.instructions[jumpInd].arg1
                                    } else if this.instructions[j].arg1.name == istrct.arg1.name+"_END" {
                                        this.instructions[j-1].instruction = "noop"
                                        this.instructions[j].instruction = "noop"
                                        found = true
                                    }
                                }
                            }
                            istrct.arg1 = this.instructions[jumpInd].arg1
                        }
                    }

                } else if istrct.instruction[0] == 'j' && istrct.arg1.isValue && istrct.arg1.name == ".BOOL_OR_" {
                    searchName = istrct.arg1.name + "_END:"
                    j=i+1; for j < len(this.instructions), j++ {
                        if this.instructions[j].instruction == searchName {
                            break
                        }
                    }
                    if this.instructions[j+1].instruction == "cmpb" && ((this.instructions[j+1].arg1.isReg && this.instructions[j+1].arg1.address == ASM_reg_id_return && this.instructions[j+1].arg1.size == 1) || (this.instructions[j+1].arg2.isReg && this.instructions[j+1].arg2.address == ASM_reg_id_return && this.instructions[j+1].arg2.size == 1)) {
                        jumpInd = j+2; for jumpInd < len(this.instructions), jumpInd++ {
                            if this.instructions[jumpInd].instruction == "movb" && this.instructions[jumpInd].arg1.isReg && this.instructions[jumpInd].arg1.address == ASM_reg_id_return && this.instructions[jumpInd].arg1.size == 1 {
                                jumpInd = len(this.instructions)
                                break
                            }
                            if this.instructions[jumpInd].instruction[0] == 'j' {
                                break
                            }
                        }

                        if jumpInd != len(this.instructions) {
                            endInstrct = j
                            this.instructions[jumpInd].instruction = "noop"
                            this.instructions[endInstrct+1].instruction = "noop"

                            found = false

                            j=i+1; for j < endInstrct, j++ {
                                if found {
                                    this.instructions[j].instruction = "noop"
                                    continue
                                }
                                if this.instructions[j].instruction[0] == 'j' {
                                    if this.isSameArgAndSize(this.instructions[j].arg1, istrct.arg1) {
                                        this.instructions[j].arg1.name += "_END"
                                    } else if this.instructions[j].arg1.isValue && this.instructions[j].arg1.name == istrct.arg1.name+"_NOT" {
                                        this.instructions[j].arg1 = this.instructions[jumpInd].arg1
                                        found = true
                                    }
                                }
                            }
                            istrct.arg1.name += "_END"
                        }
                    }


                } else if strHasPrefix(istrct.instruction, ".FOR_LOOP_START_") {
                    hasSet = false
                    j=i+1; for j < len(this.instructions), j++ {
                        if this.instructions[j].instruction[0] == 'j' && this.instructions[j].arg1.isValue && this.instructions[j].arg1.name == ".FOR_NOT_"+istrct.instruction[16:len(istrct.instruction)-1] {
                            break
                        }
                        if strHasPrefix(this.instructions[j].instruction, "set") {
                            hasSet = true
                        }
                    }
                    if hasSet {
                        jumpInd = j
                        j--; for j >= i+1, j-- {
                            if strHasPrefix(this.instructions[j].instruction, "set") {
                                break
                            }
                            this.instructions[j].instruction = "noop"
                        }
                    }
                } else if strHasPrefix(istrct.instruction, "cmp") {
                    if i+2 < len(this.instructions) {
                        tmpVar = this.instructions[i+2].arg2
                        jumpInd = i+1; for jumpInd < len(this.instructions), jumpInd++ {
                            if this.instructions[jumpInd].instruction == "movb" && this.instructions[jumpInd].arg1.isReg && this.instructions[jumpInd].arg1.address == ASM_reg_id_return && this.instructions[jumpInd].arg1.size == 1 {
                                jumpInd = len(this.instructions)
                                break
                            }
                            if this.instructions[jumpInd].instruction[0] == 'j' {
                                break
                            }
                        }
                        if jumpInd != len(this.instructions) {
                            j=jumpInd; for j < len(this.instructions), j++ {
                                if this.isSameArgAndSize(this.instructions[j].arg2, tmpVar) && this.instructions[j].arg1.isValue && this.instructions[j].arg1.name == "$0" {
                                    j = len(this.instructions)
                                    break
                                }
                                if this.isSameArgAndSize(this.instructions[j].arg1, tmpVar) && isEmptySymbol(this.instructions[j].arg2) == false {
                                    break
                                }
                            }
                            if j == len(this.instructions) {
                                nextInst = this.instructions[i+1].instruction
                                oi = i
                                i = jumpInd - 1
                                if nextInst == "sete" {
                                    this.instructions[jumpInd].instruction = "jne"
                                } else if nextInst == "setne" {
                                    this.instructions[jumpInd].instruction = "je"
                                } else if nextInst == "setg" {
                                    this.instructions[jumpInd].instruction = "jle"
                                } else if nextInst == "setl" {
                                    this.instructions[jumpInd].instruction = "jge"
                                } else if nextInst == "setge" {
                                    this.instructions[jumpInd].instruction = "jl"
                                } else if nextInst == "setle" {
                                    this.instructions[jumpInd].instruction = "jg"
                                } else {
                                    i = oi
                                }
                            }
                        }
                    }
                }
            }

            this.code += rope(istrct.toStr()+"\n")
        }
        clear(this.instructions)
    }

    fileNb: uint = 0
    totalFileNb: uint = 0

    generateFileLocation(fileName str) {
        this.instructions[len(this.instructions)] = asmInstruction {
            ".file "+uintToStr(this.totalFileNb)+" \""+fileName+"\""
        }
        this.totalFileNb++
        this.fileNb = this.totalFileNb
    }

    generateLineLocation(line uint) {
        index = len(this.instructions)-1
        if index == -1 || strHasPrefix(this.instructions[index].instruction, ".loc") == false {
            index++
        }
        this.instructions[index] = asmInstruction {
            ".loc "+uintToStr(this.fileNb-1)+" "+uintToStr(line)
        }
    }

    resetRegisters() {
        this.regIndex = 0
    }

    convertRegister(a asmSymbol*, b asmSymbol*) {
        if a.isReg && b.size != a.size {
            a.size = b.size
        } else if b.isReg && b.size != a.size {
            b.size = a.size
        } else if a.isValue && b.isValue == false {
            a.size = b.size
        } else if a.isValue == false && b.isValue {
            b.size = a.size
        }
    }

    generateMoveValue(sym asmSymbol, dest asmSymbol) {
        if sym.level == -1 && sym.size <= 8 {
            if dest.isReg {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "leaq", sym, dest
                }
                return
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "leaq", sym, asmSymbolReg(ASM_reg_id_return, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", asmSymbolReg(ASM_reg_id_return, 8, 0), dest
            }
            return
        }
        if sym.size > 8 {
            incrSize = 16
            offset = 0

            if sym.isReg && sym.size == 16 {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movups", sym, dest
                }
                return
            }

            if sym.isReg == false && sym.stack == false {
                tmpsym = sym
                tmpsym.size = 8
                tmpsym.level = -1
                srcReg = asmSymbolReg(ASM_reg_id_return, 8, 0)
                this.generateMoveValue(tmpsym, srcReg)
                srcReg.level = 1
                srcReg.size = sym.size
                sym = srcReg
            }

            if sym.level == 1 {
                srcReg = asmSymbolReg(ASM_reg_id_return, 8, 0)
                tmpsym = sym
                tmpsym.level = 0
                tmpsym.size = 8
                this.generateMoveValue(tmpsym, srcReg)
                srcRegAddr = srcReg
                srcReg.level = sym.level

                for offset < sym.size, offset += incrSize {
                    if (sym.size - offset) < incrSize {
                        incrSize = incrSize / 2
                    }
                    if incrSize == 0 {
                        break
                    }
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "addq", asmSymbolValue("$"+uintToStr(offset)), srcRegAddr
                    }
                    destReg asmSymbol
                    trsfrReg asmSymbol

                    if dest.stack {
                        destReg = asmSymbolStack(dest.address - offset, incrSize)
                    } else {
                        if dest.level <= 0 {
                            panic("what the hell")
                        }
                        destReg = dest
                        destReg.level = 0
                        destReg.size = 8
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "addq", asmSymbolValue("$"+uintToStr(offset)), destReg
                        }
                        destReg.level = dest.level
                    }

                    inst = "movups"
                    if incrSize <= 2 {
                        inst = ASM_mov[spos(incrSize)]
                        trsfrReg = asmSymbolReg(ASM_reg_id_op, incrSize, this.regIndex)                    
                    } else {
                        if incrSize <= 8 {
                            inst = ASM_mov_float[spos(incrSize)]
                        }
                        trsfrReg = asmSymbolReg(ASM_reg_id_floats, incrSize, 0)                    
                    }

                    this.instructions[len(this.instructions)] = asmInstruction {
                        inst, srcReg, trsfrReg
                    }

                    this.instructions[len(this.instructions)] = asmInstruction {
                        inst, trsfrReg, destReg
                    }
                }   
                return
            }

            for offset < sym.size, offset += incrSize {
                if (sym.size - offset) < incrSize {
                    incrSize = incrSize / 2
                }
                if incrSize == 0 {
                    break
                }
                srcReg = asmSymbolStack(sym.address - offset, incrSize)
                destReg asmSymbol
                trsfrReg asmSymbol

                if dest.stack {
                    destReg = asmSymbolStack(dest.address - offset, incrSize)
                } else {
                    if dest.level <= 0 {
                        panic("what the hell")
                    }
                    destReg = dest
                    destReg.level = 0
                    destReg.size = 8
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "addq", asmSymbolValue("$"+uintToStr(offset)), destReg
                    }
                    destReg.level = dest.level
                }


                inst = "movups"
                if incrSize <= 2 {
                    inst = ASM_mov[spos(incrSize)]
                    trsfrReg = asmSymbolReg(ASM_reg_id_op, incrSize, this.regIndex)                    
                } else {
                    if incrSize <= 8 {
                        inst = ASM_mov_float[spos(incrSize)]
                    }
                    trsfrReg = asmSymbolReg(ASM_reg_id_floats, incrSize, 0)                    
                } 


                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, srcReg, trsfrReg
                }

                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, trsfrReg, destReg
                }
            }
            return
        }

        from = sym
        level = sym.level
        if level > 0 {
            oDest = asmSymbol{}
            if dest.isReg == false {
                oDest = dest
                dest = asmSymbolReg(ASM_reg_id_return, 8, 0)
            }
            if from.isReg == false {
                tmpSym = from
                tmpSym.level = 0
                tmpSym.size = 8
                this.generateMoveValue(tmpSym, asmSymbolReg(ASM_reg_id_return, 8, 0))
                retDest = asmSymbolReg(ASM_reg_id_return, 8, 0)
                retDest.level = from.level
                from = retDest
            }

            for level > 1, level-- {
                from.level = 1
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", from, dest
                }
                from = dest
            }
            if level == 1 {
                from.level = 1
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_mov[spos(sym.size)], from, dest
                }
            }
            if isEmptySymbol(oDest) == false {
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_mov[spos(sym.size)], dest, oDest
                }
            }
            return
        }

        if dest.isReg == false && (sym.isValue == false && sym.isReg == false) {
            tmpReg = asmSymbolReg(ASM_reg_id_op, sym.size, this.regIndex)
            this.generateMoveValue(sym, tmpReg)
            from = tmpReg
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_mov[spos(sym.size)], from, dest
        }
    }

    generateStackAlloc(value asmSymbol) int {       
        alignment = 1
        if value.size == 4 {
            alignment = 8
        } if value.size >= 8 {
            alignment = 16
        }

        addr = this.stackOffset + value.size

        if addr % alignment != 0 {
            addr += (alignment - addr % alignment)
        }

        this.stackOffset = addr

        so = this.stackOffset
        this.generateMoveValue(value, asmSymbolStack(so, value.size))

        return so
    }

    generateTmpSym(value asmSymbol, size uint) asmSymbol {
        r = asmSymbolTmp(size)

        this.generateMoveValue(value, r)
        return r
    }

    generateUnary(sym asmSymbol) asmSymbol {
        addrReg = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex+1)
        ogSize = sym.size
        
        sym.size = 8
        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", sym, addrReg
        }

        sym.size = ogSize
        addrReg.level = 1
        if sym.size > 8 {
            addrReg.size = sym.size
            ns = asmSymbolStack(this.generateStackAlloc(addrReg), sym.size)
            return ns
        }

        return this.generateTmpSym(addrReg, ogSize)
    }

    generateDereference(sym asmSymbol) asmSymbol {
        addrReg = asmSymbolReg(ASM_reg_id_return, sym.size, 0)

        this.generateMoveValue(sym, addrReg)

        addrReg.level = 1

        return addrReg
    }

    generateDestDereference(sym asmSymbol) asmSymbol {
        addrReg = asmSymbolReg(ASM_reg_id_dest_addr, sym.size, 0)

        this.generateMoveValue(sym, addrReg)

        addrReg.level = 1

        return addrReg
    }

    generateStaticStr(s str, length uint) asmSymbol {
        name = ".VAR_"+uintToStr(asmRandId)
        this.data += rope(name+":\n.int "+uintToStr(length)+"\n.string "+s+"\n")

        r = asmSymbol {
            parent: this
            name: name
            size: 8
            level: -1
        }
        asmRandId++
        return r
    }

    staticInt(v str) asmSymbol {
        r = asmSymbol {
            parent: this
            name: "$"+v
            size: 8
            isValue: true
        }

        return r
    }

    staticFloat32(v str) asmSymbol {
        f = <float32>strToFloat(v)
        u = *(<uint32*>&f)

        name = ".FLOAT32_"+uintToStr(asmRandId)
        this.data += rope(name+":\n.long "+uintToStr(u)+"\n")
        asmRandId++

        this.xmmIndex = (this.xmmIndex + 1) % len(ASM_float_registers)

        floatReg = asmSymbolReg(ASM_reg_id_floats, 8, this.xmmIndex)

        this.instructions[len(this.instructions)] = asmInstruction {
            "movss", asmSymbolStaticName(name), floatReg
        }

        return floatReg
    }

    staticFloat64(v str) asmSymbol {
        f = strToFloat(v)
        u = *(<uint*>&f)

        partA = <uint32>u
        partB = <uint32>(u >> 32)

        name = ".FLOAT_"+uintToStr(asmRandId)
        this.data += rope(name+":\n.long "+uintToStr(partA)+"\n.long "+uintToStr(partB)+"\n")
        asmRandId++

        floatReg = asmSymbolReg(ASM_reg_id_floats, 8, this.xmmIndex)

        this.instructions[len(this.instructions)] = asmInstruction {
            "movsd", asmSymbolStaticName(name), floatReg
        }

        return floatReg
    }

    generateCompare(a asmSymbol, b asmSymbol, op uint) asmSymbol {
        this.convertRegister(&a, &b)

        ogB = b

        c = a
        a = b
        b = c

        operStart = len(this.instructions)

        if b.isReg == false {
            if a.isReg && a.level == 0 {
                if op == ASM_OP_LESS {
                    op = ASM_OP_GREATER
                } else if op == ASM_OP_LESS_OR_EQ {
                    op = ASM_OP_GREATER_OR_EQ
                } else if op == ASM_OP_GREATER {
                    op = ASM_OP_LESS
                } else if op == ASM_OP_GREATER_OR_EQ {
                    op = ASM_OP_LESS_OR_EQ
                }
                return this.generateCompare(a, b, op)
            }
            tmpReg = asmSymbolReg(ASM_reg_id_op, b.size, this.regIndex+1)
            this.generateMoveValue(b, tmpReg)
            b = tmpReg
            b.size = a.size
        }

        if a.isReg == false && a.level == 1 {
            if ogB.level != 0 {
                this.regIndex++
            }
            tmpReg = asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)
            this.generateMoveValue(a, tmpReg)
            this.regIndex--
            a = tmpReg
        }

        if a.isReg && a.address >= ASM_reg_id_floats || b.isReg && b.address >= ASM_reg_id_floats {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_cmp_float[spos(a.size)], a, b
            }    
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_cmp[spos(a.size)], a, b
            }
        }


        ret = asmSymbolReg(ASM_reg_id_return, 1, 0)

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_set[op], ret
        }


        r = asmSymbol {
            parent: this
            size: 1
            stack: true
            address: this.generateStackAlloc(ret)
            operStart: operStart
        }

        return r
    }

    generateBoolOrStart() {
        operStart = len(this.instructions)
        jumpSym = ".BOOL_OR_" + uintToStr(asmRandId)
        asmRandId++

        this.endSym.insert(operStart)
        this.endSym.insert(jumpSym)
    }

    generateBoolOr(cond asmSymbol) {
        operStart = <uint>this.endSym.end.prev.data
        jumpSym = <str>this.endSym.end.data

        if cond.operStart != -1 {
            setOpIndex = cond.operStart + 1
            for setOpIndex < len(this.instructions), setOpIndex++ {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            this.instructions[setOpIndex].instruction = "j" + this.instructions[setOpIndex].instruction[3:]
            this.instructions[setOpIndex].arg1 = asmSymbolValue(jumpSym)
            this.instructions[setOpIndex+1].instruction = "noop"
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$1"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "je", asmSymbolValue(jumpSym)
            }
        }
    }

    generateBoolOrEnd(cond asmSymbol) asmSymbol {
        jumpSym = <str>this.endSym.pop()
        operStart = <uint>this.endSym.pop()

        if cond.operStart != -1 {
            setOpIndex = cond.operStart + 1
            for setOpIndex < len(this.instructions), setOpIndex++ {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            if this.instructions[setOpIndex].instruction == "sete" {
                this.instructions[setOpIndex].instruction = "jne"
            } else if this.instructions[setOpIndex].instruction == "setne" {
                this.instructions[setOpIndex].instruction = "je"
            } else if this.instructions[setOpIndex].instruction == "setg" {
                this.instructions[setOpIndex].instruction = "jle"
            } else if this.instructions[setOpIndex].instruction == "setl" {
                this.instructions[setOpIndex].instruction = "jge"
            } else if this.instructions[setOpIndex].instruction == "setge" {
                this.instructions[setOpIndex].instruction = "jl"
            } else if this.instructions[setOpIndex].instruction == "setle" {
                this.instructions[setOpIndex].instruction = "jg"
            }

            this.instructions[setOpIndex].arg1.name = jumpSym+"_NOT"
            this.instructions[setOpIndex].arg1.isValue = true
            this.instructions[setOpIndex+1].instruction = "noop"
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$1"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "jne", asmSymbolValue(jumpSym+"_NOT")
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+":"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$1"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(jumpSym+"_END")
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+"_NOT:"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$0"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+"_END:"
        }

        return asmSymbolReg(ASM_reg_id_return, 1, 0)
    }

    generateBoolAndStart() {
        operStart = len(this.instructions)
        jumpSym = ".BOOL_AND_" + uintToStr(asmRandId)
        asmRandId++

        this.endSym.insert(operStart)
        this.endSym.insert(jumpSym)
    }

    generateBoolAnd(cond asmSymbol) {
        operStart = <uint>this.endSym.end.prev.data
        jumpSym = <str>this.endSym.end.data

        if cond.operStart != -1 {
            setOpIndex = cond.operStart + 1
            for setOpIndex < len(this.instructions), setOpIndex++ {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            if this.instructions[setOpIndex].instruction == "sete" {
                this.instructions[setOpIndex].instruction = "jne"
            } else if this.instructions[setOpIndex].instruction == "setne" {
                this.instructions[setOpIndex].instruction = "je"
            } else if this.instructions[setOpIndex].instruction == "setg" {
                this.instructions[setOpIndex].instruction = "jle"
            } else if this.instructions[setOpIndex].instruction == "setl" {
                this.instructions[setOpIndex].instruction = "jge"
            } else if this.instructions[setOpIndex].instruction == "setge" {
                this.instructions[setOpIndex].instruction = "jl"
            } else if this.instructions[setOpIndex].instruction == "setle" {
                this.instructions[setOpIndex].instruction = "jg"
            }

            this.instructions[setOpIndex].arg1 = asmSymbolValue(jumpSym)
            this.instructions[setOpIndex+1].instruction = "noop"
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$0"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "je", asmSymbolValue(jumpSym)
            }
        }
    }

    generateBoolAndEnd(cond asmSymbol) asmSymbol {
        jumpSym = <str>this.endSym.pop()
        operStart = <uint>this.endSym.pop()

        if cond.operStart != -1 {
            setOpIndex = cond.operStart + 1
            for setOpIndex < len(this.instructions), setOpIndex++ {
                if strHasPrefix(this.instructions[setOpIndex].instruction, "set") {
                    break
                }
            }

            if this.instructions[setOpIndex].instruction == "sete" {
                this.instructions[setOpIndex].instruction = "jne"
            } else if this.instructions[setOpIndex].instruction == "setne" {
                this.instructions[setOpIndex].instruction = "je"
            } else if this.instructions[setOpIndex].instruction == "setg" {
                this.instructions[setOpIndex].instruction = "jle"
            } else if this.instructions[setOpIndex].instruction == "setl" {
                this.instructions[setOpIndex].instruction = "jge"
            } else if this.instructions[setOpIndex].instruction == "setge" {
                this.instructions[setOpIndex].instruction = "jl"
            } else if this.instructions[setOpIndex].instruction == "setle" {
                this.instructions[setOpIndex].instruction = "jg"
            }

            this.instructions[setOpIndex].arg1 = asmSymbolValue(jumpSym)
            this.instructions[setOpIndex+1].instruction = "noop"
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                "cmpb", asmSymbolValue("$0"), cond
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "je", asmSymbolValue(jumpSym)
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$1"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(jumpSym+"_END")
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+":"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movb", asmSymbolValue("$0"), asmSymbolReg(ASM_reg_id_return, 1, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            jumpSym+"_END:"
        }

        return asmSymbolReg(ASM_reg_id_return, 1, 0)
    }

    generateStrConcatBegin() {
        this.endSym.insert(<ptr>len(this.instructions))
        syms = []asmSymbol
        this.endSym.insert(syms)
    }

    generateStrConcat(sym asmSymbol) {
        syms = <[]asmSymbol>this.endSym.end.data

        if sym.stack == false || sym.level != 0 {
            sym = this.generateTmpSym(sym, sym.size)
            // sym = asmSymbolStack(this.generateStackAlloc(sym), sym.size)
            // sym.singleUse = true
        }

        syms[len(syms)] = sym
    }

    generateStrConcatEnd() asmSymbol {
        syms = <[]asmSymbol>this.endSym.pop()
        operStart = <uint>this.endSym.pop()

        this.instructions[len(this.instructions)] = asmInstruction {
            "movl", asmSymbolValue("$5"), asmSymbolReg(ASM_reg_id_args, 4, 0)
        }

        i=0; for i < len(syms), i++ {
            sym = syms[i]

            tmpOp = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex)

            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", sym, tmpOp
            }

            tmpOp.level = 1
            this.instructions[len(this.instructions)] = asmInstruction {
                "addl", tmpOp, asmSymbolReg(ASM_reg_id_args, 4, 0)
            }


        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "pushq", asmSymbolReg(ASM_reg_id_args, 8, 0)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "call", asmSymbolValue(memoryAllocFunctionSTR)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "popq", asmSymbolReg(ASM_reg_id_args, 8, 0)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "subq", asmSymbolValue("$5"), asmSymbolReg(ASM_reg_id_args, 8, 0)
        }

        tmpRet = asmSymbolReg(ASM_reg_id_return, 8, 0)
        tmpRet.level = 1
        this.instructions[len(this.instructions)] = asmInstruction {
            "movl", asmSymbolReg(ASM_reg_id_args, 4, 0), tmpRet
        }

        tmpRet.level = 0
        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", tmpRet, asmSymbolReg(ASM_reg_id_op, 8, this.regIndex)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "addq", asmSymbolValue("$4"), tmpRet
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", tmpRet, asmSymbolReg(ASM_reg_id_args, 8, 0)
        }

        i=0; for i < len(syms), i++ {
            sym = syms[i]
            tmpArg1 = asmSymbolReg(ASM_reg_id_args, 8, 1)
            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", sym, tmpArg1
            }

            tmpArg1.level = 1
            this.instructions[len(this.instructions)] = asmInstruction {
                "movl", tmpArg1, asmSymbolReg(ASM_reg_id_args, 4, 2)
            }
            tmpArg1.level = 0
            this.instructions[len(this.instructions)] = asmInstruction {
                "addq", asmSymbolValue("$4"), tmpArg1
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "pushq", asmSymbolReg(ASM_reg_id_args, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "pushq", asmSymbolReg(ASM_reg_id_args, 8, 2)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "call", asmSymbolValue("memcpy")
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "popq", asmSymbolReg(ASM_reg_id_args, 8, 2)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                "popq", asmSymbolReg(ASM_reg_id_args, 8, 0)
            }
            if i+1 != len(syms) {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "addq", asmSymbolReg(ASM_reg_id_args, 8, 2), asmSymbolReg(ASM_reg_id_args, 8, 0)
                }
            }
        }

        r = asmSymbol {
            parent: this
            size: 8
            isReg: true
            address: ASM_reg_id_op + this.regIndex
            operStart: operStart
        }

        // r = asmSymbolStack(this.generateStackAlloc(r), 8)
        // r.singleUse = true
        return this.generateTmpSym(r, 8)
    }

    generateFor() {
        this.scope++
        forLoopStartSym = ".FOR_LOOP_START_"+uintToStr(asmRandId)
        this.endSym.insert(forLoopStartSym)
        this.forStack.insert(asmRandId)
        this.endSym.insert(asmRandId)
        asmRandId++

        this.instructions[len(this.instructions)] = asmInstruction {
            forLoopStartSym+":"
        }
    }

    generateForCond(cond asmSymbol) {
        idNb = <uint>this.endSym.pop()
        forLoopStartSym = <str>this.endSym.pop()

        forNotSym = ".FOR_NOT_"+uintToStr(idNb)
        this.endSym.insert(forNotSym)

        this.endSym.insert(forLoopStartSym)

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "je", asmSymbolValue(forNotSym)
        }

        this.endSym.insert(len(this.instructions))
    }

    generateForIncr() {
        lastIndex = this.endSym.pop()

        incrIstrcts = this.instructions[lastIndex:]

        rArr = <Bah_Array_Type*>(this.instructions)
        rArr.length = len(this.instructions) - len(incrIstrcts)

        this.endSym.insert(incrIstrcts)   
        this.forStack.insert(incrIstrcts)

    }

    generateForEnd() {
        incrInstructs = <[]asmInstruction>this.endSym.pop()
        loopStart = <str>this.endSym.pop()
        loopNot = <str>this.endSym.pop()

        this.forStack.pop()
        this.forStack.pop()

        i=0; for i < len(incrInstructs), i++ {
            this.instructions[len(this.instructions)] = incrInstructs[i]
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(loopStart)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            loopNot+":"
        }
        this.scope--
    }

    generateForContinue() {
        loopId = <uint>this.forStack.end.prev.data
        incrInstructs = <[]asmInstruction>this.forStack.end.data
        loopStart = ".FOR_LOOP_START_"+uintToStr(loopId)

        i=0; for i < len(incrInstructs), i++ {
            this.instructions[len(this.instructions)] = incrInstructs[i]
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(loopStart)
        }
    }

    generateForBreak() {
        loopId = <uint>this.forStack.end.prev.data
        this.instructions[len(this.instructions)] = asmInstruction {
            "jmp", asmSymbolValue(".FOR_NOT_"+uintToStr(loopId))
        }
    }

    generateIf(cond asmSymbol) {
        this.scope++
        ifNotSym = ".IF_NOT_"+uintToStr(asmRandId)
        this.endSym.insert(ifNotSym)
        asmRandId++

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "je", asmSymbolValue(ifNotSym)
        }
    }

    generateEndIf() {
        this.instructions[len(this.instructions)] = asmInstruction {
            <str>this.endSym.pop()+":"
        }


        this.scope--

        // i=0; for i < len(this.symbols), i++ {
        //     if this.symbols[i].scope > this.scope {
        //         delete(this.symbols, i)
        //         i--
        //     }
        // }
    }

    generateElseIf(cond asmSymbol, chainLength uint) {
        this.scope++
        elseNotSym = ".ELSE_NOT_"+uintToStr(asmRandId)

        lasti = len(this.instructions)
        for chainLength != 0, chainLength-- {
            i = len(this.instructions)-1
            for i != -1, i-- {
                this.instructions[i+1] = this.instructions[i]
                if i > lasti {
                    continue
                }
                if strHasPrefix(this.instructions[i].instruction, ".IF_NOT_") || strHasPrefix(this.instructions[i].instruction, ".ELSE_NOT_") {
                    this.instructions[i] = asmInstruction {
                        "jmp", asmSymbolValue(elseNotSym)
                    }

                    lasti = i - 1
                    break
                }
            }
        }


        this.endSym.insert(elseNotSym)
        asmRandId++

        if cond.level != 0 {
            retReg = asmSymbolReg(ASM_reg_id_return, 1, 0)
            this.generateMoveValue(cond, retReg)
            cond = retReg
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_cmp[spos(1)], asmSymbolValue("$0"), cond
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "je", asmSymbolValue(elseNotSym)
        }

    }

    generateElse(chainLength uint) {
        this.scope++
        elseNotSym = ".ELSE_NOT_"+uintToStr(asmRandId)

        lasti = len(this.instructions)
        for chainLength != 0, chainLength-- {
            i = len(this.instructions)-1
            for i != -1, i-- {
                this.instructions[i+1] = this.instructions[i]
                if i > lasti {
                    continue
                }
                if strHasPrefix(this.instructions[i].instruction, ".IF_NOT_") || strHasPrefix(this.instructions[i].instruction, ".ELSE_NOT_") {
                    this.instructions[i] = asmInstruction {
                        "jmp", asmSymbolValue(elseNotSym)
                    }

                    lasti = i - 1
                    break
                }
            }
        }

        this.endSym.insert(elseNotSym)
        asmRandId++
    }

    generateEndElse() {
        this.instructions[len(this.instructions)] = asmInstruction {
            <str>this.endSym.pop()+":"
        }

        this.scope--
    }

    generateVarDecl(name str, size uint, zero bool) asmSymbol {
        alignment = 1
        if size == 4 {
            alignment = 8
        } if size >= 8 {
            alignment = 16
        }

        addr = this.stackOffset + size

        if addr % alignment != 0 {
            addr += (alignment - addr % alignment)
        }

        this.stackOffset = addr

        r = asmSymbol {
            parent: this
            name: name
            size: size
            scope: this.scope

            stack: true
            address: this.stackOffset

        }

        //need to zero initialize it
        if zero {
            this.instructions[len(this.instructions)] = asmInstruction {
                "pxor", asmSymbolReg(ASM_reg_id_floats, 16, 0), asmSymbolReg(ASM_reg_id_floats, 16, 0)
            }
            offset = r.address
            for size >= 16, size -= 16 {
                destAddr = asmSymbolStack(offset, 16)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movups", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 16
            }
            for size >= 8, size -= 8 {
                destAddr = asmSymbolStack(offset, 8)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 8
            }
            for size >= 4, size -= 4 {
                destAddr = asmSymbolStack(offset, 8)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movl", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }   
                offset -= 4
            }

            if size != 0 {
                this.instructions[len(this.instructions)] = asmInstruction{
                    "xorb", asmSymbolReg(ASM_reg_id_return, 1, 0), asmSymbolReg(ASM_reg_id_return, 1, 0)
                }
            }

            for size >= 1, size-- {
                destAddr = asmSymbolStack(offset, 8)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movb", asmSymbolReg(ASM_reg_id_return, 1, 0), destAddr
                }
                offset -= 1
            }
        }
        return r
    }

    generateTmpDecl(size uint, zero bool) asmSymbol {
        r = asmSymbolTmp(size)

        //need to zero initialize it
        if size > 8 && zero {
            this.instructions[len(this.instructions)] = asmInstruction {
                "pxor", asmSymbolReg(ASM_reg_id_floats, 16, 0), asmSymbolReg(ASM_reg_id_floats, 16, 0)
            }
            offset = r.address
            for size >= 16, size -= 16 {
                destAddr = asmSymbolStack(offset, 16)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movups", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 16
            }
            for size >= 8, size -= 8 {
                destAddr = asmSymbolStack(offset, 8)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 8
            }
            for size >= 4, size -= 4 {
                destAddr = asmSymbolStack(offset, 8)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movl", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }   
                offset -= 4
            }
            for size >= 1, size-- {
                destAddr = asmSymbolStack(offset, 8)
                destAddr.optimizable = false
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movb", asmSymbolReg(ASM_reg_id_floats, 16, 0), destAddr
                }
                offset -= 1
            }
        }
        return r
    }

    generateGlobalVarDecl(name str, size uint) asmSymbol {
        this.bss += rope(name+":\n.zero "+uintToStr(size)+"\n.global "+name+"\n")

        r = asmSymbolStaticName(name)
        r.size = size
        return r
    }

    generatePrivateVarWithValue(name str, size uint, syms []asmSymbol) asmSymbol {
        this.data += rope(name+":\n")

        sizeOffset = 0

        i=0; for i < len(syms), i++ {
            sym = syms[i]
            directive = ".byte"

            if sym.size == 8 {
                directive = ".quad"
            } else if sym.size == 4 {
                directive = ".int"
            } else if sym.size == 2 {
                directive = ".word"
            } else if sym.size == 0 {
                directive = ".string"
            }

            this.data += rope(directive + " " + sym.name + "\n")

            sizeOffset += sym.size
        }

        r = asmSymbolStaticName(name)
        r.size = size
        return r
    }

    generateGlobalVarDeclWithValue(name str, size uint, syms []asmSymbol) asmSymbol {
        this.data += rope(".global "+name+"\n"+name+":\n")

        sizeOffset = 0

        i=0; for i < len(syms), i++ {
            sym = syms[i]
            directive = ".byte"

            if sym.size == 8 {
                directive = ".quad"
            } else if sym.size == 4 {
                directive = ".int"
            } else if sym.size == 2 {
                directive = ".word"
            } else if sym.size == 0 {
                directive = ".string"
            }

            this.data += rope(directive + " " + sym.name + "\n")

            sizeOffset += sym.size
        }

        r = asmSymbolStaticName(name)
        r.size = size
        return r
    }

    generateVarSet(a asmSymbol, b asmSymbol) {
        if b.isValue && a.isReg && a.level > 0 {
            b.size = a.size
        }

        this.convertRegister(&a, &b)
        
        if b.isValue == false && a.isValue == false && b.size <= 8 && (b.isReg == false || b.level != 0) {
            tmpReg = asmSymbolReg(ASM_reg_id_op, b.size, this.regIndex+1)
            this.generateMoveValue(b, tmpReg)
            b = tmpReg
        }

        this.generateMoveValue(b, a)
    }

    generateOpAdd(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        this.convertRegister(&a, &b)

        operStart = len(this.instructions)

        size = a.size
        if b.size > a.size {
            size = b.size
        }
        
        inst = ASM_add[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if numType == ASM_NUM_FLOAT {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mov_float[spos(a.size)], a, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_add_float[spos(a.size)], b, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            
            r = asmSymbolReg(ASM_reg_id_floats, 8, 0)
            r.operStart = operStart
            return r
        }

        if b.isReg == true && b.address == accReg[0].address {
            c = a
            a = b
            b = c
            a.size = b.size
        } else if a.isReg == false || a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[0])
        }


        if b.level != 0 {
            this.generateMoveValue(b, accReg[1])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }
        
        r = accReg[0]
        r.operStart = operStart

        return r
    }

    generateOpMult(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        this.convertRegister(&a, &b)

        operStart = len(this.instructions)

        inst = ASM_imul[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if numType == ASM_NUM_FLOAT {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mov_float[spos(a.size)], a, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mul_float[spos(a.size)], b, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            
            r = asmSymbolReg(ASM_reg_id_floats, 8, 0)
            r.operStart = operStart
            return r
        }

        if b.isReg == true && b.address == accReg[0].address {
            c = a
            a = b
            b = c
            a.size = b.size
        } else if a.isReg == false || a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[0])
        }


        if b.level != 0 {
            this.generateMoveValue(b, accReg[1])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }
            
        r = accReg[0]
        r.operStart = operStart

        return r
    }

    generateOpDiv(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        this.convertRegister(&a, &b)

        operStart = len(this.instructions)

        inst = ASM_idiv[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]
        
        if numType == ASM_NUM_FLOAT {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mov_float[spos(a.size)], a, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_div_float[spos(a.size)], b, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            
            r = asmSymbolReg(ASM_reg_id_floats, 8, 0)
            r.operStart = operStart
            return r
        }

        if a.isReg == true && a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[1])
            a = accReg[1]
        }

        this.generateMoveValue(b, accReg[0])

        
        this.generateMoveValue(a, asmSymbolReg(ASM_reg_id_return, a.size, 0))
        if a.size < 4 {
            a.size = 4
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_convert_oct
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            inst, accReg[0]
        }
        
        r = asmSymbolReg(ASM_reg_id_return, a.size, 0)
        r.operStart = operStart

        return r
    }

    generateOpMod(a asmSymbol, b asmSymbol) asmSymbol {
        this.convertRegister(&a, &b)

        operStart = len(this.instructions)

        inst = ASM_idiv[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]

        if a.isReg == true && a.address != accReg[0].address {
            this.generateMoveValue(a, accReg[1])
            a = accReg[1]
        }

        this.generateMoveValue(b, accReg[0])
        
        this.generateMoveValue(a, asmSymbolReg(ASM_reg_id_return, a.size, 0))

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_convert_oct
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            inst, accReg[0]
        }
        
        r = asmSymbolReg(ASM_reg_id_args, a.size, 2)
        r.operStart = operStart

        return r
    }


    generateOpSub(a asmSymbol, b asmSymbol, numType uint) asmSymbol {
        this.convertRegister(&a, &b)

        operStart = len(this.instructions)

        inst = ASM_sub[spos(a.size)]
        accReg = [asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex),asmSymbolReg(ASM_reg_id_op, a.size, this.regIndex+1)]
        
        if numType == ASM_NUM_FLOAT {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mov_float[spos(a.size)], a, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_sub_float[spos(a.size)], b, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
            
            r = asmSymbolReg(ASM_reg_id_floats, 8, 0)
            r.operStart = operStart
            return r
        }

        this.generateMoveValue(a, accReg[0])
        if b.level != 0 {
            this.generateMoveValue(b, accReg[1])
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, accReg[1], accReg[0]
            }
        } else {
            this.instructions[len(this.instructions)] = asmInstruction {
                inst, b, accReg[0]
            }
        }
        
        r = accReg[0]
        r.operStart = operStart

        return r
    }

    generateConvFloatToInt(sym asmSymbol, size uint) asmSymbol {
        if sym.isValue == false || sym.isReg == false || sym.address >= ASM_reg_id_floats {
            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mov_float[spos(sym.size)], sym, asmSymbolReg(ASM_reg_id_floats, 8, 0)
            }
        }

        inst = "cvttsd2siq"
        regSize = 8
        opReg = asmSymbolReg(ASM_reg_id_op, 8, this.regIndex)

        if sym.size == 8 {
            if size < 8 {
                inst = "cvttsd2sil"
                if size < 4 {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex+1)
                } else {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex)
                }
            }
        } else if sym.size == 4 {
            if size < 8 {
                inst = "cvttss2sil"
                if size < 4 {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex+1)
                } else {
                    opReg = asmSymbolReg(ASM_reg_id_op, 4, this.regIndex)
                }
            } else {
                inst = "cvttss2siq"
            }
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            inst, asmSymbolReg(ASM_reg_id_floats, 8, 0), opReg
        }

        if size == 1 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "movsbq", asmSymbolReg(ASM_reg_id_op, size, this.regIndex+1), asmSymbolReg(ASM_reg_id_op, size, this.regIndex)
            }
        } else if size == 2 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "movswq", asmSymbolReg(ASM_reg_id_op, size, this.regIndex+1), asmSymbolReg(ASM_reg_id_op, size, this.regIndex)
            }
        }

        return asmSymbolReg(ASM_reg_id_op, size, this.regIndex)
    }

    generateConvIntToFloat(sym asmSymbol, size uint) asmSymbol {
        this.instructions[len(this.instructions)] = asmInstruction {
            "pxor", asmSymbolReg(ASM_reg_id_floats, 8, 0), asmSymbolReg(ASM_reg_id_floats, 8, 0)
        }

        inst = "cvtsi2sdq"
        regSize = 8

        if sym.size == 8 {
            if size == 4 {
                inst = "cvtsi2ssq"
            }
        } else if sym.size == 4 {
            if size == 4 {
                inst = "cvtsi2ssl"
            } else {
                inst = "cvtsi2sdl"
            }
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            inst, sym, asmSymbolReg(ASM_reg_id_floats, 8, 0)
        }

        return asmSymbolReg(ASM_reg_id_floats, 8, 0)
    }

    generateSymOffset(sym asmSymbol, offset asmSymbol) asmSymbol {
        
        if sym.stack && sym.level == -1 && offset.isValue {
            sym.address -= strToInt(offset.name[1:])
            return sym
        }

        regName = asmSymbolReg(ASM_reg_id_return, 8, 0)
        if sym.isReg && sym.level == 0 {
            regName = sym
        } else {
            this.generateMoveValue(sym, regName)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_add[spos(sym.size)], offset, regName
        }

        return regName
    }

    generateDestSymOffset(sym asmSymbol, offset asmSymbol) asmSymbol {
        
        if sym.stack && sym.level == -1 && offset.isValue {
            sym.address -= strToInt(offset.name[1:])
            return sym
        }

        regName = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
        if sym.isReg && sym.level == 0 {
            regName = sym
        } else {
            this.generateMoveValue(sym, regName)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            ASM_add[spos(sym.size)], offset, regName
        }

        return regName
    }

    generateSelfOp(sym asmSymbol, op byte) asmSymbol {
        inst = ""

        if op == ASM_SELF_OP_ADD {
            inst = ASM_add[spos(sym.size)]
        } else if op == ASM_SELF_OP_SUB {
            inst = ASM_sub[spos(sym.size)]
        }

        if sym.level == 1 {
            tmpSym = sym
            tmpSym.level = 0
            tmpSym.size = 8
            this.generateMoveValue(tmpSym, asmSymbolReg(ASM_reg_id_op, 8, this.regIndex+1))
            retDest = asmSymbolReg(ASM_reg_id_op, sym.size, this.regIndex+1)
            retDest.level = sym.level
            sym = retDest
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            inst, asmSymbolValue("$1"), sym
        }


        return sym
    }

    generateFnStart(fnName str, arguments []asmSymbol, returnSize uint) {
        this.scope++
        this.stackOffset = 0
        
        this.instructions[len(this.instructions)] = asmInstruction {
            fnName+":"
        }
        
        this.instructions[len(this.instructions)] = asmInstruction {
            "pushq", asmSymbolReg(ASM_reg_id_base_pointer, 8, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "movq", asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0), asmSymbolReg(ASM_reg_id_base_pointer, 8, 0)
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "SET_STACK_POINTER"
        }

        offset = 0

        if returnSize > 16 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "movq", asmSymbolReg(ASM_reg_id_dest_addr, 8, 0), asmSymbolStack(16, 8)
            }

            this.stackOffset = 16
            offset = 1
        }

        this.startIndex = len(this.instructions)

        tmpSyms = []asmSymbol
        this.currentFn = fnName

        i=0; for i < len(arguments) , i++ {
            tmpSyms[len(tmpSyms)] = arguments[i]
            tmpSyms[len(tmpSyms)-1].stack = true
            tmpSyms[len(tmpSyms)-1].scope = this.scope

            valueReg = asmSymbol{}

            if arguments[i].size > 8 {
                if arguments[i].size <= 16 {
                    if i+offset >= 5 {
                        valueReg = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
                        inst = ASM_pop[spos(8)]

                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, valueReg
                        }
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, 8, i + offset)
                        valueReg.level = arguments[i].level
                    }

                    tmpSyms[len(tmpSyms)-1].address = this.generateStackAlloc(valueReg)
                    
                    offset++

                    ns = arguments[i].size - 8

                    if i+offset >= 5 {
                        valueReg = asmSymbolReg(ASM_reg_id_dest_addr, ns, 0)
                        inst = ASM_pop[spos(ns)]

                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, valueReg
                        }
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, ns, i + offset)
                        valueReg.level = arguments[i].level
                    }
                    this.generateMoveValue(valueReg, asmSymbolStack(tmpSyms[len(tmpSyms)-1].address + 8, ns))
                    
                } else {
                    offset--
                    tmpSyms[len(tmpSyms)-1].address = arguments[i].address
                }

                continue 
            }


            if i+offset >= 5 {
                valueReg = asmSymbolReg(ASM_reg_id_dest_addr, arguments[i].size, 0)
                inst = ASM_pop[spos(arguments[i].size)]

                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, valueReg
                }
            } else {
                valueReg = asmSymbolReg(ASM_reg_id_args, arguments[i].size, i + offset)
                valueReg.level = arguments[i].level
            }

            tmpSyms[len(tmpSyms)-1].address = this.generateStackAlloc(valueReg)
        }
    }

    generateFnEnd() {
        this.scope--
        if len(this.instructions) != 0 && this.instructions[len(this.instructions)-1].instruction == "ret" {
            this.flushInstructions()
            return
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "leave"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "ret"
        }

        this.flushInstructions()
    }

    generateReturn(value asmSymbol) {

        if value.size > 8 {
            if value.size <= 16 {
                    tmpArg = value
                    tmpArg.size = 8
                    valueReg = asmSymbolReg(ASM_reg_id_return, 8, 0)
                    this.generateMoveValue(tmpArg, valueReg)

                    tmpArg.size = value.size - 8

                    if tmpArg.stack == false {
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "leaq", tmpArg, asmSymbolReg(ASM_reg_id_args, 8, 2)
                        }
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "addq", asmSymbolValue("$8"), asmSymbolReg(ASM_reg_id_args, 8, 2)
                        }
                        tmpArg = asmSymbolReg(ASM_reg_id_args, 8, 2)
                        tmpArg.level = 1
                    } else {
                        tmpArg.address -= 8
                    }

                    valueReg = asmSymbolReg(ASM_reg_id_args, tmpArg.size, 2)

                    this.generateMoveValue(tmpArg, valueReg)
            } else {
                this.instructions[len(this.instructions)] = asmInstruction {
                    "movq", asmSymbolStack(16, 8), asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
                }
                dest = asmSymbolReg(ASM_reg_id_dest_addr, value.size, 0)
                dest.level = 1
                this.generateMoveValue(value, dest)
            }
        } else {
            inst = ASM_mov[spos(value.size)]
            retReg = asmSymbolReg(ASM_reg_id_return, value.size, 0)

            this.generateMoveValue(value, retReg)
        }



        this.instructions[len(this.instructions)] = asmInstruction {
            "leave"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "ret"
        }
    }

    generateEarlyReturn() {
        this.instructions[len(this.instructions)] = asmInstruction {
            "leave"
        }
        this.instructions[len(this.instructions)] = asmInstruction {
            "ret"
        }
    }

    generateFnCallStart() {
        args = []asmSymbol
        this.endSym.insert(args)
    }

    generateFnCallArgument(arg asmSymbol) {
        args = <[]asmSymbol>this.endSym.end.data


        if arg.isReg && arg.address >= ASM_reg_id_op && arg.address < ASM_reg_id_floats {
            pos = this.generateStackAlloc(arg)
            arg = asmSymbol {
                parent: this
                stack: true
                address: pos
                size: arg.size
            }
        }

        args[len(args)] = arg
    }

    generateFnCall(fnName asmSymbol, returnSize uint) asmSymbol {
        arguments = <[]asmSymbol>this.endSym.pop()

        floatN = 0
        floatTotal = 0
        returnAlloc asmSymbol
        //handle float registers
        floatRegs = []int{-1,-1,-1,-1,-1,-1,-1,-1}
        i=0; for i < len(arguments), i++ {
            if arguments[i].isFloat {
                if arguments[i].isReg {
                    regN = arguments[i].address - ASM_reg_id_floats
                    if floatTotal != regN {
                        floatRegs[regN] = i
                    }
                }
                floatTotal++
            }
        }

        i=0; for i < len(floatRegs), i++ {
            if floatRegs[i] == -1 {
                continue
            }
            j = floatRegs[i]

            arguments[j].isReg = false
            arguments[j].stack = true
            arguments[j].address = this.stackOffset

            this.stackOffset += arguments[j].size

            this.instructions[len(this.instructions)] = asmInstruction {
                ASM_mov_float[spos(arguments[j].size)], asmSymbolReg(ASM_reg_id_floats, 8, i), arguments[j]
            }

        }

        offset int = 0

        if returnSize > 16 {
            returnAlloc = this.generateVarDecl("return_addr", returnSize, false)
            this.instructions[len(this.instructions)] = asmInstruction {
                "leaq", returnAlloc, asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
            }
            offset = 1
        }

        rspOffset = 0
        i=len(arguments)-1; for i != -1, i-- {

            if arguments[i].isFloat {
                if arguments[i].isReg && arguments[i].address - ASM_reg_id_floats == (floatTotal - floatN - 1) {
                    floatN++
                    continue
                }
                
                this.instructions[len(this.instructions)] = asmInstruction {
                    ASM_mov_float[spos(arguments[i].size)], arguments[i], asmSymbolReg(ASM_reg_id_floats, 8, floatTotal - floatN - 1)
                }

                floatN++
                continue
            }

            if arguments[i].size > 8 {
                if arguments[i].size <= 16 {
                    tmpArg = arguments[i]
                    tmpArg.size = 8
                    if i+offset > 5 {
                        inst = ASM_push[spos(8)]
                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, tmpArg
                        }
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, 8, i+offset)

                        this.generateMoveValue(tmpArg, valueReg)
                    }

                    offset++
                    tmpArg.size = arguments[i].size - 8

                    if tmpArg.stack == false {
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "leaq", tmpArg, asmSymbolReg(ASM_reg_id_return, 8, 0)
                        }
                        this.instructions[len(this.instructions)] = asmInstruction {
                            "addq", asmSymbolValue("$8"), asmSymbolReg(ASM_reg_id_return, 8, 0)
                        }
                        tmpArg = asmSymbolReg(ASM_reg_id_return, tmpArg.size, 0)
                        tmpArg.level = 1
                    } else {
                        tmpArg.address -= 8
                    }
                    

                    if i+offset > 5 {
                        inst = ASM_push[spos(tmpArg.size)]
                        this.instructions[len(this.instructions)] = asmInstruction {
                            inst, tmpArg
                        }
                    } else {
                        valueReg = asmSymbolReg(ASM_reg_id_args, tmpArg.size, i+offset)

                        this.generateMoveValue(tmpArg, valueReg)
                    }

                } else {
                    offset--
                    dest = asmSymbolReg(ASM_reg_id_dest_addr, 8, 0)
                    this.instructions[len(this.instructions)] = asmInstruction {
                        "subq", asmSymbolValue("$"+uintToStr(arguments[i].size)), asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0)
                    }
                    this.generateMoveValue(asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0), dest)
                    rspOffset += arguments[i].size
                    dest.level = 1
                    this.generateMoveValue(arguments[i], dest)
                    
                    //make it dynamic for optimizer to skip its allocation
                }

                continue
            }

            if i+offset > 5 {
                inst = ASM_push[spos(arguments[i].size)]
                this.instructions[len(this.instructions)] = asmInstruction {
                    inst, arguments[i]
                }
            } else {
                valueReg = asmSymbolReg(ASM_reg_id_args, arguments[i].size, i+offset)
                this.generateMoveValue(arguments[i], valueReg)
                //TODO: move value to *reg
            }
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "call", fnName
        }

        if rspOffset != 0 {
            this.instructions[len(this.instructions)] = asmInstruction {
                "addq", asmSymbolValue("$"+uintToStr(rspOffset)), asmSymbolReg(ASM_reg_id_stack_pointer, 8, 0)
            }
        }

        if returnSize > 8 {
            if returnSize <= 16 {
                accReg = asmSymbolReg(ASM_reg_id_floats, 16, 0)
                tmpSym = this.generateVarDecl("return_addr", 16, false)
                this.instructions[len(this.instructions)] = asmInstruction {
                    "vmovq", asmSymbolReg(ASM_reg_id_return, 8, 0), accReg
                }
                this.instructions[len(this.instructions)] = asmInstruction {
                    "vmovq", asmSymbolReg(ASM_reg_id_args, 8, 2), asmSymbolReg(ASM_reg_id_floats, 16, 1)
                }
                this.instructions[len(this.instructions)] = asmInstruction {
                    "vpunpcklqdq", asmSymbolReg(ASM_reg_id_floats, 16, 1), asmSymbolValue("%xmm0, %xmm0")
                }
                this.generateMoveValue(accReg, tmpSym)

                return tmpSym
            } else {
                return returnAlloc
            }
        }

        r = asmSymbolReg(ASM_reg_id_return, returnSize, 0)

        return r
    }

    generateSyscall(arguments []asmSymbol, syscall str, returnSize uint) asmSymbol {
        i=len(arguments)-1; for i != -1, i-- {
            valueReg = asmSymbolReg(ASM_reg_id_args, arguments[i].size, i)

            this.generateMoveValue(arguments[i], valueReg)
        }

        this.instructions[len(this.instructions)] = asmInstruction {
            "int", asmSymbolValue(syscall)
        }

        return asmSymbolReg(ASM_reg_id_return, returnSize, 0)
    }
}

_asm_append_instruction(ctxPtr ptr, inst asmInstruction) {
    ctx = <asmContext*>ctxPtr
    ctx.instructions[len(ctx.instructions)] = inst
}