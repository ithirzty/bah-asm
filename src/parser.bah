#import "iostream.bah"
#import "string.bah"
#import "exec.bah"

#import "lexer.bah"
#import "cache.bah"
#import "types.bah"
#import "state.bah"
#import "error.bah"
#import "gen.bah"


const BAH_LINE_DECL_VAR   = 0
const BAH_LINE_DECL_FN    = 1
const BAH_LINE_DECL_STRCT = 2

const BAH_LINE_HASH = 3

const BAH_LINE_FLOW_IF   = 4
const BAH_LINE_FLOW_ELSE = 5
const BAH_LINE_FLOW_FOR  = 6

struct booleanHash {
    name: str
    isTrue: bool
}

BAH_boolean_hashes = []booleanHash

#define parseLines(tokens []bahToken, start uint, end uint)
#define parseLine(tokens []bahToken, start uint, end uint)
#define consumeValue(tokens []bahToken, start uint, end uint, parentStart int, opLevel uint) [bahValue*, uint]
#define parseFnBody(fn bahFunction*, tokens []bahToken, i uint, end uint)

parallelObjCompile(filePath str, outputName str, deps []str, cf cacheFile*) {
    println(ASCII_GREY+"[compiling] "+ASCII_RESET+filePath)

    compDirectory = parserCtx.currentFilePath
    i=len(compDirectory)-1; for i != -1, i-- {
        if compDirectory[i] == '/' {
            break
        }
    }
    compDirectory = compDirectory[:i+1]

    cmd = command(compilerPath+" "+filePath+" -silent -object -o "+outputName)
    err = cmd.run()

    if cmd.status != 0 {
        exit(cmd.status)
    }

    if cf == null {
        makeCacheFile(filePath, deps)
    } else {
        updateCacheFile(cf, deps)
    }
    
    compileWaitChannel.send(null)
}

includeFile(filePath str) {
    if filePath in parserCtx.parsedFiles {
        return
    }

    parserCtx.parsedFiles[len(parserCtx.parsedFiles)] = filePath

    fs = fileStream{}
    fs.open(filePath, "r")
    content = fs.readContent()
    fs.close()


    oldFilePath = parserCtx.currentFilePath 
    oldCurrFile = parserCtx.currentFile 
    oldFileNb = gen.fileNb
    oldDeclMode = parserCtx.declareMode

    if isImportFile && isObjectFile == false {
        parserCtx.declareMode = false
    } else if isObjectFile {
        parserCtx.declareMode = true
    }

    parserCtx.currentFilePath = filePath
    parserCtx.currentFile = content

    inclTokens = lexer(content, true)

    gen.generateFileLocation(parserCtx.currentFilePath)
    parseLines(inclTokens, 0, len(inclTokens))


    gen.fileNb = oldFileNb
    parserCtx.currentFilePath = oldFilePath 
    parserCtx.currentFile = oldCurrFile 
    parserCtx.declareMode = oldDeclMode

}

importFile(filePath str) {
    if parserCtx.noImports {
        includeFile(filePath)
        return
    }

    if filePath in parserCtx.parsedFiles {
        return
    }

    parserCtx.parsedFiles[len(parserCtx.parsedFiles)] = filePath


    oldFilePath = parserCtx.currentFilePath 
    oldCurrFile = parserCtx.currentFile 
    oldFileNb = gen.fileNb
    oDeclareMode = parserCtx.declareMode
    oImportDeps = parserCtx.importDeps
    oisImp = isImportFile

    fs = fileStream{}
    fs.open(filePath, "r")
    content = fs.readContent()
    fs.close()

    parserCtx.currentFilePath = filePath
    parserCtx.currentFile = content
    parserCtx.declareMode = true
    parserCtx.importDeps = []str
    isImportFile = true

    inclTokens = lexer(content, false)

    gen.generateFileLocation(parserCtx.currentFilePath)
    parseLines(inclTokens, 0, len(inclTokens))

    cf = getCacheFile(filePath)
    outputName = BAH_DIR+"cache/"+pathToVarName(filePath)

    if isObjectFile == false && isValidCacheFile(cf) == false {
        parserCtx.currentCompileNb++
        async parallelObjCompile(filePath, outputName, parserCtx.importDeps, cf)
    }

    parserCtx.libraries[len(parserCtx.libraries)] = outputName+".o"

    gen.fileNb = oldFileNb
    parserCtx.currentFilePath = oldFilePath 
    parserCtx.currentFile = oldCurrFile 
    parserCtx.declareMode = oDeclareMode
    parserCtx.importDeps = oImportDeps
    isImportFile = oisImp
}

consumeType(tokens []bahToken, start uint, end uint, isFuncDecl bool) [bahType*, uint] {
    if end - start == 0 {
        return [<bahType*>null, start]
    }

    r = new bahType

    i = start

    if isFuncDecl || tokens[i].cont == "function" {
        //function type
        r.type = BAH_TYPE_FUNC
        r.isNativePtr = true
        r.size = 8

        if isFuncDecl == false {
            i++
        }
        
        if i+1 >= end {
            throwErrorTok(&tokens[start], "Invalid function type.")
        }
        if tokens[i].cont != "(" {
            throwErrorTok(&tokens[i], "Expected function argument list.")
        }

        i++
        lastElem = r
        for i < end, i++ {
            if tokens[i].cont == ")" {
                break
            }

            if tokens[i].type != TOKEN_TYPE_VAR {
                throwErrorTok(&tokens[i], "Expected argument name.")
            }

            name = ""

            if isFuncDecl {
                name = tokens[i].cont

                i++

                if i == end {
                    throwErrorTok(&tokens[i-1], "Expected argument type after its name.")
                }
                
            }
            
            consArgType = consumeType(tokens, i, end, false)
            

            if consArgType[0] == null {
                throwErrorTok(&tokens[i], "Invalid argument type.")
            }
            argType bahType*

            if consArgType[0].type == BAH_TYPE_STRCT || consArgType[0].type == BAH_TYPE_CUSTOM_TYPE {
                argType = new bahType
                *argType = *(consArgType[0])
            } else {
                argType = consArgType[0]
            }

            argType.name = name
                
            
            i = consArgType[1]

            if i == end {
                throwErrorTok(&tokens[i-1], "Incomplete function type.")
            }

            if lastElem == r {
                lastElem.child = argType
            } else {
                lastElem.next = argType
            }
            lastElem = argType

            if tokens[i].cont != "," {
                break
            }
        }

        if i == end {
            throwErrorTok(&tokens[start], "Expected closing function type.")
        }

        if tokens[i].cont != ")" {
            throwErrorTok(&tokens[i], "Expected closing argument list in function type.")
        }
        i++

        retTypeCons = consumeType(tokens, i, end, false)
        if retTypeCons[0] != null {
            r.ret = retTypeCons[0]
            i = retTypeCons[1]
        }

    } else if tokens[i].cont == "[" && i+1 < end {
        if tokens[i+1].cont == "]" {
            //array type
            i += 2
            r.type = BAH_TYPE_ARRAY
            r.isNativePtr = true
            r.size = 8
            childCons = consumeType(tokens, i, end, false)
            if childCons[0] == null {
                throwErrorTok(&tokens[start], "Invalid array type without element type.")
            }
            i = childCons[1]
            r.child = childCons[0]
        } else {
            //tuple type

            r.type = BAH_TYPE_TUPLE
            
            currTp = r

            i++
            for i < end, i++ {
                tp = consumeType(tokens, i, end-1, false)

                if tp[0] == null {
                    throwErrorTok(&tokens[i], "Invalid type.")
                }

                otp = tp[0]
                tp[0] = new bahType
                *tp[0] = *otp
                tp[0].next = null

                if currTp == r {
                    currTp.child = tp[0]
                } else {
                    currTp.next = tp[0]
                }
                tp[0].offset = r.size
                r.size += tp[0].size


                currTp = tp[0]
                
                i = tp[1]

                if tokens[i].cont != "," {
                    break
                }
            }

            if tokens[i].cont != "]" {
                throwErrorTok(&tokens[i], "Expected closing tuple type.")
            }

            i++
        }
    } else {
        if tokens[i].type == TOKEN_TYPE_VAR {
            if tokens[i].cont == "float" {
                r.type = BAH_TYPE_FLOAT
                r.size = 8
            } else if tokens[i].cont == "float32" {
                r.type = BAH_TYPE_FLOAT
                r.size = 4
            } else if tokens[i].cont == "int16" {
                r.type = BAH_TYPE_INT
                r.size = 2
            } else if tokens[i].cont == "int32" {
                r.type = BAH_TYPE_INT
                r.size = 4
            } else if tokens[i].cont == "int" {
                r.type = BAH_TYPE_INT
                r.size = 8
            } else if tokens[i].cont == "byte" || tokens[i].cont == "char" {
                r.type = BAH_TYPE_UINT
                r.size = 1
            } else if tokens[i].cont == "uint16" {
                r.type = BAH_TYPE_UINT
                r.size = 2
            } else if tokens[i].cont == "uint32" {
                r.type = BAH_TYPE_UINT
                r.size = 4
            } else if tokens[i].cont == "uint" {
                r.type = BAH_TYPE_UINT
                r.size = 8
            } else if tokens[i].cont == "str" {
                r.type = BAH_TYPE_STR
                r.isNativePtr = true
                r.size = 8
            } else if tokens[i].cont == "bool" {
                r.type = BAH_TYPE_BOOL
                r.size = 1
            } else if tokens[i].cont == "ptr" {
                r.type = BAH_TYPE_PTR
                r.size = 8
                r.isNativePtr = true
            } else {
                r = parserCtx.findType(tokens[i].cont)
                if r == null {
                    return [<bahType*>null, i]
                }
            }

            i++
            for i < end, i++ {
                if tokens[i].cont != "*" {
                    break
                }
                r = r.getPtr()
            }
        } else if tokens[i].type == TOKEN_TYPE_KEYWORD {
            if tokens[i].cont == "buffer" {
                r.type = BAH_TYPE_BUFFER
                if i+2 >= end || tokens[i+1].cont != ":" || tokens[i+2].type != TOKEN_TYPE_INT {
                    throwErrorTok(&tokens[i], "Invalid buffer type. Expected buffer:size")
                }
                r.size = strToInt(tokens[i+2].cont)
                i += 3

            }
        } else {

            return [<bahType*>null, i]
        }
    }

    return [r, i]
}

consumeLeftValue(tokens []bahToken, start uint, end uint) [bahLeftValue*, uint, bool] {

    if start == end {
        return [<bahLeftValue*>null, start, false]
    }

    //handle dereference etc and fn call in dereference

    v bahVariable*

    t = tokens[start]

    if t.cont == "*" {
        if start + 1 == end {
            throwErrorTok(&t, "Expected a symbol after unary '*'.")
        }

        valCons = consumeLeftValue(tokens, start + 1, end)
        if valCons[0] == null {
            throwErrorTok(&tokens[start+1], "Expected left-value.")
        }

        i = valCons[1]
        varVal = valCons[0]

        if valCons[2] {
            throwErrorTok(&varVal.tok, "Cannot use not yet declared variable.")
        }

        if varVal.type.isPtr == false {
            throwErrorTok(&varVal.tok, "Cannot set the value of a non pointer symbol.")
        }


        val = new bahLeftValue {
            isUnary: true
            left: varVal
            tok: t
            type: varVal.type.child
        }

        return [val, i, false]
    }

    if t.type == TOKEN_TYPE_VAR {
        v = parserCtx.findVar(t.cont)
        isDeclared = v == null
        if isDeclared {
            val = new bahLeftValue {
                isVariable: true
                tok: t
            }
            return [val, start+1, true]
        }

        if parserCtx.scope != 0 && v.scope == 0 && parserCtx.scopeCtx.currentFunction.type.isFlagSet(BAH_TYPE_FLAG_PURE) {
            parserCtx.scopeCtx.currentFunction.type.toggleFlag(BAH_TYPE_FLAG_PURE)
        }
    }

    if v == null {
        //try by addressing
        rbCons = consumeValue(tokens, start, end, start, 0)
        if rbCons[0] == null {
            return [<bahLeftValue*>null, start+1, false]
        }

        val = new bahLeftValue {
            tok: tokens[start]
            isByAddress: true
            type: rbCons[0].type
            index: rbCons[0]
        }

        return [val, rbCons[1]+1, false]
    }

    if v.isConst {
        throwErrorTok(&t, "Cannot set the value of a constant.")
    }

    val = new bahLeftValue {
        tok: tokens[start]
        isVariable: true
        variable: v
        type: v.type
    }

    i = start+1
    for i < end, i++ {
        if tokens[i].cont == "." {
            if (val.type.isPtr == false && val.type.type != BAH_TYPE_STRCT) || (val.type.isPtr == true && val.type.child.type != BAH_TYPE_STRCT) {
                throwErrorTok(&tokens[i], "Cannot access member of a non structure value.")
            }

            parentVal = val
            val = new bahLeftValue {
                left: parentVal
                isStruct: true
            }
            i++
            if tokens[i].type != TOKEN_TYPE_VAR {
                throwErrorTok(&tokens[i], "Invalid member identifier.")
            }
            currTp bahType*
            if val.left.type.isPtr {
                currTp = val.left.type.child.child.next
            } else {
                currTp = val.left.type.child.next
            }

            for currTp != null, currTp = currTp.next {
                if currTp.name == tokens[i].cont {
                    break
                }
            }

            if currTp == null {
                throwErrorTok(&tokens[i], "Unknown structure member.")
            }

            membVal = new bahLeftValue {
                tok: tokens[i]
                type: currTp
            }
            val.type = currTp

            val.right = membVal
        } else if tokens[i].cont == "[" {
            if i + 2 >= end {
                throwErrorTok(&tokens[start+1], "Missing index value.")
            }
            arrStart = i
            nbEncl = 1
            brackEnd = end-1
            i++
            for i < end, i++ {
                t = tokens[i]
                if t.type != TOKEN_TYPE_ENCL {
                    continue
                }
                
                if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                    nbEncl++
                } else {
                    if nbEncl == 0 {
                        throwErrorTok(&t, "One too many token.")
                    }
                    nbEncl--
                    if nbEncl == 0 {
                        brackEnd = i
                        break
                    }
                    continue
                }
                
            }

            r = consumeValue(tokens, arrStart+1, brackEnd+1, arrStart, 0)
            
            if r[0] == null {
                throwErrorTok(&tokens[start+2], "Expected value as index.")
            }

            parentVal = val

            if parentVal.type.type == BAH_TYPE_BUFFER {
                val = new bahLeftValue {
                    isBuffer: true
                    left: parentVal
                    index: r[0]
                }
                val.type = new bahType {
                    size: 1
                    type: BAH_TYPE_UINT
                }
            } else if parentVal.type.type == BAH_TYPE_ARRAY {
                val = new bahLeftValue {
                    isArray: true
                    left: parentVal
                    index: r[0]
                    type: parentVal.type.child
                }
            } else if parentVal.type.type == BAH_TYPE_TUPLE {
                
                if r[0].isStaticValue == false {
                    throwError(r[0], "Cannot index a tuple by non static value.")
                }

                indexSym = generateBahValueSymbol(r[0], null)
                indexVal = strToInt(indexSym.name[1:])

                if indexVal < 0 {
                    throwError(r[0], "Index cannot be less than 0.")
                }

                index = 0
                currTp = val.type.child
                for index < indexVal, index++ {
                    if currTp == null {
                        break
                    }

                    currTp = currTp.next
                }

                if currTp == null {
                    throwError(r[0], "Cannot access tuple's value of index larger than its length.")
                }

                val = new bahLeftValue {
                    isTuple: true
                    left: parentVal
                    index: r[0]
                    type: currTp
                }
            } else {
                throwErrorTok(&tokens[arrStart+1], "Cannot use lvalue as indexable symbol.")
            }

        
            if parentVal.type.isPtr {
                throwErrorTok(&val.tok, "Cannot use a pointer as indexable symbol.")
            }

            if parentVal.type.type == BAH_TYPE_STR {
                throwErrorTok(&val.tok, "Cannot set the value of a str by index.")
            }
            
            //handle buffers and maps
        } else {
            break
        }
    }

    //handle arrays, structs...

    return [val, i, false]
}

recursiveStructDeclaration(st bahType*) bahValue* {
    currTp = st.child
    val = new bahValue {
        value: BAH_VALUE_DECLARATION
        type: st
    }
    for currTp != null, currTp = currTp.next {
        defVal = <bahValue*>currTp.defaultValue

        if defVal == null {
            if currTp.type == BAH_TYPE_ARRAY {
                defVal = new bahValue {
                    value: BAH_VALUE_DECLARATION
                }
                defVal.type = new bahType {
                    type: BAH_TYPE_ARRAY
                    size: ARR_TYPE_SIZE
                    isNativePtr: true
                    child: currTp.child
                }
            } else if currTp.type == BAH_TYPE_STRCT {
                defVal = recursiveStructDeclaration(currTp)
            } else {
                continue
            }
        }

        currVal = val.left
        val.left = new bahValue {
            type: currTp
            right: defVal
            left: currVal
        }
    }

    return val
}

consumeValue(tokens []bahToken, start uint, end uint, parentStart int, opLevel uint) [bahValue*, uint] {

    i = start
    nbPar = 0
    parStart = start




    if parentStart != -1 {
        nbEncl = 0
        for start >= parentStart, start-- {
            t = tokens[start]
            if t.type == TOKEN_TYPE_ENCL {
                if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                    nbEncl--

                    continue
                }
                nbEncl++
            }

            if nbEncl == 0 && (t.cont == "," || t.cont == "=") {
                break
            }
        }
        start++

        isArrayDeclare = start+2 < end && tokens[start].cont == "[" && tokens[start+1].cont == "]" && (tokens[start+2].type == TOKEN_TYPE_VAR || tokens[start+2].cont == "["  || tokens[start+2].type == TOKEN_TYPE_KEYWORD)

        if isArrayDeclare == false && tokens[start].type == TOKEN_TYPE_ENCL {
            start++
            end--
        }

        r = consumeValue(tokens, start, end, -1, 0)

        if isArrayDeclare {
            r[1]--
        } else if tokens[start].type == TOKEN_TYPE_ENCL {
            r[1]++
        }

        if r[0].value == BAH_VALUE_OP {
            r[0].pemdas = 5
        }

        return r
    }

    val = new bahValue
    consumedVal = false

    if tokens[start].cont == "(" {
        // tokens[end-1].cont == ")"
        nbEncl = 1
        parEnd = end-1
        i = start+1; for i < end, i++ {
            t = tokens[i]
            if t.type != TOKEN_TYPE_ENCL {
                continue
            }
            
            if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                nbEncl++
            } else {
                if nbEncl == 0 {
                    throwErrorTok(&t, "One too many token.")
                }
                nbEncl--
                if nbEncl == 0 {
                    parEnd = i
                    break
                }
                continue
            }
            
        }

        moreThanThis = false
        i++
        for i < end, i++ {
            if tokens[i].cont == "," || tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" || tokens[i].cont == "."  {
                break
            }
            if tokens[i].cont != ")" && tokens[i].cont != "]" && tokens[i].cont != "}" {
                moreThanThis = true
                break
            }
        }


        if moreThanThis == false {
            r = consumeValue(tokens, start+1, parEnd, parentStart, 0)
            
            if r[0].value == BAH_VALUE_OP {
                r[0].pemdas = 5
            }

            if r[1] + 1 == end || tokens[r[1] + 1].cont == "," {
                r[1]++
                return r
            }

            start = r[1]
            val = r[0]
            consumedVal = true
            opLevel = 5
        }

    }

    if opLevel == 5 {
        t = tokens[start]


        if consumedVal == false {

            if t.type == TOKEN_TYPE_CAST {
                castToks = lexer(t.cont[1:len(t.cont)-1], true)
                typeCons = consumeType(castToks, 0, len(castToks), false)
                if typeCons[1] != len(castToks) || typeCons[0] == null {
                    throwErrorTok(&t, "Invalid cast type.")
                }

                nvCons = consumeValue(tokens, start+1, end, parentStart, opLevel)

                if nvCons[0] == null {
                    throwErrorTok(&tokens[start], "Missing value after type cast.")
                }

                tp = typeCons[0]
                val.value = BAH_VALUE_CAST
                val.tok = t

                val.type = typeCons[0]
                val.left = nvCons[0]

                return [val, nvCons[1]]
            }

            if t.cont == "new" || (t.type == TOKEN_TYPE_VAR && i+1 < end && tokens[i+1].cont == "{") {
                st bahType*

                val.tok = tokens[i]

                if t.cont == "new" {
                    st = parserCtx.findType(tokens[i+1].cont)
                    i++
                } else {
                    st = parserCtx.findType(t.cont)
                }

                if st == null {
                    throwErrorTok(&tokens[i], "Unknown structure.")
                }
                currTp = st.child

                val.value = BAH_VALUE_DECLARATION
                val.type = st
                currVal = val

                i += 2
                nbBraces uint = 1
                for i < end, i++ {
                    if tokens[i].cont == "{" {
                        nbBraces++
                    } else if tokens[i].cont == "}" {
                        nbBraces--
                        if nbBraces == 0 {
                            break
                        }
                    }


                    //field: value
                    if i+2 < end && tokens[i+1].cont == ":" {
                        if tokens[i].type != TOKEN_TYPE_VAR {
                            throwErrorTok(&tokens[i], "Expected field name.")
                        }
                        nameTok = tokens[i]
                        currTp = st.child.next
                        for currTp != null, currTp = currTp.next {
                            if currTp.name == nameTok.cont {
                                break
                            }
                        }

                        if currTp == null {
                            throwErrorTok(&tokens[i], "Unknown field name in structure declaration.")
                        }
                        i += 2
                        currLine = nameTok.line
                        nbEncls = 0
                        j=i; for j < end, j++ {
                            if tokens[j].cont == "(" || tokens[j].cont == "[" || tokens[j].cont == "{" {
                                nbEncls++
                            } else if tokens[j].cont == ")" || tokens[j].cont == "]" || tokens[j].cont == "}" {
                                nbEncls--
                            }

                            if nbEncls > 0 {
                                currLine = tokens[j].line
                                continue
                            }

                            if tokens[j].line != currLine {
                                if tokens[j].begLine == currLine {
                                    currLine = tokens[j].line
                                    continue
                                }

                                break
                            }
                        }

                        if j == end {
                            j--
                        }

                        valCons = consumeValue(tokens, i, j, i, 0)
                        if valCons[0] == null {
                            throwErrorTok(&tokens[i], "Expected value.")
                        }

                        i = valCons[1] - 1
                        if i < j-1 {
                            throwErrorTok(&tokens[i], "Did not expect anything after field value.")
                        }
                        fieldVal = valCons[0]
                        if compatibleTypes(currTp, fieldVal.type) == false {
                            throwTypeError(fieldVal, currTp)
                        }

                        currVal.left = new bahValue {
                            tok: nameTok
                            type: currTp
                        }
                        currVal.left.right = fieldVal
                        currVal = currVal.left
                        
                    } else { //value, value
                        currTp = currTp.next

                        if currTp == null {
                            throwErrorTok(&tokens[i], "Unknown field position in structure declaration.")
                        }
                        valCons = consumeValue(tokens, i, end-1, i, 0)
                        if valCons[0] == null {
                            throwErrorTok(&tokens[i], "Expected value.")
                        }

                        i = valCons[1]
                        fieldVal = valCons[0]
                        if compatibleTypes(currTp, fieldVal.type) == false {
                            throwTypeError(fieldVal, currTp)
                        }

                        currVal.left = new bahValue {
                            tok: fieldVal.tok
                            type: currTp
                        }
                        currVal.left.right = fieldVal
                        currVal = currVal.left

                        if tokens[i].cont != "," {
                            if tokens[i].cont == "}" {
                                break
                            }
                            throwErrorTok(&tokens[i], "Expected separator between values.")
                        }
                    }

                }

                currTp = st.child
                for currTp != null, currTp = currTp.next {
                    defVal = <bahValue*>currTp.defaultValue

                    if defVal == null {
                        if currTp.type == BAH_TYPE_ARRAY {
                            defVal = new bahValue {
                                value: BAH_VALUE_DECLARATION
                            }
                            defVal.type = new bahType {
                                type: BAH_TYPE_ARRAY
                                size: ARR_TYPE_SIZE
                                isNativePtr: true
                                child: currTp.child
                            }
                        } else if currTp.type == BAH_TYPE_STRCT {
                            defVal = recursiveStructDeclaration(currTp)
                        } else {
                            continue
                        }
                    }

                    currVal = val.left
                    for currVal != null, currVal = currVal.left {
                        if currVal.tok.cont == currTp.name {
                            break
                        }
                    }

                    if currVal == null {
                        currVal = val.left
                        val.left = new bahValue {
                            type: currTp
                            right: defVal
                            left: currVal
                        }
                    }
                } 


                if t.cont == "new" {
                    val.type = val.type.getPtr()
                }

                return [val, i+1]
            }

            if t.cont == "buffer" {
                if i+1 == end || tokens[i+1].type != TOKEN_TYPE_INT {
                    throwErrorTok(&tokens[i], "Expected buffer length after buffer keyword.")
                }

                val.value = BAH_VALUE_DECLARATION
                val.type = new bahType {
                    type: BAH_TYPE_BUFFER
                    size: strToInt(tokens[i+1].cont)
                    isNativePtr: true
                }

                return [val, i+2]
            }

            if t.cont == "[" && i+2 < end && tokens[i+1].cont == "]" {
                tp = consumeType(tokens, i+2, end, false)

                if tp[0] == null {
                    throwErrorTok(&tokens[i+2], "Unknown array element type.")
                }

                i = tp[1]

                val.value = BAH_VALUE_DECLARATION
                val.tok = t
                val.type = new bahType {
                    type: BAH_TYPE_ARRAY
                    size: ARR_TYPE_SIZE
                    isNativePtr: true
                    child: tp[0]
                }

                if i < end && tokens[i].cont == "{" {
                    nbBraces uint = 1
                    i++
                    currVal = val
                    
                    for i < end, i++ {
                        if tokens[i].cont == "{" {
                            nbBraces++
                        } else if tokens[i].cont == "}" {
                            nbBraces--
                            if nbBraces == 0 {
                                break
                            }
                        }

                        valCons = consumeValue(tokens, i, end-1, i, 0)

                        if valCons[0] == null {
                            throwErrorTok(&tokens[i], "Cannot use as value.")
                        }

                        if compatibleTypes(valCons[0].type, val.type.child) == false {
                            throwTypeError(valCons[0], val.type.child)
                        }

                        i = valCons[1]

                        currVal.right = new bahValue {
                            left: valCons[0]
                        }
                        currVal = currVal.right

                        if i < end && tokens[i].cont != "," && tokens[i].cont != "}" {
                            throwErrorTok(&tokens[i], "Expected coma between values.")
                        }

                    }

                    
                }

                return [val, i+1]
            }

            if t.cont == "[" && i + 2 < end {
                val.type = new bahType {
                    type: BAH_TYPE_TUPLE
                }

                val.value = BAH_VALUE_DECLARATION
                val.tok = t

                currVal = val
                currTp = val.type
                i++
                for i < end, i++ {

                    elemVal = consumeValue(tokens, i, end-1, start+1, 0)


                    if elemVal[0] == null {
                        throwErrorTok(&tokens[i], "Expected a value inside tuple declaration.")
                    }

                    elemType = new bahType
                    *elemType = *(elemVal[0].type)
                    elemType.next = null

                    if currTp == val.type {
                        currTp.child = elemType
                    } else {
                        currTp.next = elemType
                    }
                    currTp = elemType

                    //todo: alignment?
                    elemType.offset = val.type.size
                    val.type.size += elemType.size

                    currVal.left = new bahValue {
                        right: elemVal[0]
                    }
                    currVal = currVal.left

                    i = elemVal[1]

                    if tokens[i].cont != "," {
                        break
                    }
                }

                i++
                return [val, i]
            }

            if t.cont == "&" {
                if start+1 == end {
                    throwErrorTok(&t, "Expected a symbol to get pointer from.")
                }
                valCons = consumeValue(tokens, start + 1, end, parentStart, opLevel)
                i = valCons[1]

                if valCons[0] == null {
                    throwErrorTok(&tokens[start+1], "Expected addressable value.")
                }

                varVal = valCons[0]

                // if varVal.isVariable == false {
                //     throwError(&varVal.tok, "Cannot get pointer of anything other than a variable.")
                // }

                nt = valCons[0].type.getPtr()

                *val = *varVal
                val.type = nt
                val.isPointer = true

                return [val, i]

            }
            
            if t.cont == "*" {
                if start+1 == end {
                    throwErrorTok(&t, "Expected a symbol to access value from pointer.")
                }
                valCons = consumeValue(tokens, start + 1, end, parentStart, opLevel)
                i = valCons[1]

                if valCons[0] == null {
                    throwErrorTok(&tokens[start+1], "Expected value as an address.")
                }

                varVal = valCons[0]

                if valCons[0].type.isPtr == false {
                    throwError(varVal, "Cannot access value of a non-pointer type.")
                }

                nt = valCons[0].type.child

                val.type = nt
                val.value = BAH_VALUE_UNARY
                val.left = varVal

                return [val, i]
            }

            if t.cont == "~" {
                if start+1 == end {
                    throwErrorTok(&t, "Expected a symbol to not.")
                }
                valCons = consumeValue(tokens, start + 1, end, parentStart, opLevel)
                i = valCons[1]

                if valCons[0] == null {
                    throwErrorTok(&tokens[start+1], "Expected value.")
                }

                varVal = valCons[0]

                if valCons[0].type.type != BAH_TYPE_UINT && valCons[0].isStaticValue == false  {
                    throwError(varVal, "Cannot not a value that is not of type uint/byte.")
                }

                val.type = varVal.type
                val.value = BAH_VALUE_NOT
                val.left = varVal

                return [val, i]
            }
            
            if t.isValue == false {
                throwErrorTok(&t, "Value expected.")
            }

            val.tok = t

            if t.type == TOKEN_TYPE_VAR {
                if t.cont[0] == '$' {
                    val.value = BAH_VALUE_REG
                    val.type = new bahType {
                        size: 8
                        type: BAH_TYPE_UINT
                    }
                } else {
                    v = parserCtx.findVar(t.cont)

                    if v != null {
                        val.value = BAH_VALUE_VAR
                        val.type = v.type
                        val.sym = v.sym

                        if parserCtx.scope != 0 && v.scope == 0 && parserCtx.scopeCtx.currentFunction.type.isFlagSet(BAH_TYPE_FLAG_PURE) {
                            parserCtx.scopeCtx.currentFunction.type.toggleFlag(BAH_TYPE_FLAG_PURE)
                        }

                    } else {
                        fn = parserCtx.findFunc(t.cont)
                        if fn != null {
                            val.value = BAH_VALUE_FUNC_SYM
                            val.type = fn.type
                            val.isStaticValue = true
                        } else {
                            throwErrorTok(&t, "Unknown symbol.")
                        }
                    }
                }
            } else if t.type == TOKEN_TYPE_BOOL {
                val.type = new bahType {
                    size: 1
                    type: BAH_TYPE_BOOL
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_INT {
                val.type = new bahType {
                    size: 8
                    type: BAH_TYPE_INT
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_FLOAT {
                val.type = new bahType {
                    size: 8
                    type: BAH_TYPE_FLOAT
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_STR {
                val.type = new bahType {
                    size: 8
                    type: BAH_TYPE_STR
                    isNativePtr: true
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_CHAR {
                val.type = new bahType {
                    size: 1
                    type: BAH_TYPE_UINT
                }
                val.isStaticValue = true
            } else {
                val = null
            }

            if end - start == 1 || tokens[start+1].type == TOKEN_TYPE_SYNTAX || tokens[start+1].cont == ")" || tokens[start+1].cont == "]" || tokens[start+1].cont == "}" {
                return [val, start + 1]
            }

            if val == null {
                throwErrorTok(&t, "Expected a value.")
            }
        }

        for start < end {
            if tokens[start+1].cont == "(" && tokens[start].cont != "*" {
                if val.type.type != BAH_TYPE_FUNC {
                    throwErrorTok(&t, "Cannot use symbol as function.")
                }


                if tokens[start].cont == "sizeof" {
                    tp = consumeType(tokens, start+2, end, false)
                    i = tp[1]

                    if tp[0] == null {
                        throwErrorTok(&tokens[start+2], "Unknown type.")
                    }

                    val.isStaticValue = true
                    val.value = 0
                    val.sym = gen.staticInt(uintToStr(tp[0].size))
                    val.type = new bahType {
                        type: BAH_TYPE_UINT
                        size: 8
                    }

                    if tokens[i].cont != ")" {
                        throwErrorTok(&tokens[start+3], "Sizeof can only take one argument.")
                    }

                    
                    start = i
                    continue
                }

                fnSymVal = val
                val = new bahValue
                val.value = BAH_VALUE_FUNC_CALL
                val.left = fnSymVal
                val.tok = fnSymVal.tok
                val.type = fnSymVal.type.ret

                if parserCtx.scope != 0 {
                    if (fnSymVal.tok.cont == "exit" || fnSymVal.tok.cont == "panic" || fnSymVal.type.isFlagSet(BAH_TYPE_FLAG_EXIT)) && hasScopeAreturn(parserCtx.scopeCtx) == false {
                        parserCtx.scopeCtx.setState(BAH_SCOPE_EXITTED)
                    } else if (fnSymVal.tok.cont == "memoryRealloc" || fnSymVal.tok.cont == "realloc" || fnSymVal.type.isFlagSet(BAH_TYPE_FLAG_REALLOC)) && hasScopeAreturn(parserCtx.scopeCtx) == false {
                        parserCtx.scopeCtx.setState(BAH_SCOPE_REALLOC)
                    } else 
                    if parserCtx.scopeCtx.currentFunction.type.isFlagSet(BAH_TYPE_FLAG_PURE) {
                        if fnSymVal.type.isFlagSet(BAH_TYPE_FLAG_PURE) == false {
                            parserCtx.scopeCtx.currentFunction.type.toggleFlag(BAH_TYPE_FLAG_PURE)
                        } else {
                            calledFn = parserCtx.findFunc(fnSymVal.tok.cont)
                            if calledFn != null && calledFn.name != parserCtx.scopeCtx.currentFunction.name {
                                parserCtx.scopeCtx.currentFunction.pureCalls[len(parserCtx.scopeCtx.currentFunction.pureCalls)] = calledFn
                            }
                        }
                    }
                }

                currArg = fnSymVal.type.child
                currArgVal = val


                i = start + 2
                nbPar = 1

                if val.left.value == BAH_VALUE_STRUCT && val.left.type.child != null && val.left.type.child.isPtr && (val.left.left.type.isPtr && compatibleTypes(val.left.left.type, val.left.type.child) || val.left.left.type.isPtr == false && compatibleTypes(val.left.left.type, val.left.type.child.child)) {
                    currArg = currArg.next
                }


                for i < end, i++ {
                    if tokens[i].cont == ")" {
                        break
                    }

                    argCons = consumeValue(tokens, i, end, -1, 0)
                    i = argCons[1]


                    if argCons[0] == null {
                        throwErrorTok(&tokens[i], "Expected value as argument in function call.")
                    }

                    if currArg == null {
                        throwError(argCons[0], "Too many arguments in function call.")
                    }

                    if currArg.type == BAH_TYPE_STRCT && currArg.child.name == "reflectElement" && (argCons[0].type.type != BAH_TYPE_STRCT || argCons[0].type.child.name != "reflectElement") {
                        currArgVal.right = new bahValue {
                            value: BAH_VALUE_REFLECT
                            left: argCons[0]
                            type: currArg
                        }
                    } else {
                        if argCons[0].type.type == BAH_TYPE_ARRAY && currArg.isPtr && currArg.child.type == BAH_TYPE_STRCT && currArg.child.child.name == "Bah_Array_Type" {
                            argCons[0].type = currArg
                        } else if compatibleTypes(argCons[0].type, currArg) == false {
                            if argCons[0].type.type != BAH_TYPE_STR || currArg.isPtr == false || currArg.child.type != BAH_TYPE_UINT || currArg.child.size != 1 {
                                throwTypeError(argCons[0], currArg)
                            }
                        }

                        currArgVal.right = new bahValue {
                            value: BAH_VALUE_ARGS
                            left: argCons[0]
                            type: currArg
                        }
                    }

                    currArgVal = currArgVal.right
                    currArg = currArg.next

                    if i == end {
                        throwErrorTok(&t, "Missing end of function call.")
                    }

                    if tokens[i].cont != "," && tokens[i].cont != ")" {
                        throwErrorTok(&tokens[i], "Expected separator between arguments in function call.")
                    } else if tokens[i].cont == ")" {
                        i--
                    }

                }

                if currArg != null {
                    throwErrorTok(&tokens[i], "Missing arguments.")
                }

                start = i
            } else if tokens[start+1].cont == "[" {
                //TODO: handle splits and others (value1 : value2)
                if start + 3 >= end {
                    throwErrorTok(&tokens[start+1], "Missing index value.")
                }

                nbEncl = 1
                brackEnd = end-1
                splitIndex = -1
                i = start+2; for i < end, i++ {
                    t = tokens[i]
                    if t.type != TOKEN_TYPE_ENCL {
                        if t.cont == ":" {
                            splitIndex = i
                        }
                        continue
                    }
                    
                    if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                        nbEncl++
                    } else {
                        if nbEncl == 0 {
                            throwErrorTok(&t, "One too many token.")
                        }
                        nbEncl--
                        if nbEncl == 0 {
                            brackEnd = i
                            break
                        }
                        continue
                    }
                    
                }

                if splitIndex != -1 {
                    left bahValue* = null
                    right bahValue* = null

                    if splitIndex > start + 2 {
                        leftCons = consumeValue(tokens, start+2, splitIndex, parentStart, 0)
                        left = leftCons[0]
                        if left == null {
                            throwErrorTok(&tokens[start+2], "Expected value as begining index.")
                        }
                    }

                    if splitIndex+1 < brackEnd {
                        rightCons = consumeValue(tokens, splitIndex+1, brackEnd, parentStart, 0)
                        right = rightCons[0]
                        if right == null {
                            throwErrorTok(&tokens[splitIndex+1], "Expected value as length.")
                        }
                    }

                    if val.type.type != BAH_TYPE_ARRAY && val.type.type != BAH_TYPE_STR {
                        throwError(val, "Cannot use symbol as indexable type.")
                    }

                    val = new bahValue {
                        tok: val.tok
                        value: BAH_VALUE_SPLIT
                        left: val
                        type: val.type
                    }

                    val.right = new bahValue {
                        left: left
                        right: right
                    }

                } else {
                    r = consumeValue(tokens, start+2, brackEnd, parentStart, 0)
                    
                    if r[0] == null {
                        throwErrorTok(&tokens[start+2], "Expected value as index.")
                    }
                
                    nt = val.type

                    if val.type.isPtr {
                        throwError(val, "Cannot use a pointer as indexable symbol.")
                    }

                    if val.type.type == BAH_TYPE_TUPLE {

                        if r[0].isStaticValue == false {
                            throwError(r[0], "Cannot index a tuple by non static value.")
                        }

                        indexSym = generateBahValueSymbol(r[0], null)
                        indexVal = strToInt(indexSym.name[1:])

                        if indexVal < 0 {
                            throwError(r[0], "Index cannot be less than 0.")
                        }

                        index = 0
                        currTp = val.type.child
                        for index < indexVal, index++ {
                            if currTp == null {
                                break
                            }

                            currTp = currTp.next
                        }

                        if currTp == null {
                            throwErrorTok(&tokens[start+2], "Cannot access tuple's value of index larger than its length.")
                        }

                        val = new bahValue {
                            tok: val.tok
                            value: BAH_VALUE_INDEXED
                            left: val
                            right: r[0]
                            type: currTp
                        }

                    } else {
                        if val.type.type == BAH_TYPE_STR || val.type.type == BAH_TYPE_BUFFER {
                            nt = new bahType {
                                type: BAH_TYPE_UINT
                                size: 1
                            }
                        } else if val.type.type == BAH_TYPE_ARRAY {
                            nt = val.type.child
                        } else {
                            throwError(val, "Cannot use symbol as indexable type.")
                        }

                        varSym = val
                        val = new bahValue {
                            tok: varSym.tok
                            value: BAH_VALUE_INDEXED
                            left: varSym
                            right: r[0]
                            type: nt
                        }
                    }
                }

                start = i
            } else if tokens[start+1].cont == "." {
                if (val.type.isPtr == false && val.type.type != BAH_TYPE_STRCT) || (val.type.isPtr && val.type.child.type != BAH_TYPE_STRCT) {
                    throwError(val, "Cannot access the member of a value that is not a structure.")
                }

                i = start + 2

                memb = new bahValue {
                    tok: tokens[i]
                }
                
                currTp bahType*

                if val.type.isPtr {
                    currTp = val.type.child.child.next
                } else {
                    currTp = val.type.child.next
                }

                for currTp != null, currTp = currTp.next {
                    if currTp.name == tokens[i].cont {
                        break
                    }
                }

                if currTp == null {
                    strctType = val.type
                    if val.type.isPtr {
                        strctType = val.type.child
                    }

                    // method = parserCtx.findFunc(strctType.child.name+"."+tokens[i].cont)
                    method = parserCtx.findMethod(strctType, tokens[i].cont)
                    if method == null {
                        throwErrorTok(&tokens[i], "Unknown struct member.")
                    }

                    memb.value = BAH_VALUE_FUNC_SYM
                    memb.sym = asmSymbolValue(method.name)
                    memb.sym.level = -1
                    memb.sym.size = 8
                    val = new bahValue {
                        value: BAH_VALUE_STRUCT
                        left: val
                        right: memb
                        type: method.type
                        tok: tokens[start+1]
                    }

                } else {
                    memb.type = currTp
                    varSym = val
                    val = new bahValue {
                        value: BAH_VALUE_STRUCT
                        left: varSym
                        right: memb
                        type: memb.type
                        tok: tokens[start+1]
                    }
                }


                start = i
            } else {
                break
            }
        }

        // if val.isOperation {
        //     printDebugContext()

        // }

        return [val, start+1]

        //handle arrays, structs..
        //in else statement

    }

    for i < end, i++ {
        if tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" {
            if nbPar == 0 {
                parStart = i
            }
            nbPar++
        } else if tokens[i].cont == ")" || tokens[i].cont == "]" || tokens[i].cont == "}" {
            nbPar--
            continue
        }

        if nbPar > 0 {
            continue
        }

        if tokens[i].cont == "," {
            break
        }
        
        if i > start && opLevel == 3 && (tokens[i].type == TOKEN_TYPE_INT || tokens[i].type == TOKEN_TYPE_FLOAT) && tokens[i].cont[0] == '-' && tokens[i-1].type != TOKEN_TYPE_CAST && tokens[i-1].type != TOKEN_TYPE_SYNTAX {
            leftCons = consumeValue(tokens, i-1, i, <int>start, opLevel+1)
            if leftCons[0] != null {

                val = new bahValue{
                    pemdas: opLevel
                    value: BAH_VALUE_OP
                    left: leftCons[0]
                }
                val.tok = bahToken {
                    cont: "+"
                }
                rightCons = consumeValue(tokens, i, end, -1, opLevel)
                if rightCons[0] == null {
                    throwErrorTok(&tokens[i+1], "Cannot do operation on non value on the right.")
                }
                val.right = rightCons[0]
                i = rightCons[1]

                if compatibleTypes(val.left.type, val.right.type) == false {
                    throwError(val.right, "Wrong type.")
                }

                if val.right.type.size > val.left.type.size {
                    val.type = val.right.type
                } else {
                    val.type = val.left.type
                }

                return [val, i]
            }
        }

        if i > start && i+1 < end {
            if (opLevel == 0 && (tokens[i].cont == "||")) || (opLevel == 1 && (tokens[i].cont == "&&")) || (opLevel == 2 && (tokens[i].cont == "<" || tokens[i].cont == ">" || tokens[i].cont == ">=" || tokens[i].cont == "<=" || tokens[i].cont == "==" || tokens[i].cont == "!=")) || (opLevel == 3 && (tokens[i].cont == "in" || tokens[i].cont == "+" || tokens[i].cont == "-" || tokens[i].cont == "&" || tokens[i].cont == "|" || tokens[i].cont == "^" || tokens[i].cont == ">>" || tokens[i].cont == "<<")) || (opLevel == 4 && (tokens[i].cont == "*" || tokens[i].cont == "/" || tokens[i].cont == "%"))  {
                if tokens[i].cont == "*" && i+1 < end && tokens[i+1].cont == "{" {
                    continue
                }

                val = new bahValue{
                    tok: tokens[i]
                    pemdas: opLevel
                    value: BAH_VALUE_OP
                }
                leftCons = consumeValue(tokens, i-1, i, <int>start, opLevel+1)
                val.left = leftCons[0]

                if val.left == null {
                    if (tokens[i].cont == "*" || tokens[i].cont == "&") {
                        //is a pointer dereference or pointer
                        continue
                    }
                    throwErrorTok(&tokens[i-1], "Cannot do operation on non value on the left.")
                } else if val.left.value == BAH_VALUE_CAST && leftCons[1] != i && (tokens[i].cont == "*" || tokens[i].cont == "&") {
                    val = val.left
                    continue
                }

                if tokens[i+1].cont == tokens[i].cont && (tokens[i].cont == "+" || tokens[i].cont == "-") {
                    if val.left.type.type != BAH_TYPE_INT && val.left.type.type != BAH_TYPE_UINT {
                        throwError(val.left, "Cannot increment/decrement a symbol that is not an integer.")
                    }
                    val.type = val.left.type
                    val.isSelfOp = true
                    i++
                } else {
                    rightCons = consumeValue(tokens, i+1, end, -1, opLevel)
                    if rightCons[0] == null {
                        throwErrorTok(&tokens[i+1], "Cannot do operation on non value on the right.")
                    }
                    val.right = rightCons[0]
                    i = rightCons[1]

                    if val.tok.cont == "in" {
                        if val.right.type.type != BAH_TYPE_ARRAY {
                            throwError(val.right, "Cannot use 'in' operator on anything other than an array.")
                        }

                        if compatibleTypes(val.left.type, val.right.type.child) == false {
                            throwTypeError(val.right, val.left.type)
                        }
                    } else if compatibleTypes(val.left.type, val.right.type) == false {
                        throwTypeError(val.right, val.left.type)
                    }

                    if val.tok.cont == "||" || val.tok.cont == "&&" || val.tok.cont == "<" || val.tok.cont == ">" || val.tok.cont == "<=" || val.tok.cont == ">=" || val.tok.cont == "==" || val.tok.cont == "in" || val.tok.cont == "!=" {
                        if val.left.type.type == BAH_TYPE_UINT && val.right.isStaticValue {
                            if val.tok.cont == ">=" && val.right.tok.cont == "0" {
                                throwWarning(val, "Condition will always evaluate to true: an uint will always be above or at 0.")
                            } else if (val.tok.cont == ">" || val.tok.cont == ">=") && val.right.tok.cont == "-1" {
                                throwWarning(val, "Condition will always evaluate to true: an uint will always be above -1.")
                            } else if (val.tok.cont == "<" || val.tok.cont == "<=") && val.right.tok.cont[0] == '-' {
                                throwWarning(val, "Condition will always evaluate to false: an uint will never be less than "+val.right.tok.cont+".")
                            }
                        } else if val.right.type.type == BAH_TYPE_UINT && val.left.isStaticValue {
                            if val.tok.cont == ">=" && val.left.tok.cont == "0" {
                                throwWarning(val, "Condition will always evaluate to true: an uint will always be above or at 0.")
                            } else if (val.tok.cont == ">" || val.tok.cont == ">=") && val.left.tok.cont == "-1" {
                                throwWarning(val, "Condition will always evaluate to true: an uint will always be above -1.")
                            } else if (val.tok.cont == "<" || val.tok.cont == "<=") && val.left.tok.cont[0] == '-' {
                                throwWarning(val, "Condition will always evaluate to false: an uint will never be less than "+val.left.tok.cont+".")
                            }
                        }
                        val.type = new bahType {
                            type: BAH_TYPE_BOOL
                            size: 1
                        }
                    } else {
                        if val.right.type.size > val.left.type.size {
                            val.type = val.right.type
                        } else {
                            val.type = val.left.type
                        }
                    }
                }

                return [val, i]
            }
        }

    }

    if opLevel == 5 {
        return [<bahValue*>null, start]
    }

    return consumeValue(tokens, start, end, -1, opLevel+1)
}


parseHashDirective(tokens []bahToken, start uint, end uint) {

    if tokens[end-1].cont == "}" {
        i = start
        for i < end, i++ {

            j=0; for j < len(BAH_boolean_hashes), j++ {
                if BAH_boolean_hashes[j].name == tokens[i].cont {
                    break
                }
            }


            if j == len(BAH_boolean_hashes) {
                throwErrorTok(&tokens[i], "Unknown hash directive.")
            }

            hashVal = true

            if tokens[i+1].cont == "!" {
                hashVal = false
                i++
            }

            if BAH_boolean_hashes[j].isTrue != hashVal {
                return
            }

            i++
            if tokens[i].cont == "{" {
                break
            }

            if tokens[i].cont != "," {
                throwErrorTok(&tokens[i], "Expected {codeblock} or coma separator (,) between hash directives.")
            }
        }

        parseLines(tokens, i+1, end-1)
        return
    }

    
    if parserCtx.scope > 0 {
        throwErrorTok(&tokens[start], "Directive should be used at global scope.")
    }

    if tokens[start].cont == "#cLib" {
        i=start+1; for i < end, i++ {
            if tokens[i].type != TOKEN_TYPE_STR {
                throwErrorTok(&tokens[i], "Expected library name.")
            }

            parserCtx.libraries[len(parserCtx.libraries)] = tokens[i].cont[1:len(tokens[i].cont)-1]
        }

    } else if tokens[start].cont == "#define" {
        if end - start < 3 {
            throwErrorTok(&tokens[start], "Invalid use of #define.")
        }

        if tokens[start+2].cont == "(" {
            fnTypeCons = consumeType(tokens, start+2, end, true)
            fnType = fnTypeCons[0]
            i = fnTypeCons[1]

            if fnType == null {
                throwErrorTok(&tokens[start], "Invalid function type in function definition.")
            }

            fn = new bahFunction {
                name: tokens[start+1].cont
                type: fnType
            }


            if tokens[start+1].cont == "main" && fnType.toStr() != "function([]str) int" {
                throwErrorTok(&tokens[start], "Invalid main function type, should be: function([]str) int.")
            }

            parserCtx.addFunc(fn)

            if i != end {
                throwErrorTok(&tokens[i], "Didn't expected anything after function definition.")
            }
        } else {
            if tokens[start+1].type != TOKEN_TYPE_VAR {
                throwErrorTok(&tokens[start+1], "Expected type name.")
            }

            tp = consumeType(tokens, start+2, end, false)

            if tp[0] == null {
                throwErrorTok(&tokens[start+2], "Invalid type.")
            }

            if parserCtx.findType(tokens[start+1].cont) != null {
                throwErrorTok(&tokens[start+1], "Type already exists.")
            }

            nt = new bahType {
                type: BAH_TYPE_CUSTOM_TYPE
                size: tp[0].size
                child: new bahType {
                    name: tokens[start+1].cont
                }
            }
            nt.child.child = tp[0]

            parserCtx.addType(nt)
        }
    } else if tokens[start].cont == "#include" {
        if end - start != 2 || tokens[start+1].type != TOKEN_TYPE_STR {
            throwErrorTok(&tokens[start], "Invalid use of #include.")
        }

        inclFileName = tokens[start+1].cont[1:len(tokens[start+1].cont)-1]

        filePath = inclFileName
        if inclFileName[0] != '/' {
            currDirectory = absPath(parserCtx.currentFilePath)
            i=len(currDirectory)-1; for i != -1, i-- {
                if currDirectory[i] == '/' {
                    break
                }
            }
            
            currDirectory = currDirectory[:i+1]
            filePath = currDirectory + inclFileName
        }

        if fileExists(filePath) == false {
            filePath = BAH_DIR + inclFileName
            if fileExists(filePath) == false {
                throwErrorTok(&tokens[start+1], "Cannot find file.")
            }
        }

        if parserCtx.declareMode {
            parserCtx.importDeps[len(parserCtx.importDeps)] = filePath
        }

        includeFile(filePath)

    } else if tokens[start].cont == "#import" {
        if end - start != 2 || tokens[start+1].type != TOKEN_TYPE_STR {
            throwErrorTok(&tokens[start], "Invalid use of #import.")
        }

        inclFileName = tokens[start+1].cont[1:len(tokens[start+1].cont)-1]

        filePath = inclFileName
        if inclFileName[0] != '/' {
            currDirectory = absPath(parserCtx.currentFilePath)
            i=len(currDirectory)-1; for i != -1, i-- {
                if currDirectory[i] == '/' {
                    break
                }
            }
            
            currDirectory = currDirectory[:i+1]
            filePath = currDirectory + inclFileName
        }


        if fileExists(filePath) == false {
            filePath = BAH_DIR + inclFileName
            if fileExists(filePath) == false {
                throwErrorTok(&tokens[start+1], "Cannot find file.")
            }
        }
        filePath = absPath(filePath)

        if parserCtx.declareMode {
            parserCtx.importDeps[len(parserCtx.importDeps)] = filePath
        }

        importFile(filePath)

    } else if tokens[start].cont == "#init" {
        if parserCtx.declareMode {
            return
        }
        realGen = gen
        gen = initFnGen
        gen.fileNb = realGen.fileNb
        gen.totalFileNb = realGen.totalFileNb

        parseLine(tokens, start+1, end)

        realGen.data += gen.data
        realGen.staticData += gen.staticData
        realGen.bss += gen.bss
        gen = realGen
    } else {
        throwErrorTok(&tokens[start], "Unknown directive.")
    }

}

parseReturn(tokens []bahToken, start uint, end uint) {

    if parserCtx.debugEnabled {
        gen.instructions[len(gen.instructions)] = asmInstruction {
            ".return_"+intToStr(asmRandId)+"_"+parserCtx.scopeCtx.currentFunction.name+":"
        }
        asmRandId++
    }

    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Cannot return outside of a function.")
    }

    if start+1 == end {
        //handle only return if no ret type
        if parserCtx.scopeCtx.currentFunction.type.ret != null {
            throwErrorTok(&tokens[start], "Expected return value, current function of type: "+parserCtx.scopeCtx.currentFunction.type.toStr())
        }

        gen.generateEarlyReturn()
        return
    }

    valCons = consumeValue(tokens, start+1, end, -1, 0)
    val = valCons[0]
    if val == null {
        throwErrorTok(&tokens[start+1], "Expected value, cannot return anything other than a value.")
    }

    if valCons[1] != end {
        throwErrorTok(&tokens[valCons[1]], "Did not expect anything after the return statement.")
    }

    if parserCtx.scopeCtx.currentFunction.type.ret == null {
        throwError(val, "Did not expect a return value.")
    }
    
    if compatibleTypes(parserCtx.scopeCtx.currentFunction.type.ret, val.type) == false {
        throwTypeError(val, parserCtx.scopeCtx.currentFunction.type.ret)
    }

    parserCtx.scopeCtx.setState(BAH_SCOPE_RETURNED)

    valSym = generateBahValueSymbol(val, null)

    retType = parserCtx.scopeCtx.currentFunction.type.ret
    if retType != null {
        //fing mazochist who invented that
        if retType.type == BAH_TYPE_STRCT {
            if retType.child.next != null && retType.child.next.type == BAH_TYPE_FLOAT {
                if retType.child.next.next != null {
                    if retType.child.next.next.type == BAH_TYPE_FLOAT {
                        valSym.isFloat = true
                    }
                } else {
                    valSym.isFloat = true
                }
            }
        } else if retType.type == BAH_TYPE_FLOAT {
            valSym.isFloat = true
        }
    }

    gen.generateReturn(valSym)

}

parseIf(tokens []bahToken, start uint, end uint) {
    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Did not expect if statement outside of a function.")
    }

    nbPar = 1
    i = end-2
    ifLineEnd = end
    for i != -1, i-- {
        if tokens[i].cont == "{" {
            nbPar--
            if nbPar == 0 {
                ifLineEnd = i
                break
            }
        } else if tokens[i].cont == "}" {
            nbPar++
        }
    }

    condStartIndex = len(gen.instructions)

    condValCons = consumeValue(tokens, start+1, ifLineEnd, -1, 0)
    if condValCons[0] == null {
        throwErrorTok(&tokens[start+1], "Expected a condition in if statement.")
    }

    isChainStart = end < len(tokens) && tokens[end].cont == "else"

    condSym = generateBahValueSymbol(condValCons[0], null)

    instStartIndex = gen.generateIf(condSym)

    ifScope = new parserScope {
        isConditional: true
        isIf: true
        currentFunction: parserCtx.scopeCtx.currentFunction
    }

    parserCtx.startScope(ifScope)

    parseLines(tokens, ifLineEnd+1, end-1)

    parserCtx.endScope()


    gen.generateEndIf(isChainStart)

    if gen.enableOptimizations && isChainStart == false {
        //TODO: move optimizations to gen_asm_linux_64.bah

        if ifScope.isSingleVarSet && isValuePure(ifScope.rVal) && isValueSafe(ifScope.rVal) && isLeftValueSafe(ifScope.lVal) {
            //Optimization: if all the if scope is doing is setting a var value, try to do it branchless
            if gen.instructions[len(gen.instructions) - 2].instruction[0] == 'm' {
                condInsts = gen.instructions[condStartIndex:instStartIndex]
                arrayDuplicate(condInsts)
                movInst = gen.instructions[len(gen.instructions)-2]
                
                i = instStartIndex
                for i != -1, i-- {
                    if gen.instructions[i].instruction[0] == 'j' && gen.instructions[i].instruction[len(gen.instructions[i].instruction) - 1] != ':' {
                        movInst.instruction = "cmov"+(gen.inverseJump(gen.instructions[i].instruction)[1:])
                        break
                    }
                }
                if i == -1 {
                    panic("Error converting if condition")
                }
                i=instStartIndex+1
                offset = (i - condStartIndex)
                for i < len(gen.instructions)-2, i++ {
                    gen.instructions[i - offset] = gen.instructions[i]
                }
                instsArr = <Bah_Array_Type*>gen.instructions
                instsArr.length = i - offset

                sym = gen.generateTmpSym(movInst.arg1, movInst.arg1.size)
                i=0; for i < len(condInsts), i++ {
                    gen.instructions[len(gen.instructions)] = condInsts[i]
                }
                
                tmpReg = asmSymbolReg(ASM_reg_id_dest_addr, movInst.arg2.size, 0)
                if gen.isSameArg(&tmpReg, &movInst.arg2) {
                    tmpReg = asmSymbolReg(ASM_reg_id_op, movInst.arg2.size, 5)
                }
                gen.generateMoveValue(movInst.arg2, tmpReg)
                gen.generateMoveValue(sym, asmSymbolReg(ASM_reg_id_return, sym.size, 0))
                dest = movInst.arg2
                movInst.arg1 = asmSymbolReg(ASM_reg_id_return, 8, 0)
                movInst.arg2 = tmpReg
                movInst.arg2.size = 8

                gen.instructions[len(gen.instructions)] = movInst
                gen.generateMoveValue(tmpReg, dest)
            }
        } else if (optimizeIsCondNotLikely(condValCons[0]) || hasScopeState(ifScope, BAH_SCOPE_EXITTED) || hasScopeState(ifScope, BAH_SCOPE_REALLOC)) {
            //Optimization: if unlikely branch, make the branch predictor understand it is not likely
            newLabel = ".IF_UNLIKELY_"+uintToStr(asmRandId)
            oldLabel = ""
            asmRandId++
            
            i = instStartIndex

            for i != -1, i-- {
                if gen.instructions[i].instruction[0] == 'j' && gen.instructions[i].instruction[len(gen.instructions[i].instruction) - 1] != ':' {
                    gen.instructions[i].instruction = gen.inverseJump(gen.instructions[i].instruction)
                    oldLabel = gen.instructions[i].arg1.name
                    gen.instructions[i].arg1.name = newLabel
                    break
                }
            }

            if i == -1 {
                panic("Error converting if condition")
            }

            i++

            endInstructions = parserCtx.scopeCtx.currentFunction.endInstructions

            endInstructions[len(endInstructions)] = asmInstruction {
                newLabel+":"
            }

            for i < len(gen.instructions) - 1, i++ {
                endInstructions[len(endInstructions)] = gen.instructions[i]
                gen.instructions[i].instruction = "#"
            }
            endInstructions[len(endInstructions)] = asmInstruction {
                "jmp", asmSymbolValue(oldLabel)
            }
        }
    }


    if isChainStart {
        parserCtx.scopeCtx.ifChainLabels[len(parserCtx.scopeCtx.ifChainLabels)] = len(gen.instructions) - 1
        parserCtx.scopeCtx.ifChainLength++
    } else {
        clear(parserCtx.scopeCtx.ifChainLabels)
        parserCtx.scopeCtx.ifChainLength = 0
    }

}

parseElse(tokens []bahToken, start uint, end uint) {

    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Did not expect if statement outside of a function.")
    }

    if parserCtx.scopeCtx.ifChainLength == 0 {
        throwErrorTok(&tokens[start], "Did not expect else block here.")
    }

    elseLineEnd = start + 1

    if end - start > 1 && tokens[start+1].cont == "if" {
        nbPar = 1
        i = end-2
        for i != -1, i-- {
            if tokens[i].cont == "{" {
                nbPar--
                if nbPar == 0 {
                    elseLineEnd = i
                    break
                }
            } else if tokens[i].cont == "}" {
                nbPar++
            }
        }

        condValCons = consumeValue(tokens, start+2, elseLineEnd, -1, 0)
        if condValCons[0] == null {
            throwErrorTok(&tokens[start+2], "Expected a condition in else if statement.")
        }

        isNotChainEnd = end < len(tokens) && tokens[end].cont == "else"
        chainLength = parserCtx.scopeCtx.ifChainLength

        if isNotChainEnd {
            chainLength = 0
        }

        gen.generateElseIf(generateBahValueSymbol(condValCons[0], null), chainLength, parserCtx.scopeCtx.ifChainLabels)

        ifScope = new parserScope {
            isConditional: true
            currentFunction: parserCtx.scopeCtx.currentFunction
        }

        parserCtx.startScope(ifScope)

        parseLines(tokens, elseLineEnd+1, end-1)

        parserCtx.endScope()

        gen.generateEndElse()

        if isNotChainEnd {
            parserCtx.scopeCtx.ifChainLength++
            parserCtx.scopeCtx.ifChainLabels[len(parserCtx.scopeCtx.ifChainLabels)] = len(gen.instructions) - 1
        } else {
            parserCtx.scopeCtx.ifChainLength = 0
            clear(parserCtx.scopeCtx.ifChainLabels)
        }

    } else {

        gen.generateElse(parserCtx.scopeCtx.ifChainLength, parserCtx.scopeCtx.ifChainLabels)

        elseScope = new parserScope {
            isConditional: true
            isElse: true
            currentFunction: parserCtx.scopeCtx.currentFunction
        }

        parserCtx.startScope(elseScope)

        parseLines(tokens, elseLineEnd+1, end-1)

        parserCtx.endScope()

        gen.generateEndElse()

        parserCtx.scopeCtx.ifChainLength = 0
        clear(parserCtx.scopeCtx.ifChainLabels)
    }
    
}

parseFor(tokens []bahToken, start uint, end uint) {

    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Did not expect if statement outside of a function.")
    }

    nbPar = 1
    i = end-2
    forLineEnd = end
    for i != -1, i-- {
        if tokens[i].cont == "{" {
            nbPar--
            if nbPar == 0 {
                forLineEnd = i
                break
            }
        } else if tokens[i].cont == "}" {
            nbPar++
        }
    }
    
    condValCons = consumeValue(tokens, start+1, forLineEnd, -1, 0)
    if condValCons[0] == null {
        throwErrorTok(&tokens[start+1], "Expected at least a condition.")
    }

    condVal = condValCons[0]
    i = condValCons[1]

    if condValCons[0].type.type != BAH_TYPE_BOOL {
        throwError(condVal, "Type error, condition of a loop should be a boolean instead of type '"+condVal.type.toStr()+"'.")
    }

    gen.generateFor()
    optimizedIndex = len(gen.instructions)-1

    shouldOptimizeForLoop = false
    if gen.enableOptimizations && (isValueInexpensive(condVal) || condVal.value == BAH_VALUE_OP && isValueInexpensive(condVal.left) && isValueInexpensive(condVal.right)) {
        shouldOptimizeForLoop = true
        j = forLineEnd+1; for j < end-1, j++ {
            if tokens[j].cont == "continue" {
                shouldOptimizeForLoop = false
                break
            }
        }
    }

    if shouldOptimizeForLoop == false {
        optimizedIndex = -1
    }

    gen.generateForCond(generateBahValueSymbol(condVal, null), optimizedIndex)

    forLoopScope = new parserScope {
        isConditional: true
        currentFunction: parserCtx.scopeCtx.currentFunction
    }

    parserCtx.startScope(forLoopScope)

    if tokens[i].cont == "," {
        parseLine(tokens, i+1, forLineEnd)
    }

    if shouldOptimizeForLoop {
        gen.generateForOptimizedCond(generateBahValueSymbol(condVal, null))
    }

    gen.generateForIncr()


    parseLines(tokens, forLineEnd+1, end-1)

    gen.generateForEnd(shouldOptimizeForLoop)

    parserCtx.endScope()


}

parseStruct(tokens []bahToken, start uint, end uint) {
    
    if parserCtx.scope != 0 {
        throwErrorTok(&tokens[start], "Did not expect structure definition inside a function.")
    }

    if end - start < 4 {
        throwErrorTok(&tokens[start], "Invalid structure definition.")
    }

    if tokens[start+1].type != TOKEN_TYPE_VAR {
        throwErrorTok(&tokens[start+1], "Invalid structure name.")
    }



    strctType = new bahType {
        type: BAH_TYPE_STRCT
    }
    strctType.child = new bahType {
        name: tokens[start+1].cont
    }

    if parserCtx.findType(strctType.name) != null {
        throwErrorTok(&tokens[start+1], "Cannot redefine a structure.")
    }

    i = start + 2

    currParent = strctType.child
    currOffset = 0

    if tokens[start+2].cont == "extend" {
        if tokens[start+3].type != TOKEN_TYPE_VAR {
            throwErrorTok(&tokens[start+3], "Invalid structure name.")
        }

        extdTp = parserCtx.findType(tokens[start+3].cont)
        if extdTp == null || extdTp.type != BAH_TYPE_STRCT {
            throwErrorTok(&tokens[start+3], "No structure named that way.")
        }
        strctType.ret = extdTp

        extdTp = extdTp.child.next

        for extdTp != null, extdTp = extdTp.next {
            memberCopy = new bahType
            *memberCopy = *extdTp

            alignment = memberCopy.size

            if alignment > 8 {
                alignment = 8
            }

            if currOffset % alignment != 0 {
                currOffset += alignment - (currOffset % alignment)
            }

            memberCopy.offset = currOffset
            currParent.next = memberCopy
            strctType.size = currOffset + memberCopy.size
            currOffset += memberCopy.size

            currParent.next = memberCopy
            currParent = memberCopy
        }
        currOffset = currParent.offset + currParent.size

        
        i += 2
    }

    parserCtx.addType(strctType)

    if tokens[i].cont != "{" {
        throwErrorTok(&tokens[i], "Expected start of fields definition.")
    }
    i++


    for i < end-1, i++ {
        nameInd = i
        if tokens[nameInd].type != TOKEN_TYPE_VAR {
            throwErrorTok(&tokens[nameInd], "Invalid filed name.")
        }
        i++

        if tokens[i].cont == "(" { //method definition
            nbPar = 1
            j = i
            fnLineEnd = end
            for j < end, j++ {
                if tokens[j].cont == "{" {
                    fnLineEnd = j
                    break
                }
            }

            methodTypeCons = consumeType(tokens, i, fnLineEnd, true)

            if methodTypeCons[0] == null {
                throwErrorTok(&tokens[i-1], "Invalid method type definition.")
            }

            method = new bahFunction {
                name: strctType.child.name+"."+tokens[nameInd].cont
                type: methodTypeCons[0]
                declared: true
            }

            tpThisInjct = strctType.getPtr()
            tpThisInjct.next = method.type.child
            tpThisInjct.name = "this"
            method.type.child = tpThisInjct

            nbBraces = 1
            i = fnLineEnd+1
            for i < end, i++ {
                if tokens[i].cont == "{" {
                    nbBraces++
                } else if tokens[i].cont == "}" {
                    nbBraces--
                    if nbBraces == 0 {
                        i++
                        break
                    }
                }
            }

            parserCtx.addFunc(method)
            parseFnBody(method, tokens, fnLineEnd+1, i)
            
        } else { //field definition

            if tokens[i].cont != ":" {
                throwErrorTok(&tokens[i], "Expected ':' after field name.")
            }
            i++



            fieldTypeCons = consumeType(tokens, i, end-1, false)
            if fieldTypeCons[0] == null {
                throwErrorTok(&tokens[i], "Unknown type.")
            }

            i = fieldTypeCons[1]
            fieldType = new bahType
            *fieldType = *(fieldTypeCons[0])
            fieldType.name = tokens[nameInd].cont

            alignment = fieldType.size

            if alignment > 8 {
                alignment = 8
            }

            if currOffset % alignment != 0 {
                currOffset += alignment - (currOffset % alignment)
            }


            if tokens[i].cont == "=" {
                if i+1 > end {
                    throwErrorTok(&tokens[i], "Expected a field default value after equal.")
                }

                lineEnd = i+1
                currLine = tokens[i].line
                for lineEnd < end-1, lineEnd++ {
                    t = tokens[lineEnd]
                    if t.type == TOKEN_TYPE_STR && t.begLine == currLine && t.line != currLine {
                        currLine = t.line
                    }

                    if t.line != currLine {
                        break
                    }
                }

                // printDebugContext()
                val = consumeValue(tokens, i+1, lineEnd, -1, 0)
                if val[0] == null {
                    throwErrorTok(&tokens[i+1], "Expected a field default value after equal.")
                }

                if compatibleTypes(fieldType, val[0].type) == false {
                    throwTypeError(val[0], fieldType)
                }

                fieldType.defaultValue = val[0]

                i = val[1]

                // throwError(&tokens[i], "Default value not yet implemented")
            }



            fieldType.offset = currOffset
            currParent.next = fieldType
            strctType.size = currOffset + fieldType.size
            currOffset += fieldType.size
            currParent = currParent.next

        }
        

        if i == end-1 {
            break
        } else {
            if tokens[i].line == tokens[nameInd].line {
                throwErrorTok(&tokens[i], "Did not expect anything after field type.")
            }
            i--
        }
    }



}

parseFnBody(fn bahFunction*, tokens []bahToken, i uint, end uint) {    
    if parserCtx.declareMode {
        return
    }

    hasRetType = fn.type.ret != null

    returnSize = 0
    if hasRetType {
        returnSize = fn.type.ret.size
    }

    funcScope = new parserScope {
        isConditional: false
        needsReturn: hasRetType

        currentFunction: fn
    }


    parserCtx.startScope(funcScope)

    genArgs = []asmSymbol

    gen.stackOffset = 0
    stackOff = 16 //stack frame size

    if returnSize > 16 {
        gen.stackOffset = 16
    }

    arg = fn.type.child

    if hasRetType && fn.type.ret.size <= 8 && fn.type.ret.isPtr == false && fn.type.ret.isNativePtr == false && fn.type.ret.type != BAH_TYPE_FLOAT {
        fn.type.flags = BAH_TYPE_FLAG_PURE
    }

    for arg != null, arg = arg.next {
        if arg.size > 8 || arg.isPtr || arg.isNativePtr || arg.type == BAH_TYPE_FLOAT {
            fn.type.flags = 0
        }
        v = new bahVariable {
            name: arg.name
            type: arg
        }
        parserCtx.addVar(v)
        if v.type.size > 16 {
            addr = stackOff

            tmpArg = arg.next
            for tmpArg != null, tmpArg = tmpArg.next {
                if tmpArg.size > 16 {
                    addr += tmpArg.size
                    if addr % 16 != 0 {
                        addr += (16 - addr % 16)
                    }
                }
            }

            v.sym = asmSymbolStack(0 - addr, v.type.size)
        } else {
            v.sym = gen.generateVarDecl(v.name, v.type.size, false)

            if arg.type == BAH_TYPE_STRCT {
                if arg.child.next != null && arg.child.next.type == BAH_TYPE_FLOAT {
                    if arg.child.next.next != null {
                        if arg.child.next.next.type == BAH_TYPE_FLOAT {
                            v.sym.isFloat = true
                        }
                    } else {
                        v.sym.isFloat = true
                    }
                }
            } else if arg.type == BAH_TYPE_FLOAT {
                v.sym.isFloat = true
            }
        }
        genArgs[len(genArgs)] = v.sym
    }

    gen.generateFnStart(fn.name, genArgs, returnSize)

    parseLines(tokens, i, end-1)

    if parserCtx.scopeCtx.currentFunction.type.ret != null && hasScopeReturned(parserCtx.scopeCtx) == false {
        throwErrorTok(&tokens[end-1], "Function with a return type shall be returned.")
    }

    if parserCtx.debugEnabled {
        gen.instructions[len(gen.instructions)] = asmInstruction {
            ".return_"+intToStr(asmRandId)+"_"+fn.name+":"
        }
        asmRandId++
    }

    if parserCtx.scopeCtx.isState(BAH_SCOPE_EXITTED) {
        fn.type.toggleFlag(BAH_TYPE_FLAG_EXIT)
    } else if parserCtx.scopeCtx.isState(BAH_SCOPE_REALLOC) {
        fn.type.toggleFlag(BAH_TYPE_FLAG_REALLOC)
    } 

    parserCtx.endScope()
    fn.asmInstructions = gen.generateFnEnd(fn.endInstructions)


}

parseFnDecl(tokens []bahToken, start uint, end uint) {
    nbPar = 1
    i = end-2
    fnLineEnd = end
    for i != -1, i-- {
        if tokens[i].cont == "{" {
            nbPar--
            if nbPar == 0 {
                fnLineEnd = i
                break
            }
        } else if tokens[i].cont == "}" {
            nbPar++
        }
    }

    fnTypeCons = consumeType(tokens, start+1, fnLineEnd, true)

    fnType = fnTypeCons[0]

    i = fnTypeCons[1]

    if fnType == null {
        throwErrorTok(&tokens[start], "Invalid function type in function declaration.")
    }

    fn = parserCtx.findFunc(tokens[start].cont)

    if fn == null {
        fn = new bahFunction {
            name: tokens[start].cont
            type: fnType
            declared: true
        }
        parserCtx.addFunc(fn)
    } else {
        if fn.declared {
            throwErrorTok(&tokens[start], "Cannot redeclare a function.")
        } else if compatibleTypes(fn.type, fnType) == false {
            throwErrorTok(&tokens[start], "Function declaration missmatch.")
        }
        fn.declared = true
        fn.type = fnType
    }


    if tokens[start].cont == "main" && fnType.toStr() != "function([]str) int" {
        throwErrorTok(&tokens[start], "Invalid main function type, should be: function([]str) int.")
    }

    i++

    parseFnBody(fn, tokens, i, end)
}

parseVariableSet(tokens []bahToken, start uint, end uint, eqlIndex uint, lValCons [bahLeftValue*, uint, bool], rValCons [bahValue*, uint]) {
    tmpDeclType bahType* = null

    if rValCons[0] == null {
        throwErrorTok(&tokens[eqlIndex+1], "Expected a value on the right of equal.")
    }

    if lValCons[0] == null {
        throwErrorTok(&tokens[start], "Expected a symbol or an address on the left of equal.")
    }

    if lValCons[1] != eqlIndex {
        typeCons = consumeType(tokens, lValCons[1], eqlIndex, false)
        if typeCons[0] == null {
            throwErrorTok(&tokens[lValCons[1]], "Expected type.")
        } else if typeCons[1] != eqlIndex {
            throwErrorTok(&tokens[typeCons[1]], "Did not expect anything after the type.")
        }

        if lValCons[2] == false {
            throwErrorTok(&tokens[lValCons[1]], "Cannot cast the left value type outside of a declaration.")
        }

        tmpDeclType = typeCons[0]

        //type?
        // throwError(&tokens[lValCons[1]], "Didn't expect anything between left value and equal sign.")
    }

    rVal = rValCons[0]
    lVal = lValCons[0]

    if len(tokens[eqlIndex].cont) == 2 {
        if lValCons[2] {
            throwErrorTok(&tokens[eqlIndex], "Invalid self operation on declaration.")
        }

        leftRightVal = consumeValue(tokens, start, eqlIndex, -1, 0)[0]
        rVal = new bahValue {
            value: BAH_VALUE_OP
            tok: tokens[eqlIndex]
            left: leftRightVal
            right: rVal
            type: rVal.type
        }
    }
    
    if lValCons[2] {
        //is declaration

        if len(tokens[eqlIndex].cont) == 2 {
            throwErrorTok(&tokens[eqlIndex], "Invalid self operation on declaration.")
        }

        lVal.variable = new bahVariable {
            name: lValCons[0].tok.cont
            type: rVal.type
        }


        if tmpDeclType != null {
            lVal.variable.type = tmpDeclType
            lVal.type = tmpDeclType
        } else {
            lVal.type = rVal.type
        }

        parserCtx.addVar(lVal.variable)

        if parserCtx.scope == 0 {
            if rVal == null {
                if parserCtx.declareMode {
                    lVal.variable.sym = asmSymbolStaticName(lVal.variable.name)
                    lVal.variable.sym.size = lVal.variable.type.size
                } else {
                    lVal.variable.sym = gen.generateGlobalVarDecl(lVal.variable.name, lVal.variable.type.size)
                }
            }
        } else {
            if lVal.isVariable == false || rVal.value != BAH_VALUE_DECLARATION && (rVal.value != BAH_VALUE_FUNC_CALL || rVal.type.size <= 8) {
                size = lVal.variable.type.size
                if lVal.variable.type.isNativePtr {
                    size = 8
                }
                lVal.variable.sym = gen.generateVarDecl(lVal.variable.name, size, false)
            }
        }
    } else {
        if parserCtx.scope == 0 {
            throwErrorTok(&lVal.tok, "Cannot redeclare a global variable.")
        }
        if compatibleTypes(lVal.type, rVal.type) == false {
            throwTypeError(rVal, lVal.type)
        }
    }

    rValSym = asmSymbol{}

    if rVal.isStaticValue {
        rVal.type.size = lVal.type.size
    }

    if parserCtx.scope == 0 {
        typeSize = lVal.variable.type.size
        if lVal.variable.type.isNativePtr {
            typeSize = 8
        }
        if isObjectFile {
            lVal.variable.sym = asmSymbolStaticName(lVal.variable.name)
            lVal.variable.sym.size = typeSize
        } else {
            syms = []asmSymbol
            generateImmediateValues(rVal, syms)
            lVal.variable.sym = gen.generateGlobalVarDeclWithValue(lVal.variable.name, typeSize, syms)
        }
    } else {
        //Generate var setting
        if parserCtx.scopeCtx.isIf || parserCtx.scopeCtx.isElse {
            if parserCtx.scopeCtx.lVal != null || parserCtx.scopeCtx.moreThanSingleSet {
                parserCtx.scopeCtx.isSingleVarSet = false
            } else {
                parserCtx.scopeCtx.isSingleVarSet = true
                parserCtx.scopeCtx.rVal = rVal
                parserCtx.scopeCtx.lVal = lVal
            }
        }

        if lVal.isVariable == false && rVal.value == BAH_VALUE_FUNC_CALL && rVal.type.size > 16 {
            lValSym = generateBahLeftValueSymbol(lVal)
            tmpLvalSym = lValSym
            if tmpLvalSym.level != 0 {
                tmpLvalSym.level = 0
                tmpLvalSym.size = 8
                tmpLvalSym = gen.generateTmpSym(tmpLvalSym, tmpLvalSym.size)
                tmpLvalSym.level = lValSym.level
            }
            rValSym = generateBahValueSymbol(rVal, &tmpLvalSym)
            if isEmptySymbol(&rValSym) == false {
                gen.generateVarSet(lValSym, rValSym, false)
            }
        } else {
            if lValCons[2] == true && isSameType(lVal.type, rVal.type) == false {
                rValSym = generateTypeConversion(rVal, lVal.type)
            } else {
                rValSym = generateBahValueSymbol(rVal, null)
            }

            if lVal.isArrayRecursive() {
                rValSym = gen.generateTmpSym(rValSym, rValSym.size)
            }

            lValSym = generateBahLeftValueSymbol(lVal)
            if lVal.isVariable && lVal.variable.scope == parserCtx.scope && (rVal.value == BAH_VALUE_DECLARATION || (rVal.value == BAH_VALUE_FUNC_CALL && rVal.type.size > 8)) {
                lVal.variable.sym = rValSym
            } else {

                if rValSym.size != lValSym.size && lVal.type.type == BAH_TYPE_FLOAT {
                    rValSym.isFloat = true
                    rValSym = gen.generateConvSizes(rValSym, lValSym.size, false)
                }

                gen.generateVarSet(lValSym, rValSym, lVal.type.type == BAH_TYPE_UINT)
            }
        }

    }
}

parseConst(tokens []bahToken, start uint, end uint) {

    // if parserCtx.scope != 0 {
    //     throwError(&tokens[start], "Did not expect const definition inside a function.")
    // }

    i=start; for i < end, i++ {
    if tokens[i].cont == "=" {
            break
        }
    }

    if i == end {
        throwErrorTok(&tokens[i], "Cannot declare a const without a value.")
    }
    if i == start {
        throwErrorTok(&tokens[i], "Expected a const name on the left of equal, got nothing.")
    }
    if i == end - 1 {
        throwErrorTok(&tokens[i], "Expected a const value on the right of equal, got nothing.")
    }

    lVal = tokens[start+1]

    if lVal.type != TOKEN_TYPE_VAR {
        throwErrorTok(&lVal, "Expected a constant's name.")
    }

    rValCons = consumeValue(tokens, i+1, end, -1, 0)

    if rValCons[0] == null {
        throwErrorTok(&tokens[i+1], "Expected a value on the right of equal.")
    }

    rVal = rValCons[0]

    if rVal.isStaticValue == false {
        if rVal.value != BAH_VALUE_CAST || (rVal.value == BAH_VALUE_CAST && rVal.left.isStaticValue == false) {
            found = false
            if rVal.value == BAH_VALUE_VAR {
                v = parserCtx.findVar(rVal.tok.cont)
                if v == null {
                    panic("That's a good one lol.")
                }
                if v.isConst {
                    found = true
                }
            }

            if found == false {
                lValCons = consumeLeftValue(tokens, start+1, i)
                parseVariableSet(tokens, start+1, end, i, lValCons, rValCons)
                lValCons[0].variable.isConst = true
                return
            }
        }


        rVal = rVal.left
    }

    variable = new bahVariable {
        name: lVal.cont
        type: rValCons[0].type
        isConst: true
    }


    parserCtx.addVar(variable)

    variable.sym = generateBahValueSymbol(rValCons[0], null)

}

parseContinue(tokens []bahToken, start uint, end uint) {
    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Did not expect continue statement outside of a function.")
    }

    if end - start != 1 {
        throwErrorTok(&tokens[start+1], "Did not expect anything after keyword.")
    }
    gen.generateForContinue()
}

parseBreak(tokens []bahToken, start uint, end uint) {
    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Did not expect break statement outside of a function.")
    }

    if end - start != 1 {
        throwErrorTok(&tokens[start+1], "Did not expect anything after keyword.")
    }
    gen.generateForBreak()
}

parseAsync(tokens []bahToken, start uint, end uint) {
    if parserCtx.scope == 0 {
        throwErrorTok(&tokens[start], "Did not expect async function call outside of a function.")
    }

    valCons = consumeValue(tokens, start+1, end, -1, 0)

    if valCons[0] == null {
        throwErrorTok(&tokens[start+1], "Expected function call after async keyword.")
    }

    if valCons[0].value != BAH_VALUE_FUNC_CALL {
        throwError(valCons[0], "Expected function call after async keyword.")
    }

    valCons[0].isAsync = true

    generateBahValueSymbol(valCons[0], null)
}

parseLine(tokens []bahToken, start uint, end uint) {
    //type by first token
    t = tokens[start]

    parserCtx.currentLine = t.line
    if parserCtx.declareMode == false && parserCtx.scope != 0 {
        gen.generateLineLocation(t.line)
    }

    if t.type == TOKEN_TYPE_KEYWORD {
        if t.cont[0] == '#' {
            parseHashDirective(tokens, start, end)
        } else if t.cont == "return" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseReturn(tokens, start, end)
        } else if t.cont == "if" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseIf(tokens, start, end)
        } else if t.cont == "else" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseElse(tokens, start, end)
        } else if t.cont == "for" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseFor(tokens, start, end)
        } else if t.cont == "struct" {
            parseStruct(tokens, start, end)
        } else if t.cont == "const" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseConst(tokens, start, end)
        } else if t.cont == "continue" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseContinue(tokens, start, end)
        } else if t.cont == "break" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseBreak(tokens, start, end)
        } else if t.cont == "async" {
            parserCtx.scopeCtx.moreThanSingleSet = true
            parseAsync(tokens, start, end)
        } else {
            throwErrorTok(&tokens[start], "Invalid keyword.")
        }
    } else if t.type == TOKEN_TYPE_VAR && end - start > 4 && tokens[start+1].cont == "(" && tokens[end-1].cont == "}" {
        parseFnDecl(tokens, start, end)
    } else {
        eqlIndex = 0
        i=start; for i < end, i++ {
            if tokens[i].cont == "=" || tokens[i].cont == "+=" || tokens[i].cont == "-=" || tokens[i].cont == "/=" || tokens[i].cont == "*=" {
                eqlIndex = i
                break
            }
        }

        if i != end {
            if i == start {
                throwErrorTok(&tokens[i], "Expected a value on the left of equal, got nothing.")
            }
            if i == end - 1 {
                throwErrorTok(&tokens[i], "Expected a value on the right of equal, got nothing.")
            }

            lValCons = consumeLeftValue(tokens, start, i)
            rValCons = consumeValue(tokens, i+1, end, -1, 0)

            parseVariableSet(tokens, start, end, eqlIndex, lValCons, rValCons)
        } else {

            parserCtx.scopeCtx.moreThanSingleSet = true
            i=start+1
            //handle rvalue lines without setting a var
            if end - start >= 2 && tokens[start].type == TOKEN_TYPE_VAR {
                for i < end, i++ {
                    if tokens[i].cont == "(" && tokens[i-1].cont != "function" || (tokens[i].type == TOKEN_TYPE_SYNTAX && tokens[i].cont != "*") {
                        val = consumeValue(tokens, start, end, -1, 0)
                        if val[0] != null {
                            if val[0].value != BAH_VALUE_FUNC_CALL && val[0].isSelfOp == false {
                                throwError(val[0], "Meaningless line.")
                            }
                            generateBahValueSymbol(val[0], null)
                        } else {
                            if val[1] != end {
                                throwErrorTok(&tokens[val[1]], "Not expected.")
                            }
                        }
                        break
                    }
                }
            }

            //handle var declaration with just a type
            if i == end {
                lValCons = consumeLeftValue(tokens, start, i)
                tmpDeclType bahType* = null

                if lValCons[0] == null {
                    throwErrorTok(&tokens[start], "Expected a symbol in variable declaration.")
                }

                typeCons = consumeType(tokens, lValCons[1], i, false)
                if typeCons[0] == null {
                    throwErrorTok(&tokens[lValCons[1]], "Expected type.")
                } else if typeCons[1] != i {
                    throwErrorTok(&tokens[typeCons[1]], "Did not expect anything after the type.")
                }

                tmpDeclType = typeCons[0]
                lVal = lValCons[0]
                
                if lValCons[2] == false {
                    throwErrorTok(&lVal.tok, "Cannot redeclare variable.")
                }

                lVal.variable = new bahVariable {
                    name: lValCons[0].tok.cont
                    type: tmpDeclType
                }

                parserCtx.addVar(lVal.variable)

                if parserCtx.scope == 0 {
                    if parserCtx.declareMode {
                        lVal.variable.sym = asmSymbolStaticName(lVal.variable.name)
                        lVal.variable.sym.size = lVal.variable.type.size
                    } else {
                        lVal.variable.sym = gen.generateGlobalVarDecl(lVal.variable.name, lVal.variable.type.size)
                    }
                } else {
                    lVal.variable.sym = gen.generateVarDecl(lVal.variable.name, lVal.variable.type.size, true)
                }
            }

        }
    }

    
}

parseLines(tokens []bahToken, start uint, end uint) {
    nbEncl uint = 0
    currentLine uint = 0
    startLine uint = start
    endLine uint = end

    i=start; for i < end, i++ {
        t = tokens[i]

        if t.type == TOKEN_TYPE_STR && t.begLine == currentLine && t.line != currentLine {
            currentLine = t.line
        }

        if t.type == TOKEN_TYPE_ENCL {
            if t.cont[0] == '(' || t.cont[0] == '[' {
                if t.line == currentLine || nbEncl != 0 {
                    nbEncl++
                } else {
                    endLine = i
                    if startLine != endLine {
                        parseLine(tokens, startLine, endLine)
                    }
                    startLine = endLine
                    currentLine = t.line
                    nbEncl = 1
                }
            } else if t.cont[0] == '{' {
                nbEncl++
            } else {
                if nbEncl == 0 {
                    throwErrorTok(&t, "One too many token.")
                }
                nbEncl--
                if nbEncl == 0 && t.cont[0] == '}' {
                    endLine = i+1
                    if startLine != endLine {
                        parseLine(tokens, startLine, endLine)
                    }
                    startLine = endLine
                    if endLine < end {
                        currentLine = tokens[endLine].line
                    }
                }
                continue
            }
        }

        if t.line != currentLine || t.cont == ";" {
            if nbEncl == 0 {
                endLine = i
                if startLine != endLine {
                    parseLine(tokens, startLine, endLine)
                }
                startLine = endLine
                if t.cont == ";" {
                    startLine++
                }
            }
            currentLine = t.line
        }

    }

    if startLine != i {
        endLine = i
        parseLine(tokens, startLine, endLine)
    }
}