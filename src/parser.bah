const BAH_LINE_DECL_VAR   = 0
const BAH_LINE_DECL_FN    = 1
const BAH_LINE_DECL_STRCT = 2

const BAH_LINE_HASH = 3

const BAH_LINE_FLOW_IF   = 4
const BAH_LINE_FLOW_ELSE = 5
const BAH_LINE_FLOW_FOR  = 6

#define parseLines(tokens []bahToken, start uint, end uint)
#define parseLine(tokens []bahToken, start uint, end uint)
#define consumeValue(tokens []bahToken, start uint, end uint, parentStart int, opLevel uint) [bahValue*, uint]
#define parseFnBody(fn bahFunction*, tokens []bahToken, i uint, end uint)

includeFile(filePath str) {
    if filePath in parserCtx.parsedFiles {
        return
    }

    parserCtx.parsedFiles[len(parserCtx.parsedFiles)] = filePath

    fs = fileStream{}
    fs.open(filePath, "r")
    content = fs.readContent()
    fs.close()


    oldFilePath = parserCtx.currentFilePath 
    oldCurrFile = parserCtx.currentFile 
    oldFileNb = gen.fileNb

    parserCtx.currentFilePath = filePath
    parserCtx.currentFile = content

    inclTokens = lexer(content)

    gen.generateFileLocation(parserCtx.currentFilePath)
    parseLines(inclTokens, 0, len(inclTokens))


    gen.fileNb = oldFileNb
    parserCtx.currentFilePath = oldFilePath 
    parserCtx.currentFile = oldCurrFile 
}

consumeType(tokens []bahToken, start uint, end uint, isFuncDecl bool) [bahType*, uint] {
    if end - start == 0 {
        return [<bahType*>null, start]
    }

    r = new bahType

    i = start

    if isFuncDecl || tokens[i].cont == "function" {
        //function type
        r.type = BAH_TYPE_FUNC
        r.isNativePtr = true
        r.size = 8

        if isFuncDecl == false {
            i++
        }
        
        if i+1 >= end {
            throwError(&tokens[start], "Invalid function type.")
        }
        if tokens[i].cont != "(" {
            throwError(&tokens[i], "Expected function argument list.")
        }

        i++
        lastElem = r
        for i < end, i++ {
            if tokens[i].cont == ")" {
                break
            }

            if tokens[i].type != TOKEN_TYPE_VAR {
                throwError(&tokens[i], "Expected argument name.")
            }

            name = ""

            if isFuncDecl {
                name = tokens[i].cont

                i++

                if i == end {
                    throwError(&tokens[i-1], "Expected argument type after its name.")
                }
                
            }
            
            consArgType = consumeType(tokens, i, end, false)
            

            if consArgType[0] == null {
                throwError(&tokens[i], "Invalid argument type.")
            }
            argType bahType*

            if consArgType[0].type == BAH_TYPE_STRCT || consArgType[0].type == BAH_TYPE_CUSTOM_TYPE {
                argType = new bahType
                *argType = *(consArgType[0])
            } else {
                argType = consArgType[0]
            }

            argType.name = name
                
            
            i = consArgType[1]

            if i == end {
                throwError(&tokens[i-1], "Incomplete function type.")
            }

            if lastElem == r {
                lastElem.child = argType
            } else {
                lastElem.next = argType
            }
            lastElem = argType

            if tokens[i].cont != "," {
                break
            }
        }

        if i == end {
            throwError(&tokens[start], "Expected closing function type.")
        }

        if tokens[i].cont != ")" {
            throwError(&tokens[i], "Expected closing argument list in function type.")
        }
        i++

        retTypeCons = consumeType(tokens, i, end, false)
        if retTypeCons[0] != null {
            r.ret = retTypeCons[0]
            i = retTypeCons[1]
        }

    } else if tokens[i].cont == "[" && i+1 < end {
        if tokens[i+1].cont == "]" {
            //array type
            i += 2
            r.type = BAH_TYPE_ARRAY
            r.isNativePtr = true
            r.size = 8
            childCons = consumeType(tokens, i, end, false)
            if childCons[0] == null {
                throwError(&tokens[start], "Invalid array type without element type.")
            }
            i = childCons[1]
            r.child = childCons[0]
        } else {
            //tuple type

            r.type = BAH_TYPE_TUPLE
            
            currTp = r

            i++
            for i < end, i++ {
                tp = consumeType(tokens, i, end-1, false)

                if tp[0] == null {
                    throwError(&tokens[i], "Invalid type.")
                }

                if currTp == r {
                    currTp.child = tp[0]
                } else {
                    currTp.next = tp[0]
                }
                tp[0].offset = r.size
                r.size += tp[0].size

                currTp = tp[0]
                
                i = tp[1]

                if tokens[i].cont != "," {
                    break
                }
            }

            if tokens[i].cont != "]" {
                throwError(&tokens[i], "Expected closing tuple type.")
            }

            i++
        }
    } else {
        if tokens[i].type == TOKEN_TYPE_VAR {
            if tokens[i].cont == "float" {
                r.type = BAH_TYPE_FLOAT
                r.size = 8
            } else if tokens[i].cont == "float32" {
                r.type = BAH_TYPE_FLOAT
                r.size = 4
            } else if tokens[i].cont == "int16" {
                r.type = BAH_TYPE_INT
                r.size = 2
            } else if tokens[i].cont == "int32" {
                r.type = BAH_TYPE_INT
                r.size = 4
            } else if tokens[i].cont == "int" {
                r.type = BAH_TYPE_INT
                r.size = 8
            } else if tokens[i].cont == "byte" || tokens[i].cont == "char" {
                r.type = BAH_TYPE_UINT
                r.size = 1
            } else if tokens[i].cont == "uint16" {
                r.type = BAH_TYPE_UINT
                r.size = 2
            } else if tokens[i].cont == "uint32" {
                r.type = BAH_TYPE_UINT
                r.size = 4
            } else if tokens[i].cont == "uint" {
                r.type = BAH_TYPE_UINT
                r.size = 8
            } else if tokens[i].cont == "str" {
                r.type = BAH_TYPE_STR
                r.isNativePtr = true
                r.size = 8
            } else if tokens[i].cont == "bool" {
                r.type = BAH_TYPE_BOOL
                r.size = 1
            } else if tokens[i].cont == "ptr" {
                r.type = BAH_TYPE_PTR
                r.size = 8
                r.isNativePtr = true
            } else {
                r = parserCtx.findType(tokens[i].cont)
                if r == null {
                    return [<bahType*>null, i]
                }
            }

            i++
            for i < end, i++ {
                if tokens[i].cont != "*" {
                    break
                }
                r = r.getPtr()
            }
        } else if tokens[i].type == TOKEN_TYPE_KEYWORD {
            if tokens[i].cont == "buffer" {
                r.type = BAH_TYPE_BUFFER
                if i+2 >= end || tokens[i+1].cont != ":" || tokens[i+2].type != TOKEN_TYPE_INT {
                    throwError(&tokens[i], "Invalid buffer type. Expected buffer:size")
                }
                r.size = strToInt(tokens[i+2].cont)
                i += 3

            }
        } else {

            return [<bahType*>null, i]
        }
    }

    return [r, i]
}

consumeLeftValue(tokens []bahToken, start uint, end uint) [bahLeftValue*, uint, bool] {

    if start == end {
        return [<bahLeftValue*>null, start, false]
    }

    //handle dereference etc and fn call in dereference

    v bahVariable*

    t = tokens[start]

    if t.cont == "*" {
        if start + 1 == end {
            throwError(&t, "Expected a symbol after unary '*'.")
        }

        valCons = consumeLeftValue(tokens, start + 1, end)
        if valCons[0] == null {
            throwError(&tokens[start+1], "Expected left-value.")
        }

        i = valCons[1]
        varVal = valCons[0]

        if valCons[2] {
            throwError(&varVal.tok, "Cannot use not yet declared variable.")
        }

        if varVal.type.isPtr == false {
            throwError(&varVal.tok, "Cannot set the value of a non pointer symbol.")
        }


        val = new bahLeftValue {
            isUnary: true
            left: varVal
            tok: t
            type: varVal.type.child
        }

        return [val, i, false]
    }

    if t.type == TOKEN_TYPE_VAR {
        v = parserCtx.findVar(t.cont)
        isDeclared = v == null
        if isDeclared {
            val = new bahLeftValue {
                isVariable: true
                tok: t
            }
            return [val, start+1, true]
        }
    }

    if v == null {
        return [<bahLeftValue*>null, start+1, false]
    }

    if v.isConst {
        throwError(&t, "Cannot set the value of a constant.")
    }

    val = new bahLeftValue {
        tok: tokens[start]
        isVariable: true
        variable: v
        type: v.type
    }

    i = start+1
    for i < end, i++ {
        if tokens[i].cont == "." {
            if (val.type.isPtr == false && val.type.type != BAH_TYPE_STRCT) || (val.type.isPtr == true && val.type.child.type != BAH_TYPE_STRCT) {
                throwError(&tokens[i], "Cannot access member of a non structure value.")
            }

            parentVal = val
            val = new bahLeftValue {
                left: parentVal
                isStruct: true
            }
            i++
            if tokens[i].type != TOKEN_TYPE_VAR {
                throwError(&tokens[i], "Invalid member identifier.")
            }
            currTp bahType*
            if val.left.type.isPtr {
                currTp = val.left.type.child.child.next
            } else {
                currTp = val.left.type.child.next
            }

            for currTp != null, currTp = currTp.next {
                if currTp.name == tokens[i].cont {
                    break
                }
            }

            if currTp == null {
                throwError(&tokens[i], "Unknown structure member.")
            }

            membVal = new bahLeftValue {
                tok: tokens[i]
                type: currTp
            }
            val.type = currTp

            val.right = membVal
        } else if tokens[i].cont == "[" {
            if i + 2 >= end {
                throwError(&tokens[start+1], "Missing index value.")
            }
            arrStart = i
            nbEncl = 1
            brackEnd = end-1
            i++
            for i < end, i++ {
                t = tokens[i]
                if t.type != TOKEN_TYPE_ENCL {
                    continue
                }
                
                if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                    nbEncl++
                } else {
                    if nbEncl == 0 {
                        throwError(&t, "One too many token.")
                    }
                    nbEncl--
                    if nbEncl == 0 {
                        brackEnd = i
                        break
                    }
                    continue
                }
                
            }

            r = consumeValue(tokens, arrStart+1, brackEnd+1, arrStart, 0)
            
            if r[0] == null {
                throwError(&tokens[start+2], "Expected value as index.")
            }

            parentVal = val

            if parentVal.type.type == BAH_TYPE_BUFFER {
                val = new bahLeftValue {
                    isBuffer: true
                    left: parentVal
                    index: r[0]
                }
                val.type = new bahType {
                    size: 1
                    type: BAH_TYPE_UINT
                }
            } else if parentVal.type.type == BAH_TYPE_ARRAY {
                val = new bahLeftValue {
                    isArray: true
                    left: parentVal
                    index: r[0]
                    type: parentVal.type.child
                }
            } else if parentVal.type.type == BAH_TYPE_TUPLE {
                
                if r[0].isStaticValue == false {
                    throwError(&tokens[arrStart+1], "Cannot index a tuple by non static value.")
                }

                indexSym = generateBahValueSymbol(r[0], null)
                indexVal = strToInt(indexSym.name[1:])

                if indexVal < 0 {
                    throwError(&tokens[start+2], "Index cannot be less than 0.")
                }

                index = 0
                currTp = val.type.child
                for index < indexVal, index++ {
                    if currTp == null {
                        break
                    }

                    currTp = currTp.next
                }

                if currTp == null {
                    throwError(&tokens[arrStart+1], "Cannot access tuple's value of index larger than its length.")
                }

                val = new bahLeftValue {
                    isTuple: true
                    left: parentVal
                    index: r[0]
                    type: currTp
                }
            } else {
                throwError(&tokens[arrStart+1], "Cannot use lvalue as indexable symbol.")
            }

        
            if parentVal.type.isPtr {
                throwError(&val.tok, "Cannot use a pointer as indexable symbol.")
            }

            if parentVal.type.type == BAH_TYPE_STR {
                throwError(&val.tok, "Cannot set the value of a str by index.")
            }
            
            //handle buffers and maps
        } else {
            break
        }
    }

    //handle arrays, structs...

    return [val, i, false]
}

consumeValue(tokens []bahToken, start uint, end uint, parentStart int, opLevel uint) [bahValue*, uint] {

    i = start
    nbPar = 0
    parStart = start




    if parentStart != -1 {
        nbEncl = 0
        for start >= parentStart, start-- {
            t = tokens[start]
            if t.type == TOKEN_TYPE_ENCL {
                if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                    nbEncl--

                    continue
                }
                nbEncl++
            }

            if nbEncl == 0 && (t.cont == "," || t.cont == "=") {
                break
            }
        }
        start++

        isArrayDeclare = start+2 < end && tokens[start].cont == "[" && tokens[start+1].cont == "]" && (tokens[start+2].type == TOKEN_TYPE_VAR || tokens[start+2].cont == "["  || tokens[start+2].type == TOKEN_TYPE_KEYWORD)

        if isArrayDeclare == false && tokens[start].type == TOKEN_TYPE_ENCL {
            start++
            end--
        }

        r = consumeValue(tokens, start, end, -1, 0)

        if isArrayDeclare {
            r[1]--
        } else if tokens[start].type == TOKEN_TYPE_ENCL {
            r[1]++
        }

        if r[0].isOperation {
            r[0].pemdas = 5
        }

        return r
    }

    val = new bahValue
    consumedVal = false

    if tokens[start].cont == "(" {
        // tokens[end-1].cont == ")"
        nbEncl = 1
        parEnd = end-1
        i = start+1; for i < end, i++ {
            t = tokens[i]
            if t.type != TOKEN_TYPE_ENCL {
                continue
            }
            
            if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                nbEncl++
            } else {
                if nbEncl == 0 {
                    throwError(&t, "One too many token.")
                }
                nbEncl--
                if nbEncl == 0 {
                    parEnd = i
                    break
                }
                continue
            }
            
        }

        moreThanThis = false
        i++
        for i < end, i++ {
            if tokens[i].cont == "," || tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" || tokens[i].cont == "."  {
                break
            }
            if tokens[i].cont != ")" && tokens[i].cont != "]" && tokens[i].cont != "}" {
                moreThanThis = true
                break
            }
        }


        if moreThanThis == false {
            r = consumeValue(tokens, start+1, parEnd, parentStart, 0)
            
            if r[0].isOperation {
                r[0].pemdas = 5
            }

            if r[1] + 1 == end || tokens[r[1] + 1].cont == "," {
                r[1]++
                return r
            }

            start = r[1]
            val = r[0]
            consumedVal = true
            opLevel = 5
        }

    }

    if opLevel == 5 {
        t = tokens[start]


        if consumedVal == false {


            if t.type == TOKEN_TYPE_CAST {
                castToks = lexer(t.cont[1:len(t.cont)-1])
                typeCons = consumeType(castToks, 0, len(castToks), false)
                if typeCons[1] != len(castToks) || typeCons[0] == null {
                    throwError(&t, "Invalid cast type.")
                }

                nvCons = consumeValue(tokens, start+1, end, parentStart, opLevel)

                if nvCons[0] == null {
                    throwError(&tokens[start], "Missing value after type cast.")
                }

                tp = typeCons[0]
                val.isCast = true
                val.tok = t

                val.type = typeCons[0]
                val.left = nvCons[0]

                return [val, nvCons[1]]
            }

            if t.cont == "new" || (t.type == TOKEN_TYPE_VAR && i+1 < end && tokens[i+1].cont == "{") {
                st bahType*
                if t.cont == "new" {
                    st = parserCtx.findType(tokens[i+1].cont)
                    i++
                } else {
                    st = parserCtx.findType(t.cont)
                }

                if st == null {
                    throwError(&tokens[i], "Unknown structure.")
                }
                currTp = st.child

                val.isStructDeclare = true
                val.type = st
                val.tok = tokens[i]
                currVal = val

                i += 2
                nbBraces uint = 1
                for i < end, i++ {
                    if tokens[i].cont == "{" {
                        nbBraces++
                    } else if tokens[i].cont == "}" {
                        nbBraces--
                        if nbBraces == 0 {
                            break
                        }
                    }


                    //field: value
                    if i+2 < end && tokens[i+1].cont == ":" {
                        if tokens[i].type != TOKEN_TYPE_VAR {
                            throwError(&tokens[i], "Expected field name.")
                        }
                        nameTok = tokens[i]
                        currTp = st.child.next
                        for currTp != null, currTp = currTp.next {
                            if currTp.name == nameTok.cont {
                                break
                            }
                        }

                        if currTp == null {
                            throwError(&tokens[i], "Unknown field name in structure declaration.")
                        }
                        i += 2
                        currLine = nameTok.line
                        nbEncls = 0
                        j=i; for j < end, j++ {
                            if tokens[j].cont == "(" || tokens[j].cont == "[" || tokens[j].cont == "{" {
                                nbEncls++
                            } else if tokens[j].cont == ")" || tokens[j].cont == "]" || tokens[j].cont == "}" {
                                nbEncls--
                                // if nbEncls == 0 {
                                //     printDebugContext()

                                //     j++
                                //     break
                                // }
                            }

                            if nbEncls > 0 {
                                currLine = tokens[j].line
                                continue
                            }

                            if tokens[j].line != currLine {
                                if tokens[j].begLine == currLine {
                                    currLine = tokens[j].line
                                    continue
                                }

                                break
                            }
                        }

                        valCons = consumeValue(tokens, i, j, i, 0)
                        if valCons[0] == null {
                            throwError(&tokens[i], "Expected value.")
                        }

                        i = valCons[1] - 1
                        if i < j-1 {
                            throwError(&tokens[i], "Did not expect anything after field value.")
                        }
                        fieldVal = valCons[0]
                        if compatibleTypes(currTp, fieldVal.type) == false {
                            throwTypeError(fieldVal, currTp)
                        }

                        currVal.left = new bahValue {
                            tok: nameTok
                            type: currTp
                        }
                        currVal.left.right = fieldVal
                        currVal = currVal.left
                        
                    } else { //value, value
                        currTp = currTp.next

                        if currTp == null {
                            throwError(&tokens[i], "Unknown field position in structure declaration.")
                        }
                        valCons = consumeValue(tokens, i, end-1, i, 0)
                        if valCons[0] == null {
                            throwError(&tokens[i], "Expected value.")
                        }

                        i = valCons[1]
                        fieldVal = valCons[0]
                        if compatibleTypes(currTp, fieldVal.type) == false {
                            throwTypeError(fieldVal, currTp)
                        }

                        currVal.left = new bahValue {
                            tok: fieldVal.tok
                            type: currTp
                        }
                        currVal.left.right = fieldVal
                        currVal = currVal.left

                        if tokens[i].cont != "," {
                            if tokens[i].cont == "}" {
                                break
                            }
                            throwError(&tokens[i], "Expected separator between values.")
                        }
                    }

                }

                currTp = st.child
                for currTp != null, currTp = currTp.next {
                    defVal = <bahValue*>currTp.defaultValue

                    if defVal == null {
                        if currTp.type == BAH_TYPE_ARRAY {
                            defVal = new bahValue {
                                isArrayDeclare: true
                            }
                            defVal.type = new bahType {
                                type: BAH_TYPE_ARRAY
                                size: ARR_TYPE_SIZE
                                isNativePtr: true
                                child: currTp.child
                            }
                        } else {
                            continue
                        }
                    }

                    currVal = val.left
                    for currVal != null, currVal = currVal.left {
                        if currVal.tok.cont == currTp.name {
                            break
                        }
                    }

                    if currVal == null {
                        currVal = val.left
                        val.left = new bahValue {
                            type: currTp
                            right: defVal
                            left: currVal
                        }
                    }
                } 


                if t.cont == "new" {
                    val.type = val.type.getPtr()
                }

                return [val, i+1]
            }

            if t.cont == "buffer" {
                if i+1 == end || tokens[i+1].type != TOKEN_TYPE_INT {
                    throwError(&tokens[i], "Expected buffer length after buffer keyword.")
                }

                val.isBufferDeclare = true
                val.type = new bahType {
                    type: BAH_TYPE_BUFFER
                    size: strToInt(tokens[i+1].cont)
                    isNativePtr: true
                }

                return [val, i+2]
            }

            if t.cont == "[" && i+2 < end && tokens[i+1].cont == "]" {
                tp = consumeType(tokens, i+2, end, false)

                if tp[0] == null {
                    throwError(&tokens[i+2], "Unknown array element type.")
                }

                i = tp[1]

                val.isArrayDeclare = true
                val.tok = t
                val.type = new bahType {
                    type: BAH_TYPE_ARRAY
                    size: ARR_TYPE_SIZE
                    isNativePtr: true
                    child: tp[0]
                }

                if i < end && tokens[i].cont == "{" {
                    nbBraces uint = 1
                    i++
                    currVal = val
                    
                    for i < end, i++ {
                        if tokens[i].cont == "{" {
                            nbBraces++
                        } else if tokens[i].cont == "}" {
                            nbBraces--
                            if nbBraces == 0 {
                                break
                            }
                        }

                        valCons = consumeValue(tokens, i, end-1, i, 0)

                        if valCons[0] == null {
                            throwError(&tokens[i], "Cannot use as value.")
                        }

                        if compatibleTypes(valCons[0].type, val.type.child) == false {
                            throwTypeError(valCons[0], val.type.child)
                        }

                        i = valCons[1]

                        currVal.right = new bahValue {
                            left: valCons[0]
                        }
                        currVal = currVal.right

                        if i < end && tokens[i].cont != "," && tokens[i].cont != "}" {
                            throwError(&tokens[i], "Expected coma between values.")
                        }

                    }

                    
                }

                return [val, i+1]
            }

            if t.cont == "[" && i + 2 < end {
                val.type = new bahType {
                    type: BAH_TYPE_TUPLE
                }

                val.isTupleDeclare = true
                val.tok = t

                currVal = val
                currTp = val.type
                i++
                for i < end, i++ {

                    elemVal = consumeValue(tokens, i, end-1, start+1, 0)


                    if elemVal[0] == null {
                        throwError(&tokens[i], "Expected a value inside tuple declaration.")
                    }

                    elemType = new bahType
                    *elemType = *(elemVal[0].type)

                    if currTp == val.type {
                        currTp.child = elemType
                    } else {
                        currTp.next = elemType
                    }
                    currTp = elemType

                    //todo: alignment?
                    elemType.offset = val.type.size
                    val.type.size += elemType.size

                    currVal.left = new bahValue {
                        right: elemVal[0]
                    }
                    currVal = currVal.left

                    i = elemVal[1]

                    if tokens[i].cont != "," {
                        break
                    }
                }

                i++
                return [val, i]
            }

            if t.cont == "&" {
                if start+1 == end {
                    throwError(&t, "Expected a symbol to get pointer from.")
                }
                valCons = consumeValue(tokens, start + 1, end, parentStart, opLevel)
                i = valCons[1]

                if valCons[0] == null {
                    throwError(&tokens[start+1], "Expected addressable value.")
                }

                varVal = valCons[0]

                // if varVal.isVariable == false {
                //     throwError(&varVal.tok, "Cannot get pointer of anything other than a variable.")
                // }

                nt = valCons[0].type.getPtr()

                *val = *varVal
                val.type = nt
                val.isPointer = true

                return [val, i]

            }
            
            if t.cont == "*" {
                if start+1 == end {
                    throwError(&t, "Expected a symbol to access value from pointer.")
                }
                valCons = consumeValue(tokens, start + 1, end, parentStart, opLevel)
                i = valCons[1]

                if valCons[0] == null {
                    throwError(&tokens[start+1], "Expected value as an address.")
                }

                varVal = valCons[0]

                if valCons[0].type.isPtr == false {
                    throwError(&varVal.tok, "Cannot access value of a non-pointer type.")
                }

                nt = valCons[0].type.child

                val.type = nt
                val.isUnary = true
                val.left = varVal

                return [val, i]
            }
            
            if t.isValue == false {
                throwError(&t, "Value expected.")
            }

            val.tok = t

            if t.type == TOKEN_TYPE_VAR {
                if t.cont[0] == '$' {
                    val.isReg = true
                    val.type = new bahType {
                        size: 8
                        type: BAH_TYPE_UINT
                    }
                } else {
                    v = parserCtx.findVar(t.cont)

                    if v != null {
                        val.isVariable = true
                        val.type = v.type
                        val.sym = v.sym
                    } else {
                        fn = parserCtx.findFunc(t.cont)
                        if fn != null {
                            val.isFunctionSym = true
                            val.type = fn.type
                            val.isStaticValue = true
                        } else {
                            throwError(&t, "Unknown symbol.")
                        }
                    }
                }
            } else if t.type == TOKEN_TYPE_BOOL {
                val.type = new bahType {
                    size: 1
                    type: BAH_TYPE_BOOL
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_INT {
                val.type = new bahType {
                    size: 8
                    type: BAH_TYPE_INT
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_FLOAT {
                val.type = new bahType {
                    size: 8
                    type: BAH_TYPE_FLOAT
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_STR {
                val.type = new bahType {
                    size: 8
                    type: BAH_TYPE_STR
                    isNativePtr: true
                }
                val.isStaticValue = true
            } else if t.type == TOKEN_TYPE_CHAR {
                val.type = new bahType {
                    size: 1
                    type: BAH_TYPE_UINT
                }
                val.isStaticValue = true
            } else {
                val = null
            }

            if end - start == 1 || tokens[start+1].type == TOKEN_TYPE_SYNTAX || tokens[start+1].cont == ")" || tokens[start+1].cont == "]" || tokens[start+1].cont == "}" {
                return [val, start + 1]
            }

            if val == null {
                throwError(&t, "Expected a value.")
            }
        }

        for start < end {
            if tokens[start+1].cont == "(" {
                if val.type.type != BAH_TYPE_FUNC {
                    throwError(&t, "Cannot use symbol as function.")
                }


                if tokens[start].cont == "sizeof" {
                    tp = consumeType(tokens, start+2, end, false)
                    i = tp[1]

                    if tp[0] == null {
                        throwError(&tokens[start+2], "Unknown type.")
                    }

                    val.isStaticValue = true
                    val.isFunctionSym = false
                    val.sym = gen.staticInt(uintToStr(tp[0].size))
                    val.type = new bahType {
                        type: BAH_TYPE_UINT
                        size: 8
                    }

                    if tokens[i].cont != ")" {
                        throwError(&tokens[start+3], "Sizeof can only take one argument.")
                    }

                    
                    start = i
                    continue
                }

                fnSymVal = val
                val = new bahValue
                val.isFunctionCall = true
                val.left = fnSymVal
                val.tok = fnSymVal.tok
                val.type = fnSymVal.type.ret

                currArg = fnSymVal.type.child
                currArgVal = val


                i = start + 2
                nbPar = 1

                if val.left.isStruct && val.left.type.child != null && val.left.type.child.isPtr && (val.left.left.type.isPtr && compatibleTypes(val.left.left.type, val.left.type.child) || val.left.left.type.isPtr == false && compatibleTypes(val.left.left.type, val.left.type.child.child)) {
                    currArg = currArg.next
                }

                for i < end, i++ {
                    if tokens[i].cont == ")" {
                        break
                    }

                    if currArg == null {
                        throwError(&tokens[i], "Too many arguments in function call.")
                    }

                    argCons = consumeValue(tokens, i, end, -1, 0)
                    i = argCons[1]


                    if argCons[0] == null {
                        throwError(&tokens[i], "Expected value as argument in function call.")
                    }

                    if currArg.type == BAH_TYPE_STRCT && currArg.child.name == "reflectElement" && (argCons[0].type.type != BAH_TYPE_STRCT || argCons[0].type.child.name != "reflectElement") {
                        currArgVal.right = new bahValue {
                            isArgumentList: true
                            isReflect: true
                            left: argCons[0]
                            type: currArg
                        }
                    } else {
                        if argCons[0].type.type == BAH_TYPE_ARRAY && currArg.isPtr && currArg.child.type == BAH_TYPE_STRCT && currArg.child.child.name == "Bah_Array_Type" {
                            argCons[0].type = currArg
                        } else if compatibleTypes(argCons[0].type, currArg) == false {
                            if argCons[0].type.type != BAH_TYPE_STR || currArg.isPtr == false || currArg.child.type != BAH_TYPE_UINT || currArg.child.size != 1 {
                                throwTypeError(argCons[0], currArg)
                            }
                        }

                        currArgVal.right = new bahValue {
                            isArgumentList: true
                            left: argCons[0]
                            type: currArg
                        }
                    }

                    currArgVal = currArgVal.right
                    currArg = currArg.next

                    if i == end {
                        throwError(&t, "Missing end of function call.")
                    }

                    if tokens[i].cont != "," && tokens[i].cont != ")" {
                        throwError(&tokens[i], "Expected separator between arguments in function call.")
                    } else if tokens[i].cont == ")" {
                        i--
                    }

                }

                if currArg != null {
                    throwError(&tokens[i], "Missing arguments.")
                }

                start = i
            } else if tokens[start+1].cont == "[" {
                //TODO: handle splits and others (value1 : value2)
                if start + 3 >= end {
                    throwError(&tokens[start+1], "Missing index value.")
                }

                nbEncl = 1
                brackEnd = end-1
                splitIndex = -1
                i = start+2; for i < end, i++ {
                    t = tokens[i]
                    if t.type != TOKEN_TYPE_ENCL {
                        if t.cont == ":" {
                            splitIndex = i
                        }
                        continue
                    }
                    
                    if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                        nbEncl++
                    } else {
                        if nbEncl == 0 {
                            throwError(&t, "One too many token.")
                        }
                        nbEncl--
                        if nbEncl == 0 {
                            brackEnd = i
                            break
                        }
                        continue
                    }
                    
                }

                if splitIndex != -1 {
                    left bahValue* = null
                    right bahValue* = null

                    if splitIndex > start + 2 {
                        leftCons = consumeValue(tokens, start+2, splitIndex, parentStart, 0)
                        left = leftCons[0]
                        if left == null {
                            throwError(&tokens[start+2], "Expected value as begining index.")
                        }
                    }

                    if splitIndex+1 < brackEnd {
                        rightCons = consumeValue(tokens, splitIndex+1, brackEnd, parentStart, 0)
                        right = rightCons[0]
                        if right == null {
                            throwError(&tokens[start+2], "Expected value as length.")
                        }
                    }

                    if val.type.type != BAH_TYPE_ARRAY && val.type.type != BAH_TYPE_STR {
                        throwError(&val.tok, "Cannot use symbol as indexable type.")
                    }

                    val = new bahValue {
                        tok: val.tok
                        isSplit: true
                        left: val
                        type: val.type
                    }

                    val.right = new bahValue {
                        left: left
                        right: right
                    }

                } else {
                    r = consumeValue(tokens, start+2, brackEnd, parentStart, 0)
                    
                    if r[0] == null {
                        throwError(&tokens[start+2], "Expected value as index.")
                    }
                
                    nt = val.type

                    if val.type.isPtr {
                        throwError(&val.tok, "Cannot use a pointer as indexable symbol.")
                    }

                    if val.type.type == BAH_TYPE_TUPLE {

                        if r[0].isStaticValue == false {
                            throwError(&tokens[start+2], "Cannot index a tuple by non static value.")
                        }

                        indexSym = generateBahValueSymbol(r[0], null)
                        indexVal = strToInt(indexSym.name[1:])

                        if indexVal < 0 {
                            throwError(&tokens[start+2], "Index cannot be less than 0.")
                        }

                        index = 0
                        currTp = val.type.child
                        for index < indexVal, index++ {
                            if currTp == null {
                                break
                            }

                            currTp = currTp.next
                        }

                        if currTp == null {
                            throwError(&tokens[start+2], "Cannot access tuple's value of index larger than its length.")
                        }

                        val = new bahValue {
                            tok: val.tok
                            isIndexed: true
                            left: val
                            right: r[0]
                            type: currTp
                        }

                    } else {
                        if val.type.type == BAH_TYPE_STR || val.type.type == BAH_TYPE_BUFFER {
                            nt = new bahType {
                                type: BAH_TYPE_UINT
                                size: 1
                            }
                        } else if val.type.type == BAH_TYPE_ARRAY {
                            nt = val.type.child
                        } else {
                            throwError(&val.tok, "Cannot use symbol as indexable type.")
                        }

                        varSym = val
                        val = new bahValue {
                            tok: varSym.tok
                            isIndexed: true
                            left: varSym
                            right: r[0]
                            type: nt
                        }
                    }
                }

                start = i
            } else if tokens[start+1].cont == "." {
                if (val.type.isPtr == false && val.type.type != BAH_TYPE_STRCT) || (val.type.isPtr && val.type.child.type != BAH_TYPE_STRCT) {
                    throwError(&val.tok, "Cannot access the member of a value that is not a structure.")
                }

                i = start + 2

                memb = new bahValue {
                    tok: tokens[i]
                }
                
                currTp bahType*

                if val.type.isPtr {
                    currTp = val.type.child.child.next
                } else {
                    currTp = val.type.child.next
                }

                for currTp != null, currTp = currTp.next {
                    if currTp.name == tokens[i].cont {
                        break
                    }
                }

                if currTp == null {
                    strctType = val.type
                    if val.type.isPtr {
                        strctType = val.type.child
                    }

                    method = parserCtx.findFunc(strctType.child.name+"."+tokens[i].cont)
                    if method == null {
                        throwError(&tokens[i], "Unknown struct member.")
                    }

                    memb.isFunctionSym = true
                    memb.sym = asmSymbolValue(method.name)

                    val = new bahValue {
                        isStruct: true
                        left: val
                        right: memb
                        type: method.type
                        tok: tokens[start+1]
                    }

                } else {
                    memb.type = currTp

                    varSym = val
                    val = new bahValue {
                        isStruct: true
                        left: varSym
                        right: memb
                        type: memb.type
                        tok: tokens[start+1]
                    }
                }


                start = i
            } else {
                break
            }
        }

        // if val.isOperation {
        //     printDebugContext()

        // }

        return [val, start+1]

        //handle arrays, structs..
        //in else statement

    }

    for i < end, i++ {
        if tokens[i].cont == "(" || tokens[i].cont == "[" || tokens[i].cont == "{" {
            if nbPar == 0 {
                parStart = i
            }
            nbPar++
        } else if tokens[i].cont == ")" || tokens[i].cont == "]" || tokens[i].cont == "}" {
            nbPar--
            continue
        }

        if nbPar > 0 {
            continue
        }

        if tokens[i].cont == "," {
            break
        }
        
        if i > start && opLevel == 3 && (tokens[i].type == TOKEN_TYPE_INT || tokens[i].type == TOKEN_TYPE_FLOAT) && tokens[i].cont[0] == '-' && tokens[i-1].type != TOKEN_TYPE_CAST && tokens[i-1].type != TOKEN_TYPE_SYNTAX {
            leftCons = consumeValue(tokens, i-1, i, <int>start, opLevel+1)
            if leftCons[0] != null {

                val = new bahValue{
                    pemdas: opLevel
                    isOperation: true
                    left: leftCons[0]
                }
                val.tok = bahToken {
                    cont: "+"
                }
                rightCons = consumeValue(tokens, i, end, -1, opLevel)
                if rightCons[0] == null {
                    throwError(&tokens[i+1], "Cannot do operation on non value on the right.")
                }
                val.right = rightCons[0]
                i = rightCons[1]

                if compatibleTypes(val.left.type, val.right.type) == false {
                    throwError(&val.right.tok, "Wrong type.")
                }

                if val.right.type.size > val.left.type.size {
                    val.type = val.right.type
                } else {
                    val.type = val.left.type
                }

                return [val, i]
            }
        }

        if i > start && i+1 < end {
            if (opLevel == 0 && (tokens[i].cont == "||")) || (opLevel == 1 && (tokens[i].cont == "&&")) || (opLevel == 2 && (tokens[i].cont == "<" || tokens[i].cont == ">" || tokens[i].cont == ">=" || tokens[i].cont == "<=" || tokens[i].cont == "==" || tokens[i].cont == "!=")) || (opLevel == 3 && (tokens[i].cont == "in" || tokens[i].cont == "+" || tokens[i].cont == "-")) || (opLevel == 4 && (tokens[i].cont == "*" || tokens[i].cont == "/" || tokens[i].cont == "%"))  {
                if tokens[i].cont == "*" && i+1 < end && tokens[i+1].cont == "{" {
                    continue
                }

                val = new bahValue{
                    tok: tokens[i]
                    pemdas: opLevel
                    isOperation: true
                }
                leftCons = consumeValue(tokens, i-1, i, <int>start, opLevel+1)
                val.left = leftCons[0]

                if val.left == null {
                    if (tokens[i].cont == "*" || tokens[i].cont == "&") {
                        //is a pointer dereference or pointer
                        continue
                    }
                    throwError(&tokens[i-1], "Cannot do operation on non value on the left.")
                } else if val.left.isCast && (tokens[i].cont == "*" || tokens[i].cont == "&") {
                    val = val.left
                    continue
                }

                if tokens[i+1].cont == tokens[i].cont && (tokens[i].cont == "+" || tokens[i].cont == "-") {
                    if val.left.type.type != BAH_TYPE_INT && val.left.type.type != BAH_TYPE_UINT {
                        throwError(&val.left.tok, "Cannot increment/decrement a symbol that is not an integer.")
                    }
                    val.isSelfOp = true
                    i++
                } else {
                    rightCons = consumeValue(tokens, i+1, end, -1, opLevel)
                    if rightCons[0] == null {
                        throwError(&tokens[i+1], "Cannot do operation on non value on the right.")
                    }
                    val.right = rightCons[0]
                    i = rightCons[1]

                    if val.tok.cont == "in" {
                        if val.right.type.type != BAH_TYPE_ARRAY {
                            throwError(&val.right.tok, "Cannot use 'in' operator on anything other than an array.")
                        }

                        if compatibleTypes(val.left.type, val.right.type.child) == false {
                            throwTypeError(val.right, val.left.type)
                        }
                    } else if compatibleTypes(val.left.type, val.right.type) == false {
                        throwTypeError(val.right, val.left.type)
                    }

                    if val.tok.cont == "||" || val.tok.cont == "&&" || val.tok.cont == "<" || val.tok.cont == ">" || val.tok.cont == "<=" || val.tok.cont == ">=" || val.tok.cont == "==" || val.tok.cont == "in" || val.tok.cont == "!=" {
                        val.type = new bahType {
                            type: BAH_TYPE_BOOL
                            size: 1
                        }
                    } else {
                        if val.right.type.size > val.left.type.size {
                            val.type = val.right.type
                        } else {
                            val.type = val.left.type
                        }
                    }
                }

                return [val, i]
            }
        }

    }

    if opLevel == 5 {
        return [<bahValue*>null, start]
    }

    return consumeValue(tokens, start, end, -1, opLevel+1)
}



parseHashDirective(tokens []bahToken, start uint, end uint) {

    if tokens[start].cont == "#linux" || tokens[start].cont == "#darwin" || tokens[start].cont == "#windows" {
        if tokens[start].cont[1:] == BAH_OS {
            parseLines(tokens, start+2, end-1)
        }
        return
    }
    
    if parserCtx.scope > 0 {
        throwError(&tokens[start], "Directive should be used at global scope.")
    }

    if tokens[start].cont == "#cLib" {
        i=start+1; for i < end, i++ {
            if tokens[i].type != TOKEN_TYPE_STR {
                throwError(&tokens[i], "Expected library name.")
            }

            parserCtx.libraries[len(parserCtx.libraries)] = tokens[i].cont[1:len(tokens[i].cont)-1]
        }

    } else if tokens[start].cont == "#define" {
        if end - start < 3 {
            throwError(&tokens[start], "Invalid use of #define.")
        }

        if tokens[start+2].cont == "(" {
            fnTypeCons = consumeType(tokens, start+2, end, true)
            fnType = fnTypeCons[0]
            i = fnTypeCons[1]

            if fnType == null {
                throwError(&tokens[start], "Invalid function type in function definition.")
            }

            fn = new bahFunction {
                name: tokens[start+1].cont
                type: fnType
            }


            if tokens[start+1].cont == "main" && fnType.toStr() != "function([]str) int" {
                throwError(&tokens[start], "Invalid main function type, should be: function([]str) int.")
            }

            parserCtx.addFunc(fn)

            if i != end {
                throwError(&tokens[i], "Didn't expected anything after function definition.")
            }
        } else {
            if tokens[start+1].type != TOKEN_TYPE_VAR {
                throwError(&tokens[start+1], "Expected type name.")
            }

            tp = consumeType(tokens, start+2, end, false)

            if tp[0] == null {
                throwError(&tokens[start+2], "Invalid type.")
            }

            if parserCtx.findType(tokens[start+1].cont) != null {
                throwError(&tokens[start+1], "Type already exists.")
            }

            nt = new bahType {
                name: tokens[start+1].cont
                type: BAH_TYPE_CUSTOM_TYPE
                size: tp[0].size
                child: tp[0]
            }

            parserCtx.addType(nt)
        }
    } else if tokens[start].cont == "#include" {
        if end - start != 2 || tokens[start+1].type != TOKEN_TYPE_STR {
            throwError(&tokens[start], "Invalid use of #include.")
        }

        inclFileName = tokens[start+1].cont[1:len(tokens[start+1].cont)-1]

        currDirectory = absPath(parserCtx.currentFilePath)
        i=len(currDirectory)-1; for i != -1, i-- {
            if currDirectory[i] == '/' {
                break
            }
        }
        
        currDirectory = currDirectory[:i+1]
        filePath = currDirectory + inclFileName

        if fileExists(filePath) == false {
            filePath = BAH_DIR + "/" + inclFileName
            if fileExists(filePath) == false {
                throwError(&tokens[start+1], "Cannot find file.")
            }
        }

        includeFile(filePath)

    } else if tokens[start].cont == "#import" {
        if end - start != 2 || tokens[start+1].type != TOKEN_TYPE_STR {
            throwError(&tokens[start], "Invalid use of #import.")
        }

        inclFileName = tokens[start+1].cont[1:len(tokens[start+1].cont)-1]

        currDirectory = absPath(parserCtx.currentFilePath)
        i=len(currDirectory)-1; for i != -1, i-- {
            if currDirectory[i] == '/' {
                break
            }
        }
        
        currDirectory = currDirectory[:i+1]
        filePath = currDirectory + inclFileName

        if fileExists(filePath) == false {
            filePath = BAH_DIR + "/" + inclFileName
            if fileExists(filePath) == false {
                throwError(&tokens[start+1], "Cannot find file.")
            }
        }
        filePath = absPath(filePath)

        if filePath in parserCtx.parsedFiles {
            return
        }

        parserCtx.parsedFiles[len(parserCtx.parsedFiles)] = filePath

        fs = fileStream{}
        fs.open(filePath, "r")
        content = fs.readContent()
        fs.close()


        oldFilePath = parserCtx.currentFilePath 
        oldCurrFile = parserCtx.currentFile 
        oldFileNb = gen.fileNb

        parserCtx.currentFilePath = filePath
        parserCtx.currentFile = content

        // cf = getCacheFile(filePath)
        // if cf == null || isValidCacheFile(cf) == false {
        //     println(ASCII_GREY+"[compiling] "+ASCII_RESET+filePath)

        //     compDirectory = parserCtx.currentFilePath
        //     i=len(compDirectory)-1; for i != -1, i-- {
        //         if compDirectory[i] == '/' {
        //             break
        //         }
        //     }
        //     compDirectory = compDirectory[:i+1]

        //     setCurrentPath(compDirectory)
        //     cmd = command(compilerPath+" "+filePath+" - object -o "+BAH_DIR+"cache/"+pathToVarName(cf.file)+".o")
        //     cmd.runBytes()

        // }

        inclTokens = lexer(content)

        gen.generateFileLocation(parserCtx.currentFilePath)
        parseLines(inclTokens, 0, len(inclTokens))


        gen.fileNb = oldFileNb
        parserCtx.currentFilePath = oldFilePath 
        parserCtx.currentFile = oldCurrFile 

    } else if tokens[start].cont == "#init" {
        realGen = gen
        gen = initFnGen
        gen.fileNb = realGen.fileNb
        gen.totalFileNb = realGen.totalFileNb

        parseLine(tokens, start+1, end)

        realGen.data += gen.data
        realGen.bss += gen.bss
        gen = realGen
    } else {
        throwError(&tokens[start], "Unknown directive.")
    }

}

parseReturn(tokens []bahToken, start uint, end uint) {

    if parserCtx.scope == 0 {
        throwError(&tokens[start], "Cannot return outside of a function.")
    }

    if start+1 == end {
        //handle only return if no ret type
        if parserCtx.scopeCtx.currentFunction.type.ret != null {
            throwError(&tokens[start], "Expected return value.")
        }

        gen.generateEarlyReturn()
        return
    }

    valCons = consumeValue(tokens, start+1, end, -1, 0)
    val = valCons[0]
    if val == null {
        throwError(&tokens[start+1], "Expected value, cannot return anything other than a value.")
    }

    if valCons[1] != end {
        throwError(&tokens[valCons[1]], "Did not expect anything after the return statement.")
    }

    if parserCtx.scopeCtx.currentFunction.type.ret == null {
        throwError(&val.tok, "Did not expect a return value.")
    }
    
    if compatibleTypes(parserCtx.scopeCtx.currentFunction.type.ret, val.type) == false {
        throwTypeError(val, parserCtx.scopeCtx.currentFunction.type.ret)
    }

    parserCtx.scopeCtx.hasReturned = true


    valSym = generateBahValueSymbol(val, null)

    gen.generateReturn(valSym)

}

parseIf(tokens []bahToken, start uint, end uint) {
    nbPar = 1
    i = end-2
    ifLineEnd = end
    for i != -1, i-- {
        if tokens[i].cont == "{" {
            nbPar--
            if nbPar == 0 {
                ifLineEnd = i
                break
            }
        } else if tokens[i].cont == "}" {
            nbPar++
        }
    }



    condValCons = consumeValue(tokens, start+1, ifLineEnd, -1, 0)
    if condValCons[0] == null {
        throwError(&tokens[start+1], "Expected a condition in if statement.")
    }

    gen.generateIf(generateBahValueSymbol(condValCons[0], null))



    ifScope = new parserScope {
        isConditional: true
        currentFunction: parserCtx.scopeCtx.currentFunction
    }

    parserCtx.startScope(ifScope)

    parseLines(tokens, ifLineEnd+1, end-1)

    parserCtx.endScope()

    gen.generateEndIf()

    if end < len(tokens) && tokens[end].cont == "else" {

        parserCtx.scopeCtx.ifChainLabels[len(parserCtx.scopeCtx.ifChainLabels)] = len(gen.instructions) - 1
        parserCtx.scopeCtx.ifChainLength++
    } else {

        clear(parserCtx.scopeCtx.ifChainLabels)
        parserCtx.scopeCtx.ifChainLength = 0
    }

}

parseElse(tokens []bahToken, start uint, end uint) {

    if parserCtx.scopeCtx.ifChainLength == 0 {
        throwError(&tokens[start], "Did not expect else block here.")
    }

    elseLineEnd = start + 1

    if end - start > 1 && tokens[start+1].cont == "if" {
        nbPar = 1
        i = end-2
        for i != -1, i-- {
            if tokens[i].cont == "{" {
                nbPar--
                if nbPar == 0 {
                    elseLineEnd = i
                    break
                }
            } else if tokens[i].cont == "}" {
                nbPar++
            }
        }

        condValCons = consumeValue(tokens, start+2, elseLineEnd, -1, 0)
        if condValCons[0] == null {
            throwError(&tokens[start+2], "Expected a condition in else if statement.")
        }

        isNotChainEnd = end < len(tokens) && tokens[end].cont == "else"
        chainLength = parserCtx.scopeCtx.ifChainLength

        if isNotChainEnd {
            chainLength = 0
        }

        gen.generateElseIf(generateBahValueSymbol(condValCons[0], null), chainLength, parserCtx.scopeCtx.ifChainLabels)

        ifScope = new parserScope {
            isConditional: true
            currentFunction: parserCtx.scopeCtx.currentFunction
        }

        i= len(parserCtx._scopeCtx) - 1; for i != -1, i-- {
            if parserCtx._scopeCtx[i].scope == parserCtx.scope + 1 && parserCtx._scopeCtx[i].isConditional {
                parserCtx._scopeCtx[i].child = ifScope
                break
            }
        }

        parserCtx.startScope(ifScope)

        parseLines(tokens, elseLineEnd+1, end-1)

        parserCtx.endScope()

        gen.generateEndElse()

        if isNotChainEnd {

            parserCtx.scopeCtx.ifChainLength++
            parserCtx.scopeCtx.ifChainLabels[len(parserCtx.scopeCtx.ifChainLabels)] = len(gen.instructions) - 1
        } else {

            parserCtx.scopeCtx.ifChainLength = 0
            clear(parserCtx.scopeCtx.ifChainLabels)
        }

    } else {

        gen.generateElse(parserCtx.scopeCtx.ifChainLength, parserCtx.scopeCtx.ifChainLabels)

        elseScope = new parserScope {
            isConditional: true
            isElse: true
            currentFunction: parserCtx.scopeCtx.currentFunction
        }

        i= len(parserCtx._scopeCtx) - 1; for i != -1, i-- {
            if parserCtx._scopeCtx[i].scope == parserCtx.scope + 1 && parserCtx._scopeCtx[i].isConditional {
                parserCtx._scopeCtx[i].child = elseScope
                break
            }
        }


        parserCtx.startScope(elseScope)

        parseLines(tokens, elseLineEnd+1, end-1)

        parserCtx.endScope()

        gen.generateEndElse()

        parserCtx.scopeCtx.ifChainLength = 0
        clear(parserCtx.scopeCtx.ifChainLabels)
    }
    
}

parseFor(tokens []bahToken, start uint, end uint) {
    nbPar = 1
    i = end-2
    forLineEnd = end
    for i != -1, i-- {
        if tokens[i].cont == "{" {
            nbPar--
            if nbPar == 0 {
                forLineEnd = i
                break
            }
        } else if tokens[i].cont == "}" {
            nbPar++
        }
    }
    
    condValCons = consumeValue(tokens, start+1, forLineEnd, -1, 0)
    if condValCons[0] == null {
        throwError(&tokens[start+1], "Expected at least a condition.")
    }

    condVal = condValCons[0]
    i = condValCons[1]

    if condValCons[0].type.type != BAH_TYPE_BOOL {
        throwError(&condVal.tok, "Type error, condition of a loop should be a boolean instead of type '"+condVal.type.toStr()+"'.")
    }

    gen.generateFor()

    gen.generateForCond(generateBahValueSymbol(condVal, null))

    forLoopScope = new parserScope {
        isConditional: true
        currentFunction: parserCtx.scopeCtx.currentFunction
    }

    parserCtx.startScope(forLoopScope)

    if tokens[i].cont == "," {
        parseLine(tokens, i+1, forLineEnd)
    }

    gen.generateForIncr()


    parseLines(tokens, forLineEnd+1, end-1)

    gen.generateForEnd()

    parserCtx.endScope()


}

parseStruct(tokens []bahToken, start uint, end uint) {
    if end - start < 4 {
        throwError(&tokens[start], "Invalid structure definition.")
    }

    if tokens[start+1].type != TOKEN_TYPE_VAR {
        throwError(&tokens[start+1], "Invalid structure name.")
    }



    strctType = new bahType {
        type: BAH_TYPE_STRCT
    }
    strctType.child = new bahType {
        name: tokens[start+1].cont
    }

    if parserCtx.findType(strctType.name) != null {
        throwError(&tokens[start+1], "Cannot redefine a structure.")
    }

    i = start + 2

    if tokens[start+2].cont == "extend" {
        if tokens[start+3].type != TOKEN_TYPE_VAR {
            throwError(&tokens[start+3], "Invalid structure name.")
        }

        throwError(&tokens[start+2], "Extend not yet implemented.")
        i = start + 4
    }

    parserCtx.addType(strctType)

    if tokens[i].cont != "{" {
        throwError(&tokens[i], "Expected start of fields definition.")
    }
    i++



    currParent = strctType.child
    currOffset = 0
    for i < end-1, i++ {
        nameInd = i
        if tokens[nameInd].type != TOKEN_TYPE_VAR {
            throwError(&tokens[nameInd], "Invalid filed name.")
        }
        i++

        if tokens[i].cont == "(" { //method definition
            nbPar = 1
            j = i
            fnLineEnd = end
            for j < end, j++ {
                if tokens[j].cont == "{" {
                    fnLineEnd = j
                    break
                }
            }

            methodTypeCons = consumeType(tokens, i, fnLineEnd, true)

            if methodTypeCons[0] == null {
                throwError(&tokens[i-1], "Invalid method type definition.")
            }

            method = new bahFunction {
                name: strctType.child.name+"."+tokens[nameInd].cont
                type: methodTypeCons[0]
                declared: true
            }

            tpThisInjct = strctType.getPtr()
            tpThisInjct.next = method.type.child
            tpThisInjct.name = "this"
            method.type.child = tpThisInjct

            nbBraces = 1
            i = fnLineEnd+1
            for i < end, i++ {
                if tokens[i].cont == "{" {
                    nbBraces++
                } else if tokens[i].cont == "}" {
                    nbBraces--
                    if nbBraces == 0 {
                        i++
                        break
                    }
                }
            }

            parseFnBody(method, tokens, fnLineEnd+1, i)
            
        } else { //field definition

            if tokens[i].cont != ":" {
                throwError(&tokens[i], "Expected ':' after field name.")
            }
            i++



            fieldTypeCons = consumeType(tokens, i, end-1, false)
            if fieldTypeCons[0] == null {
                throwError(&tokens[i], "Unknown type.")
            }

            i = fieldTypeCons[1]
            fieldType = new bahType
            *fieldType = *(fieldTypeCons[0])
            fieldType.name = tokens[nameInd].cont




            alignment = 1

            if fieldType.size == 4 {
                alignment = 4
            } if fieldType.size >= 8 {
                alignment = 8
            }

            if currOffset % alignment != 0 {
                currOffset += alignment - currOffset % alignment
            }


            if tokens[i].cont == "=" {
                if i+1 > end {
                    throwError(&tokens[i], "Expected a field default value after equal.")
                }

                lineEnd = i+1
                currLine = tokens[i].line
                for lineEnd < end-1, lineEnd++ {
                    t = tokens[lineEnd]
                    if t.type == TOKEN_TYPE_STR && t.begLine == currLine && t.line != currLine {
                        currLine = t.line
                    }

                    if t.line != currLine {
                        break
                    }
                }

                // printDebugContext()
                val = consumeValue(tokens, i+1, lineEnd, -1, 0)
                if val[0] == null {
                    throwError(&tokens[i+1], "Expected a field default value after equal.")
                }

                if compatibleTypes(fieldType, val[0].type) == false {
                    throwTypeError(val[0], fieldType)
                }

                fieldType.defaultValue = val[0]

                i = val[1]

                // throwError(&tokens[i], "Default value not yet implemented")
            }



            fieldType.offset = currOffset
            currParent.next = fieldType
            strctType.size = currOffset + fieldType.size
            currOffset += fieldType.size
            currParent = currParent.next

        }
        

        if i == end-1 {
            break
        } else {
            if tokens[i].line == tokens[nameInd].line {
                throwError(&tokens[i], "Did not expect anything after field type.")
            }
            i--
        }
    }



}

parseFnBody(fn bahFunction*, tokens []bahToken, i uint, end uint) {
    hasRetType = fn.type.ret != null

    returnSize = 0
    if hasRetType {
        returnSize = fn.type.ret.size
    }

    funcScope = new parserScope {
        isConditional: false
        hasReturned: false
        needsReturn: hasRetType

        currentFunction: fn
    }

    parserCtx.addFunc(fn)

    parserCtx.startScope(funcScope)

    genArgs = []asmSymbol

    gen.stackOffset = 0
    stackOff = 16 //stack frame size

    if returnSize > 16 {
        // stackOff += 16
        gen.stackOffset = 16
    }

    arg = fn.type.child
    for arg != null, arg = arg.next {
        v = new bahVariable {
            name: arg.name
            type: arg
        }
        parserCtx.addVar(v)
        if v.type.size > 16 {
            addr = stackOff

            tmpArg = arg.next
            for tmpArg != null, tmpArg = tmpArg.next {
                if tmpArg.size > 16 {
                    addr += tmpArg.size
                }
            }

            v.sym = asmSymbolStack(0 - addr, v.type.size)
        } else {
            v.sym = gen.generateVarDecl(v.name, v.type.size, false)
        }
        genArgs[len(genArgs)] = v.sym
    }



    gen.generateFnStart(fn.name, genArgs, returnSize)


    parseLines(tokens, i, end-1)

    if parserCtx.scopeCtx.currentFunction.type.ret != null && hasScopeReturned(parserCtx.scopeCtx) == false {
        throwError(&tokens[end-1], "Function with a return type shall be returned.")
    }




    gen.generateFnEnd()


    parserCtx.endScope()

}

parseFnDecl(tokens []bahToken, start uint, end uint) {
    nbPar = 1
    i = end-2
    fnLineEnd = end
    for i != -1, i-- {
        if tokens[i].cont == "{" {
            nbPar--
            if nbPar == 0 {
                fnLineEnd = i
                break
            }
        } else if tokens[i].cont == "}" {
            nbPar++
        }
    }

    fnTypeCons = consumeType(tokens, start+1, fnLineEnd, true)

    fnType = fnTypeCons[0]

    i = fnTypeCons[1]

    if fnType == null {
        throwError(&tokens[start], "Invalid function type in function declaration.")
    }

    fn = new bahFunction {
        name: tokens[start].cont
        type: fnType
        declared: true
    }

    if tokens[start].cont == "main" && fnType.toStr() != "function([]str) int" {
        throwError(&tokens[start], "Invalid main function type, should be: function([]str) int.")
    }

    i++

    parseFnBody(fn, tokens, i, end)


}

parseConst(tokens []bahToken, start uint, end uint) {


    i=start; for i < end, i++ {
    if tokens[i].cont == "=" {
            break
        }
    }

    if i == end {
        throwError(&tokens[i], "Cannot declare a const without a value.")
    }
    if i == start {
        throwError(&tokens[i], "Expected a const name on the left of equal, got nothing.")
    }
    if i == end - 1 {
        throwError(&tokens[i], "Expected a const value on the right of equal, got nothing.")
    }

    lVal = tokens[start+1]

    if lVal.type != TOKEN_TYPE_VAR {
        throwError(&lVal, "Expected a constant's name.")
    }

    rValCons = consumeValue(tokens, i+1, end, -1, 0)

    if rValCons[0] == null {
        throwError(&tokens[i+1], "Expected a value on the right of equal.")
    }

    variable = new bahVariable {
        name: lVal.cont
        type: rValCons[0].type
        isConst: true
    }

    rVal = rValCons[0]

    if rVal.isStaticValue == false {
        if rVal.isCast == false || (rVal.isCast && rVal.left.isStaticValue == false) {
            found = false
            if rVal.isVariable {
                v = parserCtx.findVar(rVal.tok.cont)
                if v == null {
                    panic("That's a good one lol.")
                }
                if v.isConst {
                    found = true
                }
            }

            if found == false {
                throwError(&rVal.tok, "Expected constant value.")
            }
        }


        rVal = rVal.left
    }

    parserCtx.addVar(variable)

    variable.sym = generateBahValueSymbol(rValCons[0], null)

}

parseContinue(tokens []bahToken, start uint, end uint) {
    if end - start != 1 {
        throwError(&tokens[start+1], "Did not expect anything.")
    }
    gen.generateForContinue()
}

parseBreak(tokens []bahToken, start uint, end uint) {
    if end - start != 1 {
        throwError(&tokens[start+1], "Did not expect anything.")
    }
    gen.generateForBreak()
}

parseLine(tokens []bahToken, start uint, end uint) {
    //type by first token
    t = tokens[start]

    parserCtx.currentLine = t.line
    gen.generateLineLocation(t.line)

    if t.type == TOKEN_TYPE_KEYWORD {
        if t.cont[0] == '#' {
            parseHashDirective(tokens, start, end)
        } else if t.cont == "return" {
            parseReturn(tokens, start, end)
        } else if t.cont == "if" {
            parseIf(tokens, start, end)
        } else if t.cont == "else" {
            parseElse(tokens, start, end)
        } else if t.cont == "for" {
            parseFor(tokens, start, end)
        } else if t.cont == "struct" {
            parseStruct(tokens, start, end)
        } else if t.cont == "const" {
            parseConst(tokens, start, end)
        } else if t.cont == "continue" {
            parseContinue(tokens, start, end)
        } else if t.cont == "break" {
            parseBreak(tokens, start, end)
        }
    } else if t.type == TOKEN_TYPE_VAR && end - start > 4 && tokens[start+1].cont == "(" && tokens[end-1].cont == "}" {
        parseFnDecl(tokens, start, end)
    } else {
        eqlIndex = 0
        i=start; for i < end, i++ {
            if tokens[i].cont == "=" || tokens[i].cont == "+=" || tokens[i].cont == "-=" || tokens[i].cont == "/=" || tokens[i].cont == "*=" {
                eqlIndex = i
                break
            }
        }

        if i != end {
            if i == start {
                throwError(&tokens[i], "Expected a value on the left of equal, got nothing.")
            }
            if i == end - 1 {
                throwError(&tokens[i], "Expected a value on the right of equal, got nothing.")
            }

            lValCons = consumeLeftValue(tokens, start, i)
            rValCons = consumeValue(tokens, i+1, end, -1, 0)

            tmpDeclType bahType* = null

            if rValCons[0] == null {
                throwError(&tokens[i+1], "Expected a value on the right of equal.")
            }

            if lValCons[0] == null {
                throwError(&tokens[start], "Expected a symbol or an address on the left of equal.")
            }

            if lValCons[1] != i {
                typeCons = consumeType(tokens, lValCons[1], i, false)
                if typeCons[0] == null {
                    throwError(&tokens[lValCons[1]], "Expected type.")
                } else if typeCons[1] != i {
                    throwError(&tokens[typeCons[1]], "Did not expect anything after the type.")
                }

                if lValCons[2] == false {
                    throwError(&tokens[lValCons[1]], "Cannot cast the left value type outside of a declaration.")
                }

                tmpDeclType = typeCons[0]

                //type?
                // throwError(&tokens[lValCons[1]], "Didn't expect anything between left value and equal sign.")
            }

            rVal = rValCons[0]
            lVal = lValCons[0]

            if len(tokens[eqlIndex].cont) == 2 {
                if lValCons[2] {
                    throwError(&tokens[eqlIndex], "Invalid self operation on declaration.")
                }

                leftRightVal = consumeValue(tokens, start, i, -1, 0)[0]

                rVal = new bahValue {
                    isOperation: true
                    tok: tokens[eqlIndex]
                    left: leftRightVal
                    right: rVal
                    type: rVal.type
                }
            }
            
            if lValCons[2] {
                //is declaration

                if len(tokens[eqlIndex].cont) == 2 {
                    throwError(&tokens[eqlIndex], "Invalid self operation on declaration.")
                }

                lVal.variable = new bahVariable {
                    name: lValCons[0].tok.cont
                    type: rVal.type
                }


                if tmpDeclType != null {
                    lVal.variable.type = tmpDeclType
                    lVal.type = tmpDeclType
                } else {
                    lVal.type = rVal.type
                }

                parserCtx.addVar(lVal.variable)

                if parserCtx.scope == 0 {
                    if rVal == null {
                        lVal.variable.sym = gen.generateGlobalVarDecl(lVal.variable.name, lVal.variable.type.size)
                    }
                } else {
                    if lVal.isVariable == false || rVal.isTupleDeclare == false && rVal.isStructDeclare == false && rVal.isBufferDeclare == false && rVal.isArrayDeclare == false && (rVal.isFunctionCall == false || rVal.type.size <= 8) {
                        lVal.variable.sym = gen.generateVarDecl(lVal.variable.name, lVal.variable.type.size, false)
                    }
                }
            } else {
                if parserCtx.scope == 0 {
                    throwError(&lVal.tok, "Cannot redeclare a global variable.")
                }
                if compatibleTypes(lVal.type, rVal.type) == false {
                    throwTypeError(rVal, lVal.type)
                }
            }

            rValSym = asmSymbol{}

            if rVal.isStaticValue {
                rVal.type.size = lVal.type.size
            }

            if parserCtx.scope == 0 {
                syms = []asmSymbol
                generateImmediateValues(rVal, syms)
                typeSize = lVal.variable.type.size
                if lVal.variable.type.isNativePtr {
                    typeSize = 8
                }
                lVal.variable.sym = gen.generateGlobalVarDeclWithValue(lVal.variable.name, typeSize, syms)
            } else {
                //Generate var setting

                if lVal.isVariable == false && rVal.isFunctionCall == true && rVal.type.size > 16 {
                    lValSym = generateBahLeftValueSymbol(lVal)
                    tmpLvalSym = lValSym
                    if tmpLvalSym.level != 0 {
                        tmpLvalSym.level = 0
                        tmpLvalSym.size = 8
                        tmpLvalSym = gen.generateTmpSym(tmpLvalSym, tmpLvalSym.size)
                        tmpLvalSym.level = lValSym.level
                    }
                    rValSym = generateBahValueSymbol(rVal, &tmpLvalSym)
                    if isEmptySymbol(rValSym) == false {
                        gen.generateVarSet(lValSym, rValSym, false)
                    }
                } else {
                    if lValCons[2] == true && isSameType(lVal.type, rVal.type) == false {
                        rValSym = generateTypeConversion(rVal, lVal.type)
                    } else {
                        rValSym = generateBahValueSymbol(rVal, null)
                    }

                    if lVal.isArrayRecursive() {
                        rValSym = gen.generateTmpSym(rValSym, rValSym.size)
                    }

                    lValSym = generateBahLeftValueSymbol(lVal)
                    if lVal.isVariable && lVal.variable.scope == parserCtx.scope && (rVal.isTupleDeclare || rVal.isStructDeclare || rVal.isBufferDeclare || rVal.isArrayDeclare || (rVal.isFunctionCall == true && rVal.type.size > 8)) {
                        lVal.variable.sym = rValSym
                    } else {
                        gen.generateVarSet(lValSym, rValSym, lVal.type.type == BAH_TYPE_UINT)
                    }
                }

            }


        } else {

            i=start+1
            //handle rvalue lines without setting a var
            if end - start >= 2 && tokens[start].type == TOKEN_TYPE_VAR {
                for i < end, i++ {
                    if tokens[i].cont == "(" && tokens[i-1].cont != "function" || (tokens[i].type == TOKEN_TYPE_SYNTAX && tokens[i].cont != "*") {
                        val = consumeValue(tokens, start, end, -1, 0)
                        if val[0] != null {
                            generateBahValueSymbol(val[0], null)
                        }
                        break
                    }
                }
            }

            //handle var declaration with just a type
            if i == end {
                lValCons = consumeLeftValue(tokens, start, i)
                tmpDeclType bahType* = null

                if lValCons[0] == null {
                    throwError(&tokens[start], "Expected a symbol in variable declaration.")
                }

                typeCons = consumeType(tokens, lValCons[1], i, false)
                if typeCons[0] == null {
                    throwError(&tokens[lValCons[1]], "Expected type.")
                } else if typeCons[1] != i {
                    throwError(&tokens[typeCons[1]], "Did not expect anything after the type.")
                }

                tmpDeclType = typeCons[0]
                lVal = lValCons[0]
                
                if lValCons[2] == false {
                    throwError(&lVal.tok, "Cannot redeclare variable.")
                }

                lVal.variable = new bahVariable {
                    name: lValCons[0].tok.cont
                    type: tmpDeclType
                }

                parserCtx.addVar(lVal.variable)

                if parserCtx.scope == 0 {
                    lVal.variable.sym = gen.generateGlobalVarDecl(lVal.variable.name, lVal.variable.type.size)
                } else {
                    lVal.variable.sym = gen.generateVarDecl(lVal.variable.name, lVal.variable.type.size, true)
                }
            }

        }
    }

    
}

parseLines(tokens []bahToken, start uint, end uint) {
    nbEncl uint = 0
    currentLine uint = 0
    startLine uint = start
    endLine uint = end

    i=start; for i < end, i++ {
        t = tokens[i]

        if t.type == TOKEN_TYPE_STR && t.begLine == currentLine && t.line != currentLine {
            currentLine = t.line
        }

        if t.type == TOKEN_TYPE_ENCL {
            if t.cont[0] == '(' || t.cont[0] == '[' || t.cont[0] == '{' {
                nbEncl++
            } else {
                if nbEncl == 0 {
                    throwError(&t, "One too many token.")
                }
                nbEncl--
                if nbEncl == 0 && t.cont[0] == '}' {
                    endLine = i+1
                    if startLine != endLine {
                        parseLine(tokens, startLine, endLine)
                    }
                    startLine = endLine
                    if endLine < end {
                        currentLine = tokens[endLine].line
                    }
                }
                continue
            }
        }

        if t.line != currentLine || t.cont == ";" {
            if nbEncl == 0 {
                endLine = i
                if startLine != endLine {
                    parseLine(tokens, startLine, endLine)
                }
                startLine = endLine
                if t.cont == ";" {
                    startLine++
                }
            }
            currentLine = t.line
        }

    }

    if startLine != i {
        endLine = i
        parseLine(tokens, startLine, endLine)
    }
}