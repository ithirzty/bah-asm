#import "./lexer.bah"
#import "./gen_asm_linux_64.bah"

gen asmContext
initFnGen asmContext
globalFuncsGen asmContext
compileWaitChannel channel*

isObjectFile = false
isImportFile = false
isSilent = false
compilerPath = ""

const BAH_DIR = "/opt/bah-asm/"
BAH_VERSION = "v0.15 (build 33)"


const BAH_TYPE_BOOL         = 0
const BAH_TYPE_INT          = 1
const BAH_TYPE_UINT         = 2
const BAH_TYPE_FLOAT        = 3
const BAH_TYPE_STR          = 4
const BAH_TYPE_STRCT        = 5
const BAH_TYPE_ARRAY        = 6
const BAH_TYPE_MAP          = 7
const BAH_TYPE_CHAN         = 8
const BAH_TYPE_FUNC         = 9
const BAH_TYPE_PTR          = 10
const BAH_TYPE_CUSTOM_TYPE  = 11
const BAH_TYPE_BUFFER       = 12
const BAH_TYPE_TUPLE        = 13

const ARR_TYPE_SIZE        = 40
const ARR_LENGTH_OFFSET    = 8
const ARR_REALENGTH_OFFSET = 16
const ARR_ELEMSIZE_OFFSET  = 24
const ARR_PARENT_OFFSET  = 32

const REFLECT_TYPE_SIZE = 72

struct bahFileLoc {
    file: str
    line: uint
    from: uint
    to:   uint
}

const BAH_TYPE_FLAG_PURE = 1
const BAH_TYPE_FLAG_EXIT = 2
const BAH_TYPE_FLAG_REALLOC = 4

struct bahType {
    name:   str
    size:   uint
    offset: uint

    child: bahType*
    next:  bahType*
    ret:   bahType*
    defaultValue: ptr
    flags: uint = 0

    type:   byte
    isPtr: bool
    isNativePtr: bool

    isFlagSet(flag uint) bool {
        return this.flags & flag != 0
    }

    toggleFlag(flag uint) {
        this.flags = this.flags ^ flag
    }

    toStr() str {
        if this.isPtr {
            return this.child.toStr()+"*"
        }
        if this.type == BAH_TYPE_CUSTOM_TYPE {
            return this.child.name
        }
        if this.type == BAH_TYPE_BOOL {
            return "bool"
        } else if this.type == BAH_TYPE_INT {
            if this.size == 8 {
                return "int"
            }
            return "int" + uintToStr(this.size * 8)
        } else if this.type == BAH_TYPE_UINT {
            if this.size == 1 {
                return "byte"
            } else if this.size == 8 {
                return "uint"
            }
            return "uint" + uintToStr(this.size * 8)
        } else if this.type == BAH_TYPE_FLOAT {
            if this.size == 8 {
                return "float"
            }
            return "float" + uintToStr(this.size * 8)
        } else if this.type == BAH_TYPE_STR {
            return "str"
        } else if this.type == BAH_TYPE_STRCT {
            return this.child.name
        } else if this.type == BAH_TYPE_ARRAY {
            return "[]" + this.child.toStr()
        } else if this.type == BAH_TYPE_MAP {
            return "map:" + this.child.toStr()
        } else if this.type == BAH_TYPE_CHAN {
            return "chan:" + this.child.toStr()
        } else if this.type == BAH_TYPE_PTR {
            return "ptr"
        } else if this.type == BAH_TYPE_BUFFER {
            return "buffer:"+uintToStr(this.size)
        } else if this.type == BAH_TYPE_FUNC {
            s = "function("
            elem = this.child
            for elem != null, elem = elem.next {
                s += elem.toStr()
                if elem.next != null {
                    s += ", "
                }
            }
            s += ")"
            if this.ret != null {
                s += " "+this.ret.toStr()
            }
            return s
        } else if this.type == BAH_TYPE_TUPLE {
            s = "["
            elem = this.child
            for elem != null, elem = elem.next {
                if elem != this.child {
                    s += ","
                }
                s += elem.toStr()
            }
            s += "]"
            return s
        }

        return this.name
    }

    getPtr() bahType* {
        r = new bahType {
            isPtr: true
            isNativePtr: true
            size: 8
            child: this
        }

        return r
    }

}

struct bahVariable {
    name: str
    type: bahType*

    scope: uint

    sym: asmSymbol
    isConst: bool
}

struct bahFunction {
    name: str
    type: bahType*

    asmInstructions: rope*
    pureCalls: []bahFunction*
    endInstructions: []asmInstruction
    call: ptr

    declared: bool
}

const BAH_VALUE_OP          = 1
// const BAH_VALUE_STATIC      = 2
const BAH_VALUE_FUNC_SYM    = 3
const BAH_VALUE_FUNC_CALL   = 4
const BAH_VALUE_VAR         = 5
const BAH_VALUE_ARGS        = 6
// const BAH_VALUE_SELF_OP     = 7
const BAH_VALUE_UNARY       = 8
const BAH_VALUE_CAST        = 9
const BAH_VALUE_INDEXED     = 10
const BAH_VALUE_SPLIT       = 11
const BAH_VALUE_REG         = 12
const BAH_VALUE_STRUCT      = 13
const BAH_VALUE_DECLARATION = 14
const BAH_VALUE_REFLECT     = 15
// const BAH_VALUE_ASYNC       = 16
const BAH_VALUE_SYM         = 17
const BAH_VALUE_NOT         = 18

struct bahValue {
    pemdas: uint

    tok: bahToken
    type: bahType*

    left: bahValue*
    right: bahValue*

    sym: asmSymbol

    isPointer: bool
    isStaticValue: bool
    isSelfOp: bool
    isAsync: bool
    value: byte
}

struct bahLeftValue {
    type: bahType*

    tok: bahToken

    index: bahValue*
    variable: bahVariable*
    left: bahLeftValue*
    right: bahLeftValue*

    isConst: bool

    isVariable:  bool //final symbol in the left-val tree
    isArray:     bool //is only the array in which is the left-val
    isStruct:    bool //same for struct
    isBuffer:    bool
    isMap:       bool
    isUnary:     bool
    isTuple:     bool
    isByAddress: bool //is a right value who's returning an address, right value is stored in index


    isArrayRecursive() bool {
        if this.isArray {
            return true
        }

        if this.left != null && this.left.isArrayRecursive() {
            return true
        }

        if this.right != null && this.right.isArrayRecursive() {
            return true
        }

        return false
    }

}


const BAH_SCOPE_RETURNED = 1
const BAH_SCOPE_EXITTED  = 2
const BAH_SCOPE_REALLOC  = 4

struct parserScope {
    isConditional: bool
    
    state: uint

    needsReturn:   bool
    isIf: bool
    isElse: bool
    ifChainLength: uint
    ifChainLabels: []uint
    scope: uint

    isSingleVarSet: bool
    moreThanSingleSet: bool
    lVal: bahLeftValue*
    rVal: bahValue*

    parent: parserScope*
    prev: parserScope*
    closes: parserScope*
    last: parserScope*

    currentFunction: bahFunction*

    isState(state uint) bool {
        return this.state & state != 0
    }

    setState(state uint) {
        this.state = this.state | state
    }
}

struct parserContext {
    variables: []bahVariable*
    functions: []bahFunction*
    types:     []bahType*

    scope: uint

    parsedFiles: []str
    compiledFiles: []str
    libraries: []str

    parseOnly: bool = false

    currentFile: str
    currentFilePath: str
    currentLine: uint
    currentCompileNb: uint
    declareMode: bool
    importDeps: []str
    noImports: bool
    debugEnabled: bool
    
    scopeCtx: parserScope*

    addVar(v bahVariable*) {
        v.scope = this.scope
        this.variables[len(this.variables)] = v
    }

    addFunc(fn bahFunction*) {
        this.functions[len(this.functions)] = fn
    }

    addType(tp bahType*) {
        this.types[len(this.types)] = tp
    }

    startScope(scope parserScope*) {
        this.scope++
        scope.parent = this.scopeCtx
        scope.prev = this.scopeCtx.last
        this.scopeCtx.last = scope
        scope.scope = this.scope
        this.scopeCtx = scope
    }

    endScope() {
        this.scope--
                
        this.scopeCtx = this.scopeCtx.parent

        i=len(this.variables) - 1; for i != -1, i-- {
            if this.variables[i].scope > this.scope {
                delete(this.variables, i)
            }
        }
    }

    findVar(s str) bahVariable* {
        i=len(this.variables) - 1; for i != -1, i-- {
            v = this.variables[i]
            if v.name == s {
                return v
            }
        }
        return null
    }

    findFunc(s str) bahFunction* {
        i=len(this.functions) - 1; for i != -1, i-- {
            fn = this.functions[i]
            if fn.name == s {
                return fn
            }
        }
        return null
    }

    findMethod(strct bahType*, name str) bahFunction* {
        for strct != null, strct = strct.ret {
            fn = this.findFunc(strct.child.name+"."+name)
            if fn != null {
                return fn
            }
        }
        return null
    }

    findType(s str) bahType* {
        i=len(this.types) - 1; for i != -1, i-- {
            tp = this.types[i]
            if tp.type == BAH_TYPE_STRCT && tp.child != null && tp.child.name == s {
                return tp
            }

            if tp.type == BAH_TYPE_CUSTOM_TYPE && tp.child.name == s {
                return tp
            }
        }
        return null
    }

    _init() {
        this.scopeCtx = new parserScope
    }
}

parserCtx parserContext

//Returns true if a scope cannot do anything other than returning.
hasScopeReturned(scope parserScope*) bool {
    if scope.isState(BAH_SCOPE_RETURNED) {
        return true
    }
    
    child = scope.last
    for child != null, child = child.prev {
        if child.isElse == false || hasScopeReturned(child) == false {
            continue
        }
        
        for child != null, child = child.prev {
            if hasScopeReturned(child) == false {
                break
            }
            
            if child.isIf {
                if hasScopeReturned(child) {
                    return true
                }
                break
            }
        }
    }

    return false
}

//Returns true if a scope has a return statement at some point.
hasScopeAreturn(scope parserScope*) bool {
    if scope.isState(BAH_SCOPE_RETURNED) {
        return true
    }

    child = scope.last
    for child != null, child = child.prev {
        if hasScopeAreturn(child) {
            return true
        }
    }

    return false
}

//hasScopeReturned() will only return true if the scope is obligated to return
//but it will not return true if a scope is supposed to return in the context of the program.
//Thus, we cannot trust it to return false in hasScopeExitted() previous scope exitted (example with generateBahValue()).
//If the function takes any chance to return before the exit call, then it is not obligated to exit even if it may in the program's context.
hasScopeState(scope parserScope*, state uint) bool {
    child = scope.last
    for child != null, child = child.prev {
        if child.isElse == false || hasScopeState(child, state) == false {
            continue
        }
        
        for child != null, child = child.prev {
            if hasScopeState(child, state) == false {
                break
            }

            if child.isIf {
                if hasScopeState(child, state) {
                    returningChild = child
                    for returningChild != null, returningChild = returningChild.prev {
                        if hasScopeAreturn(returningChild) {
                            return false
                        }
                    }
                    if returningChild == null {
                        return true
                    }
                }
                break
            }
        }
    }

    return scope.isState(state)
}