#import "./lexer.bah"
#import "./gen_asm_linux_64.bah"


const BAH_TYPE_BOOL         = 0
const BAH_TYPE_INT          = 1
const BAH_TYPE_UINT         = 2
const BAH_TYPE_FLOAT        = 3
const BAH_TYPE_STR          = 4
const BAH_TYPE_STRCT        = 5
const BAH_TYPE_ARRAY        = 6
const BAH_TYPE_MAP          = 7
const BAH_TYPE_CHAN         = 8
const BAH_TYPE_FUNC         = 9
const BAH_TYPE_PTR          = 10
const BAH_TYPE_CUSTOM_TYPE  = 11
const BAH_TYPE_BUFFER       = 12
const BAH_TYPE_TUPLE        = 13

const ARR_TYPE_SIZE        = 40
const ARR_LENGTH_OFFSET    = 8
const ARR_REALENGTH_OFFSET = 16
const ARR_ELEMSIZE_OFFSET  = 24
const ARR_PARENT_OFFSET  = 32

const REFLECT_TYPE_SIZE = 72

struct bahFileLoc {
    file: str
    line: uint
    from: uint
    to:   uint
}

const BAH_TYPE_FLAG_PURE = 1

struct bahType {
    name:   str
    size:   uint
    offset: uint

    child: bahType*
    next:  bahType*
    ret:   bahType*
    defaultValue: ptr
    flags: uint = 0

    type:   byte
    isPtr: bool
    isNativePtr: bool

    isFlagSet(flag uint) bool {
        return this.flags & flag != 0
    }

    toggleFlag(flag uint) {
        this.flags = this.flags ^ flag
    }

    toStr() str {
        if this.isPtr {
            return this.child.toStr()+"*"
        }
        if this.type == BAH_TYPE_CUSTOM_TYPE {
            return this.name
        }
        if this.type == BAH_TYPE_BOOL {
            return "bool"
        } else if this.type == BAH_TYPE_INT {
            if this.size == 8 {
                return "int"
            }
            return "int" + uintToStr(this.size * 8)
        } else if this.type == BAH_TYPE_UINT {
            if this.size == 1 {
                return "byte"
            } else if this.size == 8 {
                return "uint"
            }
            return "uint" + uintToStr(this.size * 8)
        } else if this.type == BAH_TYPE_FLOAT {
            if this.size == 8 {
                return "float"
            }
            return "float" + uintToStr(this.size * 8)
        } else if this.type == BAH_TYPE_STR {
            return "str"
        } else if this.type == BAH_TYPE_STRCT {
            return this.child.name
        } else if this.type == BAH_TYPE_ARRAY {
            return "[]" + this.child.toStr()
        } else if this.type == BAH_TYPE_MAP {
            return "map:" + this.child.toStr()
        } else if this.type == BAH_TYPE_CHAN {
            return "chan:" + this.child.toStr()
        } else if this.type == BAH_TYPE_PTR {
            return "ptr"
        } else if this.type == BAH_TYPE_BUFFER {
            return "buffer:"+uintToStr(this.size)
        } else if this.type == BAH_TYPE_FUNC {
            s = "function("
            elem = this.child
            for elem != null, elem = elem.next {
                s += elem.toStr()
                if elem.next != null {
                    s += ", "
                }
            }
            s += ")"
            if this.ret != null {
                s += " "+this.ret.toStr()
            }
            return s
        } else if this.type == BAH_TYPE_TUPLE {
            s = "["
            elem = this.child
            for elem != null, elem = elem.next {
                if elem != this.child {
                    s += ","
                }
                s += elem.toStr()
            }
            s += "]"
            return s
        }

        return this.name
    }

    getPtr() bahType* {
        r = new bahType {
            isPtr: true
            isNativePtr: true
            size: 8
            child: this
        }

        return r
    }

}

struct bahVariable {
    name: str
    type: bahType*

    scope: uint

    sym: asmSymbol
    isConst: bool
}

struct bahFunction {
    name: str
    type: bahType*
    declared: bool

    asmInstructions: rope*
    pureCalls: []bahFunction*
    call: ptr
}

const BAH_VALUE_OP          = 1
// const BAH_VALUE_STATIC      = 2
const BAH_VALUE_FUNC_SYM    = 3
const BAH_VALUE_FUNC_CALL   = 4
const BAH_VALUE_VAR         = 5
const BAH_VALUE_ARGS        = 6
// const BAH_VALUE_SELF_OP     = 7
const BAH_VALUE_UNARY       = 8
const BAH_VALUE_CAST        = 9
const BAH_VALUE_INDEXED     = 10
const BAH_VALUE_SPLIT       = 11
const BAH_VALUE_REG         = 12
const BAH_VALUE_STRUCT      = 13
const BAH_VALUE_DECLARATION = 14
const BAH_VALUE_REFLECT     = 15
// const BAH_VALUE_ASYNC       = 16
const BAH_VALUE_SYM         = 17

struct bahValue {
    pemdas: uint

    tok: bahToken
    type: bahType*

    left: bahValue*
    right: bahValue*

    sym: asmSymbol

    isPointer: bool
    isStaticValue: bool
    isSelfOp: bool
    isAsync: bool
    value: byte
}

struct bahLeftValue {
    type: bahType*

    tok: bahToken

    index: bahValue*
    variable: bahVariable*
    left: bahLeftValue*
    right: bahLeftValue*

    isVariable:  bool //final symbol in the left-val tree
    isArray:     bool //is only the array in which is the left-val
    isStruct:    bool //same for struct
    isBuffer:    bool
    isMap:       bool
    isUnary:     bool
    isTuple:     bool
    isByAddress: bool //is a right value who's returning an address, right value is stored in index


    isArrayRecursive() bool {
        if this.isArray {
            return true
        }

        if this.left != null && this.left.isArrayRecursive() {
            return true
        }

        if this.right != null && this.right.isArrayRecursive() {
            return true
        }

        return false
    }

}

struct parserScope {
    isConditional: bool
    hasReturned:   bool
    needsReturn:   bool
    isElse: bool
    ifChainLength: uint
    ifChainLabels: []uint
    scope: uint

    
    parent: parserScope*
    child: parserScope*
    next: parserScope*

    currentFunction: bahFunction*
}

struct parserContext {
    variables: []bahVariable*
    functions: []bahFunction*
    types:     []bahType*

    scope: uint

    parsedFiles: []str
    compiledFiles: []str
    libraries: []str

    parseOnly: bool = false

    currentFile: str
    currentFilePath: str
    currentLine: uint
    currentCompileNb: uint
    declareMode: bool
    importDeps: []str
    noImports: bool
    debugEnabled: bool
    
    scopeCtx: parserScope*

    addVar(v bahVariable*) {
        v.scope = this.scope
        this.variables[len(this.variables)] = v
    }

    addFunc(fn bahFunction*) {
        this.functions[len(this.functions)] = fn
    }

    addType(tp bahType*) {
        this.types[len(this.types)] = tp
    }

    startScope(scope parserScope*) {
        this.scope++
        if this.scopeCtx != null {
            scope.parent = this.scopeCtx
            scope.next = this.scopeCtx.child
            this.scopeCtx.child = scope
        }
        scope.scope = this.scope
        this.scopeCtx = scope
    }

    endScope() {
        this.scope--
        
        if this.scope == 0 {
            this.scopeCtx = null
        } else {
            this.scopeCtx = this.scopeCtx.parent
        }

        i=0; for i < len(this.variables), i++ {
            if this.variables[i].scope > this.scope {
                delete(this.variables, i)
                i--
            }
        }
    }

    findVar(s str) bahVariable* {
        i=len(this.variables) - 1; for i != -1, i-- {
            v = this.variables[i]
            if v.name == s {
                return v
            }
        }
        return null
    }

    findFunc(s str) bahFunction* {
        i=len(this.functions) - 1; for i != -1, i-- {
            fn = this.functions[i]
            if fn.name == s {
                return fn
            }
        }
        return null
    }

    findMethod(strct bahType*, name str) bahFunction* {
        for strct != null, strct = strct.ret {
            fn = this.findFunc(strct.child.name+"."+name)
            if fn != null {
                return fn
            }
        }
        return null
    }

    findType(s str) bahType* {
        i=len(this.types) - 1; for i != -1, i-- {
            tp = this.types[i]
            if tp.type == BAH_TYPE_STRCT && tp.child != null && tp.child.name == s {
                return tp
            }

            if tp.type == BAH_TYPE_CUSTOM_TYPE && tp.name == s {
                return tp
            }
        }
        return null
    }
}

parserCtx parserContext

hasScopeReturned(scope parserScope*) bool {
    if scope.isConditional == false {
        if scope.hasReturned {
            return true
        }

        child = scope.child
        for child != null, child = child.next {
            if hasScopeReturned(child) {
                return true
            }
        }
        return false
    }
    
    currScope = scope.child
    for currScope != null, currScope = currScope.child {
        if hasScopeReturned(currScope) == false {
            return false
        }

        if currScope.child == null && currScope.isElse == false {
            return false
        }
    }

    return scope.hasReturned
}

gen asmContext
initFnGen asmContext
globalFuncsGen asmContext
initFnName = ".__Bah_init"
compileWaitChannel channel*

isObjectFile = false
isImportFile = false
isSilent = false
compilerPath = ""

const BAH_DIR = "/opt/bah-asm/"
BAH_VERSION = "v0.135 (build 17)"
