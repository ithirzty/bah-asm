#import "iostream.bah"
#import "string.bah"
#import "time.bah"
#import "json.bah"
#import "object.bah"
#import "queue.bah"
#import "path.bah"
#import "exec.bah"
#import "flags.bah"
#import "dl.bah"

#define printDebugContext()

#linux {
    BAH_OS = "linux"
}

#darwin {
    BAH_OS = "darwin"
}

#windows {
    BAH_OS = "windows"
}

#import "./lexer.bah"
#import "./gen_asm_linux_64.bah"

//utils
#import "./cache.bah"
#import "./state.bah"
#import "./types.bah"
#import "./error.bah"

#import "./optimizer.bah"
#import "./gen.bah"
#import "./parser.bah"

printDebugContext() {
    println("Code position: "+parserCtx.currentFilePath+":"+uintToStr(parserCtx.currentLine))
}

const persistentmcpySourceAVX = ".global persistentmcpy
persistentmcpy:
pushq %rbp
movq %rsp, %rbp
cmpq $0, %rdx
je .persistentmcpy_648
addq %rdi, %rdx
subq $31, %rdx
cmpq %rdx, %rdi
jnb .persistentmcpy_not_649
.persistentmcpy_649:
vmovdqu (%rsi), %ymm1
vmovdqu %ymm1, (%rdi)
addq $32, %rsi
addq $32, %rdi
cmpq %rdx, %rdi
jb .persistentmcpy_649
.persistentmcpy_not_649:
addq $31, %rdx
cmpq %rdx, %rdi
jnb .persistentmcpy_not_650
.persistentmcpy_650:
movb (%rsi), %al
movb %al, (%rdi)
addq $1, %rsi
addq $1, %rdi
cmpq %rdx, %rdi
jb .persistentmcpy_650
.persistentmcpy_not_650:
popq %rbp
ret
.persistentmcpy_648:
leave
ret\n"

const persistentmcpySourceNoAVX = ".global persistentmcpy
persistentmcpy:
pushq %rbp
movq %rsp, %rbp
cmpq $0, %rdx
je .persistentmcpy_648
addq %rdi, %rdx
subq $15, %rdx
cmpq %rdx, %rdi
jnb .persistentmcpy_not_649
.persistentmcpy_649:
movdqu (%rsi), %xmm0
movdqu %xmm0, (%rdi)
addq $16, %rsi
addq $16, %rdi
cmpq %rdx, %rdi
jb .persistentmcpy_649
.persistentmcpy_not_649:
addq $15, %rdx
cmpq %rdx, %rdi
jnb .persistentmcpy_not_650
.persistentmcpy_650:
movb (%rsi), %al
movb %al, (%rdi)
addq $1, %rsi
addq $1, %rdi
cmpq %rdx, %rdi
jb .persistentmcpy_650
.persistentmcpy_not_650:
popq %rbp
ret
.persistentmcpy_648:
leave
ret\n"

main(args []str) int {
    if len(args) == 1 {
        return 0
    }

    startTime = getTimeUnix() //for timming compilation time
    compilerPath = args[0]
    compileWaitChannel = channel()

    gen = asmContext{}
    parserCtx = parserContext{}


    initFnGen = asmContext{
        code: rope("")
        staticData: rope("")
        data: rope("")
        bss: rope("")
        debugEnabled: false
    }

    globalFuncsGen = asmContext{
        code: rope("")
        staticData: rope("")
        data: rope("")
        bss: rope("")
        debugEnabled: false
    }


    flags = flags{}
    flags.addString("o", "Name of the output file.")
    flags.addBool("v", "Get compiler version.")
    flags.addBool("object", "Compile to object file.")
    flags.addBool("silent", "Should not output anything.")
    flags.addBool("trim", "Removes all debug data.")
    flags.addBool("asm", "Compile to assembly file.")
    flags.addBool("disableOptimizations", "Disables generation optimizations.")
    flags.addBool("noImports", "Redirects #import directive to #include.")
    flags.addBool("debug", "Includes in depth debug informations, useful for debugging. This also redirects imports to includes.")
    flags.addBool("noBuiltin", "Do not import Bah's runtime.")
    flags.addBool("noAVX", "Do not use AVX instructions.")

    flags.parse(args)

    if flags.isSet("v") {
        println("Bah compiler (asm branch) version: "+BAH_VERSION+".")
        println("Author: Alois Laurent Boe.")
        return 0
    }

    parserCtx.noImports = flags.isSet("noImports") || flags.isSet("debug") || flags.isSet("noAVX")
    parserCtx.debugEnabled = flags.isSet("debug")
    gen.debugEnabled = flags.isSet("trim") == false || flags.isSet("debug")
    GEN_AVXenabled = flags.isSet("noAVX") == false
    
    #avx! {
        GEN_AVXenabled = false
    }

    isObjectFile = flags.isSet("object")
    isSilent = flags.isSet("silent")

    if flags.isSet("disableOptimizations") {
        gen.enableOptimizations = false
        initFnGen.enableOptimizations = false
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#linux", BAH_OS == "linux"
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#darwin", BAH_OS == "darwin"
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#windows", BAH_OS == "windows"
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#avx", GEN_AVXenabled
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#debug", flags.isSet("debug")
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#static", false
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#dynamic", true
    }

    initFnCallRope = rope("")
    programEntry = rope("")

    persistentmcpySource = persistentmcpySourceAVX
    if GEN_AVXenabled == false {
        GEN_disableAVX()
        persistentmcpySource = persistentmcpySourceNoAVX
    }

    if isObjectFile == false {
        gen.debugInfo = rope(".global .bah_debug_info_lines\n.bah_debug_info_lines:\n")
        if flags.isSet("noBuiltin") {
            programEntry = rope(".global _start
.text
_start:
movq %rsp, %rbp
call "+initFnName+"
movl (%rsp), %edi
leaq 8(%rsp), %rsi
leaq 16(%rsp,%rdi,8), %rdx
call main
movl %eax, %edi
call _exit\n"+persistentmcpySource)
            gen.staticData = rope(".data\n")
            
        } else {
            programEntry = rope(".global _start
.text
_start:
movq %rsp, %rbp
call "+initFnName+"
movl (%rsp), %edi
leaq 8(%rsp), %rsi
leaq 16(%rsp,%rdi,8), %rdx
call "+argumentsToArrFunction+"
movq %rax, %rdi
call main
movl %eax, %edi
call _exit\n"+persistentmcpySource)
            gen.staticData = rope(".data\n")
        }
        gen.data = rope("")
        gen.bss = rope(".bss
.global __bss_start
__bss_start:\n")
        gen.code = rope(".text\n")
        initFnGen.generateFnStart(initFnName, null, 0)
    } else {
        gen.debugEnabled = false
        gen.debugInfo = rope("")
        gen.staticData = rope(".data\n")
        gen.data = rope("")
        gen.bss = rope(".bss\n")
        gen.code = rope(".text\n")
    }

    file = args[1]
    fs = fileStream{}
    fs.open(file, "r")

    if fs.isValid() == false {
        println("Could not open '"+file+"'.")
        return 1
    }

    content = fs.readContent()
    fs.close()

    readCache()

    parserCtx.currentFilePath = absPath(file)
    parserCtx.currentFile = content

    tokens = lexer(content, true)

    gen.generateFileLocation(parserCtx.currentFilePath)

    if absPath(BAH_DIR + "builtin.bah") != absPath(file) && flags.isSet("noBuiltin") == false {
        importFile(BAH_DIR + "builtin.bah")
    }


    parseLines(tokens, 0, len(tokens))

    fileName = ""
    fileNameNoExt = ""

    if flags.isSet("o") {
        fileName = flags.get("o")
        
        if fileName[0] != '.' && fileName[0] != '/' {
            currDirectory = file
            i=len(currDirectory)-1; for i != -1, i-- {
                if currDirectory[i] == '/' {
                    currDirectory = currDirectory[:i+1]
                    break
                }
            }
            fileName = currDirectory + fileName
        }

        fileNameNoExt = fileName
        i=len(fileNameNoExt)-1; for i != -1, i-- {
            if fileNameNoExt[i] == '/' {
                break
            }
            if fileNameNoExt[i] == '.' {
                fileNameNoExt = fileNameNoExt[:i]
                break
            }
        }

    } else {
        fileName = file[:len(file)-4]
        fileNameNoExt = file[:len(file)-4]
    }

    gen.debugInfo += rope(".byte 0\n")
    generateRuntimeDebugInfo()

    if isObjectFile == false {
        initFnGen.generateFnEnd(null)
        gen.bss += rope(".global __bss_end\n__bss_end:\n")
        gen.data = programEntry + gen.staticData + gen.debugInfo + rope(".global __data_start\n__data_start:\n") + gen.data
        gen.code += initFnGen.code + globalFuncsGen.code
    } else {
        gen.data = gen.staticData + gen.data
        gen.code += globalFuncsGen.code
    }

    if isSilent == false {
        println("Parsed "+intToStr(totalLines)+" lines in "+intToStr((getTimeUnix() - startTime) / 1000000)+"ms.\033[0m")
    }

    i=0; for i < len(evalTmpOFiles), i++ {
        removeFile(evalTmpOFiles[i])
    }


    if flags.isSet("asm") {
        i=len(fileName)-1; for i != -1, i-- {
            if fileName[i] == '/' {
                break
            }
            if fileName[i] == '.' {
                break
            }
        }
        if i == -1 || fileName[i] != '.' {
            fileName += ".S"
        }
        

        fs.open(fileName, "w")
        fs.writeFile((gen.data + gen.bss + gen.code).toStr())
        fs.close()
        return 0
    }

    if isObjectFile {
        i=len(fileName)-1; for i != -1, i-- {
            if fileName[i] == '/' {
                break
            }
            if fileName[i] == '.' {
                break
            }
        }
        
        if i == -1 || fileName[i] != '.' {
            fileName += ".o"
        }

        cmd = command("as -f -o "+fileName)
        cmd.input = (gen.data + gen.bss + gen.code).toStr()
        cmd.run()
        return 0
    }

    cmd = command("as -f -o "+fileNameNoExt+".o")
    cmd.input = (gen.data + gen.bss + gen.code).toStr()
    err = cmd.run()

    if cmd.status != 0 {
        println("Error assembling program")
        println(err)
        return 1
    }

    libraries = ""
    i=0; for i < len(parserCtx.libraries), i++ {
        if parserCtx.libraries[i][0] == '/' {
            libraries += " "+parserCtx.libraries[i]
            continue
        }
        libraries += " -"+parserCtx.libraries[i]
    }

    for parserCtx.currentCompileNb != 0 {
        compileWaitChannel.receive()
        parserCtx.currentCompileNb--
    }

    writeCache()

    cmd = command("ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o "+fileName+" "+libraries+" "+fileNameNoExt+".o -lc")
    err = cmd.run()

    removeFile(fileNameNoExt+".o")
    if cmd.status != 0 {
        println("Error linking program")
        println(err)
        return 1
    }

    if isSilent == false {
        println("\033[1;32mDone. (compiled in "+intToStr((getTimeUnix() - startTime) / 1000000)+"ms)\033[0m")
    }

    // cmd = command("ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o "+fileName+" /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtbeginS.o  "+fileName+".o -lc /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crtn.o")
    // err = cmd.runBytes()

    // removeFile(fileName+".o")
    return 0
}