#import "iostream.bah"
#import "string.bah"
#import "time.bah"
#import "json.bah"
#import "object.bah"
#import "queue.bah"
#import "path.bah"
#import "exec.bah"
#import "flags.bah"
#import "dl.bah"

#define printDebugContext()

#linux {
    BAH_OS = "linux"
}

#darwin {
    BAH_OS = "darwin"
}

#windows {
    BAH_OS = "windows"
}

#import "./lexer.bah"
#import "./gen_asm_linux_64.bah"

//utils
#import "./cache.bah"
#import "./state.bah"
#import "./types.bah"
#import "./error.bah"

#import "./optimizer.bah"
#import "./gen.bah"
#import "./parser.bah"

printDebugContext() {
    println("Code position: "+parserCtx.currentFilePath+":"+uintToStr(parserCtx.currentLine))
}

main(args []str) int {
    if len(args) == 1 {
        return 0
    }

    startTime = getTimeUnix() //for timming compilation time
    compilerPath = args[0]
    compileWaitChannel = channel()

    gen = asmContext{}
    parserCtx = parserContext{}


    initFnGen = asmContext{
        code: rope("")
        staticData: rope("")
        data: rope("")
        bss: rope("")
        debugEnabled: false
    }

    globalFuncsGen = asmContext{
        code: rope("")
        staticData: rope("")
        data: rope("")
        bss: rope("")
        debugEnabled: false
    }


    flags = flags{}
    flags.addString("o", "Name of the output file.")
    flags.addBool("v", "Get compiler version.")
    flags.addBool("object", "Compile to object file.")
    flags.addBool("silent", "Should not output anything.")
    flags.addBool("trim", "Removes all debug data.")
    flags.addBool("asm", "Compile to assembly file.")
    flags.addBool("disableOptimizations", "Disables generation optimizations.")
    flags.addBool("noImports", "Redirects #import directive to #include.")
    flags.addBool("debug", "Includes in depth debug informations, useful for debugging. This also redirects imports to includes.")
    flags.addBool("noBuiltin", "Do not import Bah's runtime.")
    flags.addBool("noAVX", "Do not use AVX instructions.")
    flags.addBool("run", "Run the program instead of outputting an executable. Useful in shebangs.")
    flags.addBool("linkAndRun", "Use ld linker and run the program instead of outputting an executable. Use this instead of -run if you use #cLib to import external libraries.")

    flags.parse(args)

    if flags.isSet("v") {
        println("Bah compiler (asm branch) version: "+BAH_VERSION+".")
        println("Author: Alois Laurent Boe.")
        return 0
    }

    isFullLink = flags.isSet("linkAndRun")
    isRun = flags.isSet("run") || isFullLink
    parserCtx.noImports = flags.isSet("noImports") || flags.isSet("debug") || flags.isSet("noAVX") || isRun
    parserCtx.debugEnabled = flags.isSet("debug")
    gen.debugEnabled = flags.isSet("trim") == false || flags.isSet("debug")
    GEN_AVXenabled = flags.isSet("noAVX") == false
    
    #avx! {
        GEN_AVXenabled = false
    }

    isObjectFile = flags.isSet("object")
    isSilent = flags.isSet("silent") || isRun

    if flags.isSet("disableOptimizations") {
        gen.enableOptimizations = false
        initFnGen.enableOptimizations = false
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#linux", BAH_OS == "linux"
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#darwin", BAH_OS == "darwin"
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#windows", BAH_OS == "windows"
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#avx", GEN_AVXenabled
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#debug", flags.isSet("debug")
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#static", false
    }

    BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
        "#dynamic", true
    }

    #x86 {
        BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
            "#x86", true
        }
        BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
            "#arm", false
        }
    }

    #arm {
        BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
            "#arm", true
        }
        BAH_boolean_hashes[len(BAH_boolean_hashes)] = booleanHash {
            "#x86", false
        }
    }

    initFnCallRope = rope("")
    programEntry = rope("")

    programEntry = gen.generateDefaults(flags.isSet("noBuiltin") == false, isObjectFile == false)

    if isObjectFile == false {
        initFnGen.generateFnStart(initFnName, null, 0)
    }

    file = args[flags.unused()]
    fs = fileStream{}
    fs.open(file, "r")

    if fs.isValid() == false {
        println("Could not open '"+file+"'.")
        return 1
    }

    content = fs.readContent()
    fs.close()

    if parserCtx.noImports == false {
        readCache()
    }

    parserCtx.currentFilePath = absPath(file)
    parserCtx.currentFile = content

    tokens = lexer(content, true)

    gen.generateFileLocation(parserCtx.currentFilePath)

    if absPath(BAH_DIR + "builtin.bah") != absPath(file) && flags.isSet("noBuiltin") == false {
        if isRun && isFullLink == false {
            parserCtx.declareMode = true            
        }
        importFile(BAH_DIR + "builtin.bah")
        if isRun && isFullLink == false {
            parserCtx.declareMode = false
        }
    }


    parseLines(tokens, 0, len(tokens))

    fileName = ""
    fileNameNoExt = ""

    if flags.isSet("o") {
        fileName = flags.get("o")
        
        if fileName[0] != '.' && fileName[0] != '/' {
            currDirectory = file
            i=len(currDirectory)-1; for i != -1, i-- {
                if currDirectory[i] == '/' {
                    currDirectory = currDirectory[:i+1]
                    break
                }
            }
            fileName = currDirectory + fileName
        }

        fileNameNoExt = fileName
        i=len(fileNameNoExt)-1; for i != -1, i-- {
            if fileNameNoExt[i] == '/' {
                break
            }
            if fileNameNoExt[i] == '.' {
                fileNameNoExt = fileNameNoExt[:i]
                break
            }
        }

    } else {
        fileName = file[:len(file)-4]
        fileNameNoExt = file[:len(file)-4]
    }

    if isRun {
        fileNameNoExt = "/tmp/__bah_run_"+makeRandomFilename()
        fileName = fileNameNoExt
    }

    gen.debugInfo += rope(".byte 0\n")
    generateRuntimeDebugInfo()

    if isObjectFile == false {
        initFnGen.generateFnEnd(null)
        gen.bss += rope(".global __bss_end\n__bss_end:\n")
        gen.data = programEntry + gen.staticData + gen.debugInfo + rope(".global __data_start\n__data_start:\n") + gen.data
        gen.code += initFnGen.code + globalFuncsGen.code
    } else {
        gen.data = gen.staticData + gen.data
        gen.code += globalFuncsGen.code
    }

    if isSilent == false {
        println("Parsed "+intToStr(totalLines)+" lines in "+intToStr((getTimeUnix() - startTime) / 1000000)+"ms.\033[0m")
    }

    i=0; for i < len(evalTmpOFiles), i++ {
        removeFile(evalTmpOFiles[i])
    }


    if flags.isSet("asm") {
        i=len(fileName)-1; for i != -1, i-- {
            if fileName[i] == '/' {
                break
            }
            if fileName[i] == '.' {
                break
            }
        }
        if i == -1 || fileName[i] != '.' {
            fileName += ".S"
        }
        

        fs.open(fileName, "w")
        fs.writeFile((gen.data + gen.bss + gen.code).toStr())
        fs.close()
        return 0
    }

    if isObjectFile {
        i=len(fileName)-1; for i != -1, i-- {
            if fileName[i] == '/' {
                break
            }
            if fileName[i] == '.' {
                break
            }
        }
        
        if i == -1 || fileName[i] != '.' {
            fileName += ".o"
        }

        cmd = command("as -f -o "+fileName)
        cmd.input = (gen.data + gen.bss + gen.code).toStr()
        cmd.run()
        return 0
    }

    cmd = command("as -f -o "+fileNameNoExt+".o")
    cmd.input = (gen.data + gen.bss + gen.code).toStr()

    if isRun && isFullLink == false {
        stubbedSymbols = []str

        i=0; for i < len(cmd.input), i++ {
            //will skip first line but who cares
            for i < len(cmd.input), i++ {
                if cmd.input[i] == <char>10 {
                    i++
                    break
                }
            }

            if i+5 >= len(cmd.input) {
                break
            }

            if cmd.input[i] == 'c' && cmd.input[i+1] == 'a' && cmd.input[i+2] == 'l' && cmd.input[i+3] == 'l' {
                i += 5

                j=i; for j < len(cmd.input), j++ {
                    if cmd.input[j] == <char>10 {
                        break
                    }
                }

                symName = cmd.input[i:j]

                if symName == "persistentmcpy" {
                    continue
                }

                func = parserCtx.findFunc(symName)

                if func == null {
                    continue
                }

                if func.declared {
                    continue
                }


                cmd.input = cmd.input[:i] + symName + "_STUB" + cmd.input[j:]

                if symName in stubbedSymbols == false {
                    stubbedSymbols[len(stubbedSymbols)] = symName

                    cmd.input += symName + "_STUB:\njmp *"+symName+"\n"
                }
            }
        }
    }

    err = cmd.run()

    if cmd.status != 0 {
        println("Error assembling program")
        println(err)
        return 1
    }

    if isRun && isFullLink == false {
        of = objectFile{}
        if of.open(fileNameNoExt+".o") == false {
            panic("Error openning object file.")
        }
        of.weakLinker()

        mainFn = <function([]str)int>of.getSymbol("main")

        exCode = mainFn(args)

        of.close()

        removeFile(fileNameNoExt+".o")

        return exCode
    }

    libraries = ""
    i=0; for i < len(parserCtx.libraries), i++ {
        if parserCtx.libraries[i][0] == '/' {
            libraries += " "+parserCtx.libraries[i]
            continue
        }
        libraries += " -"+parserCtx.libraries[i]
    }

    for parserCtx.currentCompileNb != 0 {
        compileWaitChannel.receive()
        parserCtx.currentCompileNb--
    }

    if parserCtx.noImports == false {
        writeCache()
    }

    cmd = command("ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o "+fileName+" "+libraries+" "+fileNameNoExt+".o -lc")
    err = cmd.run()

    removeFile(fileNameNoExt+".o")
    if cmd.status != 0 {
        println("Error linking program")
        println(err)
        return 1
    }

    if isRun {
        runArgs = [fileName, null]
        pid = fork()
        if pid == 0 {
            r = execvp(fileName, <ptr>&runArgs)
        } else {
            waitpid(pid, null, 0)
            removeFile(fileName)
        }
        return 0
    }


    if isSilent == false {
        println("\033[1;32mDone. (compiled in "+intToStr((getTimeUnix() - startTime) / 1000000)+"ms)\033[0m")
    }

    // cmd = command("ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o "+fileName+" /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtbeginS.o  "+fileName+".o -lc /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/crtendS.o /usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib/crtn.o")
    // err = cmd.runBytes()

    // removeFile(fileName+".o")
    return 0
}