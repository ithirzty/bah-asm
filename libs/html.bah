#import "iostream.bah"
#import "string.bah"

const HTML_nonClosingTags = []str{
    "meta", 
    "img",
    "!doctype",
    "link",
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "input",
    "param",
    "source",
    "track",
    "wbr"
}
const HTML_nonParsingTags = []str{
    "script",
    "style",
    "svg"
}

//Represents a html element.
struct htmlElement {
    name: str
    attrs: []str
    html: str = ""
    text: str = ""
    children: []htmlElement*
    parent: htmlElement*


    //Used for getting the content of the specified attribute.
    attr(name str) str {
        i=0; for i < len(this.attrs), i++ {
            attr = this.attrs[i]
            attrName = ""
            found = true
            if len(attr) == 0 {
                continue
            }
            j=0; for j < len(attr), j++ {
                if attr[j] == '=' {
                    if j == 0 {
                        found = false
                    }
                    break
                }

                if j == len(name) {
                    found = false
                    break
                }

                if attr[j] != name[j] {
                    found = false
                    break
                }
            }

            if found == false {
                continue
            }

            if j == len(attr) {
                return "true"
            } else {
                if attr[j+1] == '"' || attr[j+1] == <char>39 {
                    return attr[j+2:len(attr)-1]
                }
                return attr[j+1:]

            }
        }
        return ""
    }

    //Used for finding a children of the element corresponding to the specified query.
    find(q str) []htmlElement* {
        elems = []htmlElement*
        tag str
        qs = string(q)
        oqs = qs
        if qs.count(" ") > 0 {
            tag = splitStringBefore(qs, " ")
        } else {
            tag = q
        }
        fc = tag[0]
        if fc == '.' {
            qs.trimLeft(1)
        }
        i=0; for i < len(this.children) {
            c = this.children[i]
            if fc == '#' {

            } else if fc == '.' {
                cl = c.attr("class")
                if strlen(cl) == 0 {
                    i++
                    continue
                }
                classes = splitString(string(cl), " ")
                j=0; for j < len(classes) {
                    class = classes[j]
                    if class.str() == qs.str() {
                        elems[len(elems)] = c
                    }
                    j++
                }
            } else {
                if c.name == tag {
                    qs.trimLeft(strlen(tag))
                    qs.trim()
                    if qs.length > 0 {
                        elems = c.find(qs.str())
                    } else {
                        elems[len(elems)] = c
                    }
                    qs = oqs
                }
            }
            i++
        }
        
        i=0; for i < len(this.children) {
            c = this.children[i]
            es = c.find(q)
            j=0; for j < len(es) {
                elems[len(elems)] = es[j]
                j++
            }
            i++
        }

        return elems
    }

}

//Returns true if the char is either a letter, '-' or '_'
//*Note: this is an internal function.*
isValidHTMLStringChar(c char) bool {
    return isAlphaNumeric(c) || c == '-' || c == '_' || c == '!' || c == ':'
}

//Used for skipping white spaces inside the current char array.
//*Note: this is an internal function.*
skipHTMLspace(s str, i int) int {
    for i < len(s), i++ {
        if isSpace(s[i]) == false {
            break
        }
    }
    return i
}

//Used for parsing a string. Will return an array of elements.
//*Note: this is an internal function, if you are trying to parse a document, use parseHTML().*
parseHTMLElements(s str, parent htmlElement*) []htmlElement* {
    elems = []htmlElement*

    if len(s) == 0 {
        return null
    }

    start = skipHTMLspace(s, 0)
    i=start; for i < len(s), i++ {
        if s[i] == '<' {

            if i + 6 < len(s) && s[i+1] == '!' && s[i+2] == '-' && s[i+3] == '-' {
                i += 4
                for i < len(s) - 2, i++ {
                    if s[i] == '-' && s[i+1] == '-' && s[i+2] == '>' {
                        break
                    }
                }
                continue
            }

            oldStart = start
            if i > start {
                elems[len(elems)] = new htmlElement {
                    name: "text"
                    text: s[start:i]
                    parent: parent
                }
            }
            start = i

            i++
            for i < len(s), i++ {
                if isValidHTMLStringChar(s[i]) == false {
                    break
                }
            }
            if i - start <= 1 {
                delete(elems, len(elems)-1)
                start = oldStart
                continue
            }

            htmlElem = new htmlElement {
                name: strToLower(s[start+1:i])
                parent: parent
            }

            isClosing = htmlElem.name in HTML_nonClosingTags

            start = i

            //parsing attributes
            for i < len(s), i++ {
                i = skipHTMLspace(s, i)

                if s[i] == '>' {
                    i++
                    break
                }

                if i+1 < len(s) && s[i] == '<' && s[i+1] == '/' {
                    delete(elems, len(elems)-1)
                    start = oldStart
                    i = oldStart
                    break
                }

                if isClosing && i+1 < len(s) && s[i] == '/' && s[i+1] == '>' {
                    i += 2
                    break
                }

                start = i
                for i < len(s), i++ {
                    if isValidHTMLStringChar(s[i]) == false {
                        break
                    }
                }

                if i == start {
                    continue
                }

                j = skipHTMLspace(s, i)

                if s[j] != '=' {
                    htmlElem.attrs[len(htmlElem.attrs)] = s[start:i]
                    continue
                }

                i = skipHTMLspace(s, j+1)

                if s[i] == '"' || s[i] == <char>39 {
                    c = s[i]
                    i++
                    for i < len(s), i++ {
                        if s[i] == c {
                            i++
                            break
                        }
                    }
                } else {
                    for i < len(s), i++ {
                        if isValidHTMLStringChar(s[i]) == false {
                            break
                        }
                    }
                }
                htmlElem.attrs[len(htmlElem.attrs)] = s[start:i]
                i--
            }

            if start == oldStart {
                continue
            }

            start = skipHTMLspace(s, i)

            if isClosing {
                elems[len(elems)] = htmlElem
                i--
                continue
            }

            max = len(s) - (len(htmlElem.name) + 2)

            if i > max {
                delete(elems, len(elems)-1)
                start = oldStart
                i = oldStart+1
                continue
            }

            for i < max, i++ {
                if s[i] == '<' && s[i+1] == '/' {
                    i += 2
                    j = 0
                    for i < len(s), i++ {
                        if isValidHTMLStringChar(s[i]) == false {
                            break
                        }
                        if s[i] != htmlElem.name[j] {
                            break
                        }
                        j++

                        if j == len(htmlElem.name) {
                            break
                        }
                    }

                    if j != len(htmlElem.name) {
                        continue
                    }

                    i++
                    if s[i] == '>' {
                        break
                    }
                }
            }

            elems[len(elems)] = htmlElem

            if htmlElem.name in HTML_nonParsingTags {
                htmlElem.text = s[start:i - (len(htmlElem.name) + 2)]
                start = skipHTMLspace(s, i+1)
                continue
            }

            htmlElem.html = s[start:i - (len(htmlElem.name) + 2)]
            htmlElem.children = parseHTMLElements(htmlElem.html, htmlElem)
            start = skipHTMLspace(s, i+1)
        }
    }


    start = skipHTMLspace(s, start)
    for i < start, i-- {
        if isSpace(s[i-1]) == false {
            break
        }
    }
    if start < i {
        elems[len(elems)] = new htmlElement {
            name: "text"
            parent: parent
            text: s[start:i]
        }
    }

    return elems

}

//Used for parsing a HTML document.
//Will return a pointer to the document.
parseHTML(doc str) htmlElement* {
    root = new htmlElement
    root.name = "document"
    root.children = parseHTMLElements(doc, root)
    return root
}