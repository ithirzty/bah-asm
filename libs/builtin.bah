#include "cBinds.bah"

#define len(a ptr) uint
#define panic(s str)

const null = <ptr>0
const true = <bool>1
const false = <bool>0

const strLenSize = 4

struct Bah_Array_Type {
	data: ptr
	length: uint
	realLength: uint
	elemSize: uint
}

__bah_strlenSTR(s str) uint32 {
    if <ptr>s == null {
        return 0
    }
    return *(<uint32*>s)
}

__bah_arrayLength(a Bah_Array_Type*) uint {
    if a == null {
        return 0
    }

    return a.length
}

__bah_compareStr(a str, b str) bool {
    if len(a) != len(b) {
        return false
    }

    i=0; for i < len(a), i++ {
        if a[i] != b[i] {
            return false
        }
    }

    return true
}

cStr(s str) char* {
	if <ptr>s == null {
		return null
	}
	return <char*>(<uint><ptr>s + strLenSize)
}

cArr(arr Bah_Array_Type*) ptr {
    return arr.data
}

clear(arr Bah_Array_Type*) {
    arr.length = 0
}

//Used for deleting an element from an array by its index.
//This will keep the order of the elements.
delete(arr Bah_Array_Type*, i uint) {
    if i >= arr.length || i < 0 {
        return
    }
	if i == arr.length - 1 {
		arr.length--
		return
	}
    elemSize int = arr.elemSize
    data char* = arr.data
    destOffset = elemSize * i
    i++
    offset = elemSize * i
    src char* = <int>data + <int>offset
    dest char* = <int>data + <int>destOffset
    rightNB = arr.length - i

    memmove(dest, src, rightNB * elemSize)
    arr.length--
}

//Like delete() but for a range.
//deleteRange(arr, 1, 3) will delete elements at indexes [1, 2, 3]
deleteRange(arr Bah_Array_Type*, from uint, to uint) {
    if from == to {
        delete(arr, from)
        return
    }


    length = arr.length
    
    elemSize int = arr.elemSize
    data char* = arr.data
    size = elemSize * (to - from)
    dest ptr = <int>data + elemSize * from
    src ptr = <int>dest + size + elemSize
    rightNB = length - to - 1

    memmove(dest, src, rightNB * elemSize)
    arr.length -= (to - from + 1)
}

#include "gc.bah"


print(s str) {
    write(1, s, len(s))
}

println(s str) {
    if <ptr>s == null {
        s = ""
    }
    puts(s)
}

__Bah_panic(e str, loc str) {
    println("panic("+loc+"): "+e)
    exit(1)
}

#define uintToStr(u uint) str

__Bah_realocate_arr(arr Bah_Array_Type*, index uint) {
    if arr == null {
        panic("Trying to set value of null array.")
        return
    }

    if index >= arr.length {
        arr.length = index + 1
    }

    if index < arr.realLength {
        return
    }


    // if index != arr.realLength {
    //     puts("nope!")
    // }

    orl = arr.realLength

    if arr.realLength == 0 {
        arr.realLength = 64
    } else {
        arr.realLength = arr.realLength * 2
    }
    arr.data = memoryRealloc(arr.data, arr.realLength * arr.elemSize)
}

//Used for pre-allocating a number of element to an array.
//The content of the array is not initialized, it may contain garbage.
allocateArray(arr Bah_Array_Type*, nbElems uint) {
    arr.length = nbElems
    arr.realLength = nbElems
    arr.data = memoryAlloc(nbElems * arr.elemSize)
}

buffToStr(b char*) str {
    l = strlen(b)
    r uint32* = memoryAllocSTR(l + 5)
    *r = l
    memcpy(<ptr>(<uint>r+4), b, l)
    return <str>r
}

cStrToBah(b char*) str {
    l = strlen(b)
    r uint32* = memoryAllocSTR(l + 5)
    *r = l
    memcpy(<ptr>(<uint>r+4), b, l)
    return <str>r
}

__bah_argsToArr(argc uint, argv char**) []str {
    arr = []str

    i=0; for i < argc, i++ {
        arr[i] = buffToStr(*<char**>(<uint>argv + i * sizeof(ptr)))
    }

    return arr
}

//Used by the compiler for operations like str[start:end].
strSubstitute(s str, i uint, l uint) str {
	size = l - i
	if i < 0 || size < 0 || size > len(s) {
		panic("builtin: str substitution out of bounds violation.")
	}
	ns uint32* = memoryAllocSTR(size+5)
    *ns = size
	memcpy(<ptr>(<uint><ptr>ns + strLenSize), <ptr>(<uint><ptr>s + i + strLenSize), size)
	return <str>ns
}

//Used by the compiler for operations like array[start:end].
arraySubstitute(arr Bah_Array_Type*, i int, l int) Bah_Array_Type* {
	length = l - i
	if i < 0 || length < 0 || length > arr.length {
		panic("builtin: array substitution out of bounds violation.")
	}
	offset int = i * arr.elemSize

	na = new Bah_Array_Type {
        elemSize: arr.elemSize
        length: length
    }

	size = length * arr.elemSize
	realSize = length * arr.elemSize
	data = memoryAlloc(size)
	oData = arr.data
	memcpy(data, <ptr>(<uint>oData + offset), realSize)
	na.data = data
	return na
}

//Used to convert an array of characters to a str.
arrToStr(arr []char) str {
    strLen = len(arr)
    if len(arr) > 0 && arr[len(arr)-1] == <char>0 {
        strLen--
    }
    a Bah_Array_Type* = arr
    str str = memoryAllocSTR(strLen+5)
    memcpy(<ptr>(<uint><ptr>str + strLenSize), a.data, strLen)
    ln uint32* = str
    *ln = strLen
    return str
}

//Used to convert a str into an array of characters.
strToArr(str str) []char {
    strLen = len(str)
    arr = []char
    a Bah_Array_Type* = arr
    a.data = memoryAlloc(strLen+1)
    memcpy(a.data, <ptr>(<uint><ptr>str + strLenSize), strLen)
    a.length = strLen
    
    return arr
}

//This is used to efficiently construct strs character by character.
//Note that if you want to create a substring of a string efficiently, you can use str[from:to] instead.
struct strBuilder {
    buff: str
    length: uint32

	//Internal function
    _init() {
        this.buff = memoryAllocSTR(65 + strLenSize)
        this.length = 64
    }

	//Used for appending a character to the end of the str.
    append(c char) {
        ln uint32* = this.buff
        l = *ln
        if l >= this.length {
            this.length *= 2
            b = memoryRealloc(this.buff, strLenSize + this.length + 1)
            this.buff = b
			ln = <uint32*>this.buff
        }
        pc = <char*>(<uint><ptr>this.buff + strLenSize + l)
        *pc = c

        *ln = l + 1
    }

	//Used for getting the resulting str.
    str() str {
        return this.buff
    }

}

//need to find wtf is hapening here
#init putchar(<char>0) //fixes bug where libc not initialized if not called from main thread.
